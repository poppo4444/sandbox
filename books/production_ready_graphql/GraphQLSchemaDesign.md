## GraphQL Schema Design
これまでに、GraphQLサーバーがタイプシステムを通じて可能性をどのように表現するかについてたくさん話しました。優れたGraphQL APIの鍵は、これらの可能性を正確に設計することから始まります。任意のAPI、ライブラリ、そして単純な関数と同様に、GraphQLスキーマデザインはあなたのAPIがどれだけ使いやすく理解しやすいかに大きな影響を与えます。この章では、素晴らしいデザインを思い付く方法と、具体的にはGraphQL APIを設計する際に避けるべきパターンまたは使うべきパターンをいくつか説明します。

## 何がAPIを優れたものにするのか？
優れたGraphQL APIを設計する要素について詳しく説明する前に、最終的な結果がどのように見えるべきかについて話すことが重要です。では、一般的に何が優れたAPIを作り出すのでしょうか？おそらく私のお気に入りの表現方法はJoshua Blochから引用するものです：

```
APIは使いやすく、誤用が難しいべきです
```

優れたAPIは、正しいことを行うのを簡単にし、間違ったことを行うのを実際には難しくするべきです。任意の開発者があなたのAPIにアクセスして、彼らが何を達成でき、それをどのように行うかを比較的容易に理解することができる必要があります。私たちのAPIは、APIの最良の使用方法に開発者を導き、またバッドプラクティスから彼らを遠ざけるべきです。全てこれは我々がそれをどのように設計するかによって行われます。

あなたが私と同じような人物であれば、過去にいくつかのAPIの使用に苦労したことがあるでしょう。我々の多くは、期待外れの奇妙な振る舞い、一貫性のない表現、古すぎるドキュメンテーション、そして他にも多数の問題に遭遇したことがあります。もしあなたがよく設計されたAPIと統合する機会を持っていたなら、それが開発者をどれだけ気分良くさせ、いかに迅速に任意の開発者が提供された機能と統合することを可能にするかを知っているはずです。これが、本書で最初に取り上げるデザインが重要な理由です：それはクライアントが統合するのを楽しむAPIを作る際に非常に重要な部分です。

GraphQLは基本的に、良いAPIを設計することを何も容易にしてくれません。それは強力なタイプシステムを提供しますが、それを正しく使わなければ、我々は他の任意のAPIスタイルと同じ罠に陥ることができます。

## デザインファースト
ユーザーに喜ばれるスキーマを作成する最良の方法は、プロジェクトの初期段階からデザインを考えることです。お気に入りのライブラリを使ってすぐに実装を始めたいという誘惑はあるでしょうが、デザインファーストのアプローチを取ることでほとんどの場合、より優れたAPIが得られます。これを行わないと、設計は一般的にシステム内部でどのように実装されているかに密接に結びつき、これはエンドユーザーが気にするべきではない問題となります。

おそらくあなたは、GraphQL APIを構築することに興味がある開発者として、この本を読んでいるのではないでしょうか。しかし、十分に大きな会社で働いていれば、APIがカバーするすべての領域で最も専門知識を持つ人物ではないことはほぼ確実です。これが、自分が提供するユースケースに最も詳しいチームや人々と協力することが非常に重要である理由です。しかし、GraphQLは私たちがこの章で取り上げるいくつかのデザイン上の問題を伴っています。最良のシナリオは、GraphQLの専門家とドメインの専門家が協力して働くことです。
API、特に公開されたものは、一度公開されると変更が非常に難しいです。設計を初めに考え、概念をよく理解することで、将来的な予期せぬ変更のリスクを軽減することが可能になります。

## クライアントファースト
序章で見たように、GraphQLはクライアント中心のAPIです。この哲学は、私たちがGraphQLのAPIをどのように設計するべきかにも影響します。バックエンドのリソースやエンティティの観点からAPIを設計するのは魅力的ですが、何よりも先にクライアントのユースケースを考えてGraphQLのAPIを設計することが非常に重要です。そうすることで、クライアントのニーズに応えるAPIを構築し、使いやすく誤用しにくい設計をすることが可能になります。これを怠ると、クライアントが目指すことを達成するために推測したり大量のドキュメントを読んだり、最悪の場合はそれを達成できなくなったりする一般的なAPIになってしまうことがよくあります。
これが正しく行われていることを確認するための良い方法は、できるだけ早い段階で「最初のクライアント」と協力することです。つまり、デザインを早期にクライアントと共有し、彼らができるだけ早くAPIと統合すること、さらにはAPIデザインに沿ってモックサーバーを提供することを意味します。このプロセスについては第6章で詳しく説明します。これは特に内部やパートナーのAPIでは当然のことで、公開APIでは少し難しい場合もあります。いずれにせよ、APIの受け手になる人々と協力するよう努めるね。

クライアントファーストが常にクライアントの望む通りに行うことを意味するわけではありません。特に、公開APIを扱う際にはそうです。多くの場合、クライアントが問題に遭遇すると、彼らは直接あなたに解決策を持ってきます。彼らが提案している解汓名の実装に入る前に、まず問題について情報を集め、一歩引いて考えることが重要です。問題の背後にはもっと洗練された解決策が存在する可能性が高いです。

同様に、「You Aren’t Going to Need it（YAGNI）」というマントラも、APIの設計において非常に有用です。これはExtremeProgrammingやアジャイルソフトウェアコミュニティから来た言葉です。私たちのAPIは完全であるべきで、つまりクライアントが関心を持っているユースケースを達成するために必要な機能だけを提供するべきです。しかし、それ以上のことは何も公開してはなりません！私は何度もAPIが非推奨になったり変更が必要になったりした例を見てきました。その原因は、誰も考えていない何かが公開され、ひどい設計につながったり、最悪の場合は性能やセキュリティ上の理由からクライアントに公開されるべきでない何かが公開されたりすることです。

もう1つクライアント中心の設計が役立つことは、私たちは実装の詳細に影響されたスキーマを設計していないことを確認することです。あなたのAPIと統合する開発者は、あなたがどのデータベースを使用しているか、サーバーがどのプログラミング言語で構築されているか、バックエンドでどのような設計問題があるかなどとは関係ありません。GraphQLスキーマは機能へのエントリーポイントであり、バックエンドの実装詳細にそれを結びつけることを避けるべきです。もちろん、可用性やパフォーマンスなどの問題が設計を左右することもありますが、それも非常に慎重に、クライアントを念頭に置いて行うべきです。これはより優れたAPIを作るだけでなく、内部事情に依存した外部APIが抱える多くの問題を避けることにもなります。私たちは、外部のクライアントが使用するAPIよりもはるかに素早いペースで内部事情を変更できるようにしたいのです。スキーマを構築する際にはこれを念頭に置くようにしてください。

GraphQLの型付け特性は、データベースや他のデータソースからGraphQL APIを構築するツールを提供する多くのベンダーを引き付けるようです。あなたが "クライアントファースト" の視点でAPIを構築しているならば、これはめったに意味をなしません。これはこれまでに述べた全てに反します：
- スキーマが実装の問題に依存してしまいます。
- 結果は、テーブルやエンティティを中心に非常に一般的になります。
- クライアントのニーズは全く考慮されていません。
- 通常、必要以上に多くのことが公開されます（YAGNI）。

これらのツールが無用であると言っているわけではありません。これらは素早いプロトタイピングや、データベース上のGraphQLレイヤーが実際に必要な場合に便利です。しかし、API設計について真剣に考え、洗練されたクライアント中心の体験型APIを求める私たちにとって、これらのツールが求めている結果を得られることはめったにありません。

他のタイプのジェネレーターは、既存のAPI定義、Swagger/OpenAPIを取り、それをGraphQLスキーマに翻訳するものです。これらのツールは非常に注意深く使いましょう。APIはそれが構築されるアーキテクチャやスタイルを考慮に入れるべきです。RESTとGraphQLは異なる設計上の問題を抱えています。たとえば、REST APIでは、リソースに焦点を当て、HTTPメソッドのセマンティクスを用いてそれらと対話するべきです。非常に素朴なジェネレーターはpostUserやputProductのような変異を生成するでしょうが、実際にはGraphQLでのリモートプロシージャコールのように見えるAPIスタイルを扱っている場合、createUserやupdateUserが最も適した呼び出しになるでしょう。これらのツールを調整してまともな結果を出すことは可能ですが、人間が設計したGraphQLファーストの策定されたAPIと同じくらいきれいに設計されることはありません。当然、コンテキストによってはこの取引が受け入れられるかもしれませんが、それを理解することは重要です。

素晴らしいAPIの特性について説明したので、次に具体的な良い実践に進みましょう！

### Naming

名前はAPIがあなたに語りかけているのだ

上の引用は、またしてもJoshua BlochのHow To Design A Good API and Why it Mattersからの引用である。
私はこの引用が大好きで、主に優れたJava APIを設計することに関連しているが、GraphQLのようなウェブAPIにも非常によく当てはまる。
ネーミングを正しくするのはとても難しいが、考えることはとても重要だ。
良い名前は、ドキュメントを読んだり、最悪推測したりする前に、そのAPIが何をするものなのかという情報を即座に伝えます。
実際、良いネーミングはそれだけで正しい設計に導いてくれることが多い。
ネーミングに関しては、一貫性が王様だ。クライアントは新しいAPIを使う前に、時間をかけて理解しなければならないことを忘れないでほしい。
物事が一貫していれば、新しいAPIを発見することはユーザーにとって自然に感じられるだろう。
ここに良い例がある：

```gql
type Query {
  products(ids: [ID!]): [Product!]!
  findPosts(ids: [ID!]): [Post!]!
}

type Mutation {
  addProduct(input: AddProductInput): AddProductPayload
  createPost(input: CreatePostInput): CreatePostPayload
}
```

このスキーマは、命名に関してはまったく一貫性がない。クエリ側では、オブジェクトのリストを取得するために2つの異なる命名スキームがあることに注目してほしい。
一方では、投稿を見つけるにはfindというプレフィックスを付け、もう一方では、商品を見つけるには単純なproductsフィールドを付ける。
このようなスキーマは予測不可能なので、クライアントにとっては実に使いにくい。すでにfindPostsを使用していて、productsと統合したいクライアントは、フィールドが存在しないというエラーに遭遇するか、単に探しているものが見つからないまで、findProductsを使用してそれができると仮定する可能性が高い。
このようなアクション動詞に一貫性を持たせるだけでなく、ドメインコンセプトの名前の付け方にも一貫性を持たせるべきです。
例えば、BlogPostとPostというように、実際に異なる概念でない限り、どこかにBlogPost、どこかにPostというような名前をつけないことだ。

もう一つの良い例は、Mutationタイプにある。
一方ではaddProductを使ってショップに商品を追加できるが、ソーシャルメディアへの投稿を追加するにはcreatePostを使う。
このような接頭辞の問題はよくあります。このような不一致が積み重なると、APIを探索したり使ったりするのが本当に難しくなります。

APIの対称性も重要だ。
対称性とは、例えば、特定のエンティティが与えられたときに、対称的なアクションが可能であることを確認することである。
例えば、publishPostの変異があると、unpublishPostの変異があるように見える。
特に、スキーマ内の他の変異がそのように対称的であればなおさらです。
最小驚嘆の原則に従うことは、一般的に非常に良い考えです。

スキーマ・メンバーの命名に関しては、過度に具体的にすることも考慮すべき良いアイデアだ。
具体的にすることで、そのオブジェクトやフィールドが一体何を表しているのかについてのクライアントの混乱を避けるだけでなく、GraphQL APIプロバイダーにも役立ちます。多くの大規模システムでは、似たような概念に複数の名前が付けられています。
Event（イベント）」や「User（ユーザー）」のような非常に一般的または汎用的な名前が導入されると、多くの場合、命名領域が占有され、より具体的な概念を導入することが難しくなります。
一般的な名前は後々役に立つかもしれないので、残しておくようにしましょう。
ネーミングの失敗例を挙げよう。クエリールートのビューアーとして機能するUserオブジェクトを紹介します。
このオブジェクトには、現在ログインしているユーザーに関する情報が含まれています。

```gql
type Query {
  viewer: User!
}

type User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

数カ月後、チームは、このオブジェクトが、チームメンバーをリストアップするときなど、ログインしているユーザーの範囲外で使用されていることに気づく：

```gql
type Query {
  viewer: User!
  team(id: ID!): Team
}
type Team {
  members: [User!]!
}
type User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

しかし、チームメンバーの個人情報を公開するのは意味がないことにすぐに気づく。
ビューワーでないユーザーがこれらのフィールドにアクセスするたびにエラーを発生させるか、新しい型を作る必要がある。最初の解決策は、かなり非現実的で、クライアントにとって良いとは言えず、実装に関してもかなりもろい。
チームは大規模な非推奨化を行う必要があり、Userはむしろインターフェイスであり、ViewerとTeamMemberはおそらく独自の型であるべきだったと気づくだろう：

```gql
type Query {
  user(id: ID!): User
  viewer: Viewer!
  team(id: ID!): Team
}
type Team {
  members: [User!]!
}
interface User {
  name: String!
}
type TeamMember implements User {
  name: String!
  isAdmin: Boolean!
}
type Viewer implements User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

具体的なネーミングをすることで、大きな非推奨化を避けることができたし、クライアントにとっても使いやすく、理解しやすいものになった。
正しいネーミングは正しいデザインへと導いてくれるが、間違ったネーミングは悪いデザインへと深みにはまっていくだけだ。

### Descriptions

ほとんどのGraphQLスキーマメンバは、記述を使用してドキュメント化することができる。
SDL で言えば、次のようになります：

```gql
"""
An order represents a `Checkout` that was paid by a `Customer` """
type Order {
  items: [LineItem!]!
}
```

ディスクリプションは、ドキュメントのような外部ソースで見つけるのではなく、スキーマに直接この情報をエンコードするので素晴らしい。
探索するとき GraphiQLを使用してAPIを探索するとき、ユーザーはスキーマと一緒に記述を素早く読むことができます。

スキーマのほぼすべてのエンティティを記述するのは良いアイデアだ。
良い記述は、スキーマの型が何を表しているのか、どのような突然変異が起こるのか、などを明確に伝えるべきです。
しかし、記述が素晴らしいのと同様に、スキーマの設計が不十分であることが明らかになることもある。

理想的には、記述はケーキの上のアイシングに過ぎません。あなたのAPIと統合しようとするクライアントが、あなたのAPIがどのように利用でき、どのように利用すべきかを理解するために、説明を読む必要はほとんどないはずだ。
すでに話したように、スキーマはすでに物事が何を意味し、どのように使われるべきかを伝えているはずだ。
典型的な匂いは、エッジケースを記述する記述、条件式を含む記述、文脈に応じた振る舞いを記述する記述です。
肝心なのは、記述を使うことですが、ユースケースを理解するためにユーザーを記述に依存させないことです。
GraphQLドキュメントについては第10章で詳しく説明します。

### Use the Scehma, Luke!


GraphQLはAPIを設計するために、この素晴らしく表現力豊かな型システムを提供してくれます。
それをフルに活用することで、ユーザーが理解するための実行時の動作に依存しない、驚くほど表現力豊かなAPIを実現することができます。
次の例では、名前、価格、型を持つProduct型のスキーマがあります。タイプは、"アパレル"、"食品"、"おもちゃ "などの商品のタイプである。

```gql
type Product {
  name: String!
  priceInCents: Int!
  type: String!
}
```

このスキーマの潜在的な問題のひとつは、クライアントがこの型から何が出てくるかを理解するのに非常に苦労するかもしれないということだ。
どのようにtypeフィールドを扱えばいいのだろうか？もしtypeに設定された数の項目があるなら、このスキーマを "自己文書化 "し、実行時の保証も提供する、より良い方法は、ここでenum型を使うことだろう：

```gql
enum ProductType {
  APPAREL
FOOD
TOYS
}
type Product {
  name: String!
  priceInCents: Int!
  type: ProductType!
}
```

もう1つの一般的で魅力的な設計上の問題は、スキーマの一部として完全に構造化されていないデータを持つことです。
これはしばしば、フィールドをどのようにパースするかを示す記述を持つString型か、時にはJSONのようなスカラー型として行われます。

```gql
type Product {
  metaAttributes: JSON!
}
type User {
# JSON encoded string with a list of user tags tags: String!
}
```

ほとんどの場合、より良いアプローチは、これらのことを表現するために、より強力なスキーマを使用することである。

```gql
type ProductMetaAttribute {
  key: String!
  value: String!
}
type Product {
  metaAttributes: [ProductMetaAttribute!]!
}
```

これは非常に似ているように見えるかもしれないが、型付きスキーマによって、クライアントはこの動作をはるかに優れた方法で処理できるようになり、クライアントが壊れることを恐れることなくスキーマを長期にわたって進化させることができる。
カスタムエンコーディングのスカラーや文字列を使用するとすぐに、型付けされた GraphQLスキーマが与えてくれるすべてを失うことになる。
たとえば、潜在的に再帰的なデータ構造など、どうしてもスキーマを使用しなければならない場合は、注意して使用してください。できる限り強力なスキーマを使用するようにしてください。

例えば、カスタム・スカラーは、文字列としてシリアライズされたフィールドをより有用な型に変えるのに役立つかもしれない：

```gql
type Product {
# Instead of a string description, we use a
# custom scalar to indicate to clients
# that they can treat the result of this field # as valid markdown.
description: Markdown
}
scalar Markdown
```

また、より正確な検証のための入力タイプとして使用することもできる：

```gql
input CreateUser {
  email: EmailAddress
}
# A valid email address according to RFC5322
scalar EmailAddress
```

要するに、より強力なスキーマを使う機会があれば、すぐにそれを検討すべきだということだ。
これは、単純なスカラーではなく、より複雑なオブジェクト・タイプを使用すること、列挙型を使用すること、そして意味のある場合はカスタム・スカラーを使用することでもよい。
