## GraphQL Schema Design
これまでに、GraphQLサーバーがタイプシステムを通じて可能性をどのように表現するかについてたくさん話しました。優れたGraphQL APIの鍵は、これらの可能性を正確に設計することから始まります。任意のAPI、ライブラリ、そして単純な関数と同様に、GraphQLスキーマデザインはあなたのAPIがどれだけ使いやすく理解しやすいかに大きな影響を与えます。この章では、素晴らしいデザインを思い付く方法と、具体的にはGraphQL APIを設計する際に避けるべきパターンまたは使うべきパターンをいくつか説明します。

## 何がAPIを優れたものにするのか？
優れたGraphQL APIを設計する要素について詳しく説明する前に、最終的な結果がどのように見えるべきかについて話すことが重要です。では、一般的に何が優れたAPIを作り出すのでしょうか？おそらく私のお気に入りの表現方法はJoshua Blochから引用するものです：

```
APIは使いやすく、誤用が難しいべきです
```

優れたAPIは、正しいことを行うのを簡単にし、間違ったことを行うのを実際には難しくするべきです。任意の開発者があなたのAPIにアクセスして、彼らが何を達成でき、それをどのように行うかを比較的容易に理解することができる必要があります。私たちのAPIは、APIの最良の使用方法に開発者を導き、またバッドプラクティスから彼らを遠ざけるべきです。全てこれは我々がそれをどのように設計するかによって行われます。

あなたが私と同じような人物であれば、過去にいくつかのAPIの使用に苦労したことがあるでしょう。我々の多くは、期待外れの奇妙な振る舞い、一貫性のない表現、古すぎるドキュメンテーション、そして他にも多数の問題に遭遇したことがあります。もしあなたがよく設計されたAPIと統合する機会を持っていたなら、それが開発者をどれだけ気分良くさせ、いかに迅速に任意の開発者が提供された機能と統合することを可能にするかを知っているはずです。これが、本書で最初に取り上げるデザインが重要な理由です：それはクライアントが統合するのを楽しむAPIを作る際に非常に重要な部分です。

GraphQLは基本的に、良いAPIを設計することを何も容易にしてくれません。それは強力なタイプシステムを提供しますが、それを正しく使わなければ、我々は他の任意のAPIスタイルと同じ罠に陥ることができます。

## デザインファースト
ユーザーに喜ばれるスキーマを作成する最良の方法は、プロジェクトの初期段階からデザインを考えることです。お気に入りのライブラリを使ってすぐに実装を始めたいという誘惑はあるでしょうが、デザインファーストのアプローチを取ることでほとんどの場合、より優れたAPIが得られます。これを行わないと、設計は一般的にシステム内部でどのように実装されているかに密接に結びつき、これはエンドユーザーが気にするべきではない問題となります。

おそらくあなたは、GraphQL APIを構築することに興味がある開発者として、この本を読んでいるのではないでしょうか。しかし、十分に大きな会社で働いていれば、APIがカバーするすべての領域で最も専門知識を持つ人物ではないことはほぼ確実です。これが、自分が提供するユースケースに最も詳しいチームや人々と協力することが非常に重要である理由です。しかし、GraphQLは私たちがこの章で取り上げるいくつかのデザイン上の問題を伴っています。最良のシナリオは、GraphQLの専門家とドメインの専門家が協力して働くことです。
API、特に公開されたものは、一度公開されると変更が非常に難しいです。設計を初めに考え、概念をよく理解することで、将来的な予期せぬ変更のリスクを軽減することが可能になります。

## クライアントファースト
序章で見たように、GraphQLはクライアント中心のAPIです。この哲学は、私たちがGraphQLのAPIをどのように設計するべきかにも影響します。バックエンドのリソースやエンティティの観点からAPIを設計するのは魅力的ですが、何よりも先にクライアントのユースケースを考えてGraphQLのAPIを設計することが非常に重要です。そうすることで、クライアントのニーズに応えるAPIを構築し、使いやすく誤用しにくい設計をすることが可能になります。これを怠ると、クライアントが目指すことを達成するために推測したり大量のドキュメントを読んだり、最悪の場合はそれを達成できなくなったりする一般的なAPIになってしまうことがよくあります。
これが正しく行われていることを確認するための良い方法は、できるだけ早い段階で「最初のクライアント」と協力することです。つまり、デザインを早期にクライアントと共有し、彼らができるだけ早くAPIと統合すること、さらにはAPIデザインに沿ってモックサーバーを提供することを意味します。このプロセスについては第6章で詳しく説明します。これは特に内部やパートナーのAPIでは当然のことで、公開APIでは少し難しい場合もあります。いずれにせよ、APIの受け手になる人々と協力するよう努めるね。

クライアントファーストが常にクライアントの望む通りに行うことを意味するわけではありません。特に、公開APIを扱う際にはそうです。多くの場合、クライアントが問題に遭遇すると、彼らは直接あなたに解決策を持ってきます。彼らが提案している解汓名の実装に入る前に、まず問題について情報を集め、一歩引いて考えることが重要です。問題の背後にはもっと洗練された解決策が存在する可能性が高いです。

同様に、「You Aren’t Going to Need it（YAGNI）」というマントラも、APIの設計において非常に有用です。これはExtremeProgrammingやアジャイルソフトウェアコミュニティから来た言葉です。私たちのAPIは完全であるべきで、つまりクライアントが関心を持っているユースケースを達成するために必要な機能だけを提供するべきです。しかし、それ以上のことは何も公開してはなりません！私は何度もAPIが非推奨になったり変更が必要になったりした例を見てきました。その原因は、誰も考えていない何かが公開され、ひどい設計につながったり、最悪の場合は性能やセキュリティ上の理由からクライアントに公開されるべきでない何かが公開されたりすることです。

もう1つクライアント中心の設計が役立つことは、私たちは実装の詳細に影響されたスキーマを設計していないことを確認することです。あなたのAPIと統合する開発者は、あなたがどのデータベースを使用しているか、サーバーがどのプログラミング言語で構築されているか、バックエンドでどのような設計問題があるかなどとは関係ありません。GraphQLスキーマは機能へのエントリーポイントであり、バックエンドの実装詳細にそれを結びつけることを避けるべきです。もちろん、可用性やパフォーマンスなどの問題が設計を左右することもありますが、それも非常に慎重に、クライアントを念頭に置いて行うべきです。これはより優れたAPIを作るだけでなく、内部事情に依存した外部APIが抱える多くの問題を避けることにもなります。私たちは、外部のクライアントが使用するAPIよりもはるかに素早いペースで内部事情を変更できるようにしたいのです。スキーマを構築する際にはこれを念頭に置くようにしてください。

GraphQLの型付け特性は、データベースや他のデータソースからGraphQL APIを構築するツールを提供する多くのベンダーを引き付けるようです。あなたが "クライアントファースト" の視点でAPIを構築しているならば、これはめったに意味をなしません。これはこれまでに述べた全てに反します：
- スキーマが実装の問題に依存してしまいます。
- 結果は、テーブルやエンティティを中心に非常に一般的になります。
- クライアントのニーズは全く考慮されていません。
- 通常、必要以上に多くのことが公開されます（YAGNI）。

これらのツールが無用であると言っているわけではありません。これらは素早いプロトタイピングや、データベース上のGraphQLレイヤーが実際に必要な場合に便利です。しかし、API設計について真剣に考え、洗練されたクライアント中心の体験型APIを求める私たちにとって、これらのツールが求めている結果を得られることはめったにありません。

他のタイプのジェネレーターは、既存のAPI定義、Swagger/OpenAPIを取り、それをGraphQLスキーマに翻訳するものです。これらのツールは非常に注意深く使いましょう。APIはそれが構築されるアーキテクチャやスタイルを考慮に入れるべきです。RESTとGraphQLは異なる設計上の問題を抱えています。たとえば、REST APIでは、リソースに焦点を当て、HTTPメソッドのセマンティクスを用いてそれらと対話するべきです。非常に素朴なジェネレーターはpostUserやputProductのような変異を生成するでしょうが、実際にはGraphQLでのリモートプロシージャコールのように見えるAPIスタイルを扱っている場合、createUserやupdateUserが最も適した呼び出しになるでしょう。これらのツールを調整してまともな結果を出すことは可能ですが、人間が設計したGraphQLファーストの策定されたAPIと同じくらいきれいに設計されることはありません。当然、コンテキストによってはこの取引が受け入れられるかもしれませんが、それを理解することは重要です。

素晴らしいAPIの特性について説明したので、次に具体的な良い実践に進みましょう！

### Naming

名前はAPIがあなたに語りかけているのだ

上の引用は、またしてもJoshua BlochのHow To Design A Good API and Why it Mattersからの引用である。
私はこの引用が大好きで、主に優れたJava APIを設計することに関連しているが、GraphQLのようなウェブAPIにも非常によく当てはまる。
ネーミングを正しくするのはとても難しいが、考えることはとても重要だ。
良い名前は、ドキュメントを読んだり、最悪推測したりする前に、そのAPIが何をするものなのかという情報を即座に伝えます。
実際、良いネーミングはそれだけで正しい設計に導いてくれることが多い。
ネーミングに関しては、一貫性が王様だ。クライアントは新しいAPIを使う前に、時間をかけて理解しなければならないことを忘れないでほしい。
物事が一貫していれば、新しいAPIを発見することはユーザーにとって自然に感じられるだろう。
ここに良い例がある：

```gql
type Query {
  products(ids: [ID!]): [Product!]!
  findPosts(ids: [ID!]): [Post!]!
}

type Mutation {
  addProduct(input: AddProductInput): AddProductPayload
  createPost(input: CreatePostInput): CreatePostPayload
}
```

このスキーマは、命名に関してはまったく一貫性がない。クエリ側では、オブジェクトのリストを取得するために2つの異なる命名スキームがあることに注目してほしい。
一方では、投稿を見つけるにはfindというプレフィックスを付け、もう一方では、商品を見つけるには単純なproductsフィールドを付ける。
このようなスキーマは予測不可能なので、クライアントにとっては実に使いにくい。すでにfindPostsを使用していて、productsと統合したいクライアントは、フィールドが存在しないというエラーに遭遇するか、単に探しているものが見つからないまで、findProductsを使用してそれができると仮定する可能性が高い。
このようなアクション動詞に一貫性を持たせるだけでなく、ドメインコンセプトの名前の付け方にも一貫性を持たせるべきです。
例えば、BlogPostとPostというように、実際に異なる概念でない限り、どこかにBlogPost、どこかにPostというような名前をつけないことだ。

もう一つの良い例は、Mutationタイプにある。
一方ではaddProductを使ってショップに商品を追加できるが、ソーシャルメディアへの投稿を追加するにはcreatePostを使う。
このような接頭辞の問題はよくあります。このような不一致が積み重なると、APIを探索したり使ったりするのが本当に難しくなります。

APIの対称性も重要だ。
対称性とは、例えば、特定のエンティティが与えられたときに、対称的なアクションが可能であることを確認することである。
例えば、publishPostの変異があると、unpublishPostの変異があるように見える。
特に、スキーマ内の他の変異がそのように対称的であればなおさらです。
最小驚嘆の原則に従うことは、一般的に非常に良い考えです。

スキーマ・メンバーの命名に関しては、過度に具体的にすることも考慮すべき良いアイデアだ。
具体的にすることで、そのオブジェクトやフィールドが一体何を表しているのかについてのクライアントの混乱を避けるだけでなく、GraphQL APIプロバイダーにも役立ちます。多くの大規模システムでは、似たような概念に複数の名前が付けられています。
Event（イベント）」や「User（ユーザー）」のような非常に一般的または汎用的な名前が導入されると、多くの場合、命名領域が占有され、より具体的な概念を導入することが難しくなります。
一般的な名前は後々役に立つかもしれないので、残しておくようにしましょう。
ネーミングの失敗例を挙げよう。クエリールートのビューアーとして機能するUserオブジェクトを紹介します。
このオブジェクトには、現在ログインしているユーザーに関する情報が含まれています。

```gql
type Query {
  viewer: User!
}

type User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

数カ月後、チームは、このオブジェクトが、チームメンバーをリストアップするときなど、ログインしているユーザーの範囲外で使用されていることに気づく：

```gql
type Query {
  viewer: User!
  team(id: ID!): Team
}
type Team {
  members: [User!]!
}
type User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

しかし、チームメンバーの個人情報を公開するのは意味がないことにすぐに気づく。
ビューワーでないユーザーがこれらのフィールドにアクセスするたびにエラーを発生させるか、新しい型を作る必要がある。最初の解決策は、かなり非現実的で、クライアントにとって良いとは言えず、実装に関してもかなりもろい。
チームは大規模な非推奨化を行う必要があり、Userはむしろインターフェイスであり、ViewerとTeamMemberはおそらく独自の型であるべきだったと気づくだろう：

```gql
type Query {
  user(id: ID!): User
  viewer: Viewer!
  team(id: ID!): Team
}
type Team {
  members: [User!]!
}
interface User {
  name: String!
}
type TeamMember implements User {
  name: String!
  isAdmin: Boolean!
}
type Viewer implements User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

具体的なネーミングをすることで、大きな非推奨化を避けることができたし、クライアントにとっても使いやすく、理解しやすいものになった。
正しいネーミングは正しいデザインへと導いてくれるが、間違ったネーミングは悪いデザインへと深みにはまっていくだけだ。

### Descriptions

ほとんどのGraphQLスキーマメンバは、記述を使用してドキュメント化することができる。
SDL で言えば、次のようになります：

```gql
"""
An order represents a `Checkout` that was paid by a `Customer` """
type Order {
  items: [LineItem!]!
}
```

ディスクリプションは、ドキュメントのような外部ソースで見つけるのではなく、スキーマに直接この情報をエンコードするので素晴らしい。
探索するとき GraphiQLを使用してAPIを探索するとき、ユーザーはスキーマと一緒に記述を素早く読むことができます。

スキーマのほぼすべてのエンティティを記述するのは良いアイデアだ。
良い記述は、スキーマの型が何を表しているのか、どのような突然変異が起こるのか、などを明確に伝えるべきです。
しかし、記述が素晴らしいのと同様に、スキーマの設計が不十分であることが明らかになることもある。

理想的には、記述はケーキの上のアイシングに過ぎません。あなたのAPIと統合しようとするクライアントが、あなたのAPIがどのように利用でき、どのように利用すべきかを理解するために、説明を読む必要はほとんどないはずだ。
すでに話したように、スキーマはすでに物事が何を意味し、どのように使われるべきかを伝えているはずだ。
典型的な匂いは、エッジケースを記述する記述、条件式を含む記述、文脈に応じた振る舞いを記述する記述です。
肝心なのは、記述を使うことですが、ユースケースを理解するためにユーザーを記述に依存させないことです。
GraphQLドキュメントについては第10章で詳しく説明します。

### Use the Scehma, Luke!


GraphQLはAPIを設計するために、この素晴らしく表現力豊かな型システムを提供してくれます。
それをフルに活用することで、ユーザーが理解するための実行時の動作に依存しない、驚くほど表現力豊かなAPIを実現することができます。
次の例では、名前、価格、型を持つProduct型のスキーマがあります。タイプは、"アパレル"、"食品"、"おもちゃ "などの商品のタイプである。

```gql
type Product {
  name: String!
  priceInCents: Int!
  type: String!
}
```

このスキーマの潜在的な問題のひとつは、クライアントがこの型から何が出てくるかを理解するのに非常に苦労するかもしれないということだ。
どのようにtypeフィールドを扱えばいいのだろうか？もしtypeに設定された数の項目があるなら、このスキーマを "自己文書化 "し、実行時の保証も提供する、より良い方法は、ここでenum型を使うことだろう：

```gql
enum ProductType {
  APPAREL
FOOD
TOYS
}
type Product {
  name: String!
  priceInCents: Int!
  type: ProductType!
}
```

もう1つの一般的で魅力的な設計上の問題は、スキーマの一部として完全に構造化されていないデータを持つことです。
これはしばしば、フィールドをどのようにパースするかを示す記述を持つString型か、時にはJSONのようなスカラー型として行われます。

```gql
type Product {
  metaAttributes: JSON!
}
type User {
# JSON encoded string with a list of user tags tags: String!
}
```

ほとんどの場合、より良いアプローチは、これらのことを表現するために、より強力なスキーマを使用することである。

```gql
type ProductMetaAttribute {
  key: String!
  value: String!
}
type Product {
  metaAttributes: [ProductMetaAttribute!]!
}
```

これは非常に似ているように見えるかもしれないが、型付きスキーマによって、クライアントはこの動作をはるかに優れた方法で処理できるようになり、クライアントが壊れることを恐れることなくスキーマを長期にわたって進化させることができる。
カスタムエンコーディングのスカラーや文字列を使用するとすぐに、型付けされた GraphQLスキーマが与えてくれるすべてを失うことになる。
たとえば、潜在的に再帰的なデータ構造など、どうしてもスキーマを使用しなければならない場合は、注意して使用してください。できる限り強力なスキーマを使用するようにしてください。

例えば、カスタム・スカラーは、文字列としてシリアライズされたフィールドをより有用な型に変えるのに役立つかもしれない：

```gql
type Product {
# Instead of a string description, we use a
# custom scalar to indicate to clients
# that they can treat the result of this field # as valid markdown.
description: Markdown
}
scalar Markdown
```

また、より正確な検証のための入力タイプとして使用することもできる：

```gql
input CreateUser {
  email: EmailAddress
}
# A valid email address according to RFC5322
scalar EmailAddress
```

要するに、より強力なスキーマを使う機会があれば、すぐにそれを検討すべきだということだ。
これは、単純なスカラーではなく、より複雑なオブジェクト・タイプを使用すること、列挙型を使用すること、そして意味のある場合はカスタム・スカラーを使用することでもよい。

### Expressive Schemas

GraphQLの型システムは、真に表現力豊かなAPIを構築することを可能にする。
これはどういう意味でしょうか？
表現力豊かなAPIは、クライアント開発者がAPIがどのように使用されるのかを容易に理解できるようにします。
使いやすく、誤用しにくいのです。
それだけでなく、最後のセクションで見たように、GraphQLスキーマはAPIプロバイダーがドキュメントを見たり、最悪実装したりする前に、APIがどのように使われるかを表現することを可能にする。

表現力豊かなスキーマを構築する1つの方法は、nullabilityを利用することだ。
GraphQL APIが商品を見つける方法を提供している例を見てみよう。
商品はグローバルIDでも名前でも参照できる。
これを実現する1つの方法は、オプションでidフィールドとnameフィールドの両方を受け付けるfindProductフィールドを作ることです：

```gql
type Query {
  # Find a query by id or by name. Passing none or both
  # will result in a NotFound error.
  findProduct(id: ID, name: String): Product
}
```

このデザインは確かにクライアントのニーズを解決するだろう。
しかし、直感的ではまったくない。
もしクライアントが引数を一つも与えなかったらどうなるのか？
両方を指定した場合は？
どちらの場合も、サーバーはおそらくエラーを返すだろう。
同じユースケースを解決する方法があるが、それを明示的に文書化したり、開発者に実行時に発見させたりする必要はない：

```gql
type Query {
  productByID(id: ID!): Product
  productByName(name: String!): Product
}
```


少し驚かれる方もいらっしゃるかもしれません。
これらのフィールドはとても似ているので、同じフィールドを再利用できないのだろうか？
実際には、序章で少し取り上げたように、GraphQLでさまざまな方法を提供することを恐れるべきではありません。
商品をフェッチする5つの異なる方法を公開したとしても、既存のクライアントにオーバーヘッドを追加することにはなりません。
これらのクライアントは、単に彼らのユースケースに最適なものを選択するだけだとわかっているからです。
このAPIは悪用されにくい。
スキーマ自体が、バリデーション時に、クライアントにフィールドの使い方を指示する。もっと複雑な例を見てみよう：

```gql
type Payment {
  creditCardNumber: String
  creditCardExp: String
  giftCardCode: String
}
```

これは顧客による支払いを表すPaymentタイプです。
注文の支払い方法に応じて、入力可能な3つのフィールドがあります。
クレジットカードが使用された場合、creditCardNumber と creditCardExp フィールドが入力されます。
さらに、注文にギフトカードが使用された場合は、giftCardCode フィールドが存在します。
私たちが改善できる最初のことは、これらの事柄のいくつかを表現するために、より強力なスキーマを使用することです。

```gql
type Payment {
  creditCardNumber: CreditCardNumber
  creditCardExpiration: CreditCardExpiration
  giftCardCode: String
}

# Represents a 16 digits credit card number
scalar CreditCardNumber

type CreditCardExpiration {
  isExpired: Boolean!
  month: Int!
  year: Int!
}
```

いくつかの問題に対処しました。
クレジットカードの有効期限をString型にしたことで、クライアントがどのようなフォーマットを提供すべきかを把握するのが難しくなりましたが、その代わりに、月と年の両方に整数フィールドを持つCardExpirationDetails型にリファクタリングしました。
これは、クライアントが渡さなければならない文字列よりも使いやすいだけでなく、私たちが進化するにつれて、この有効期限詳細型にフィールドを追加することができます。
例えば、最終的にはisExpired： ブール値フィールドを追加して、このロジックでクライアントを支援することができます。
また、クレジットカード番号にはカスタムのスカラーを使いました。
クレジットカード番号はかなり特殊なフォーマットなので、クライアントにもう少しセマンティクスを提供します。

まだ改善の余地がある。
すべてのフィールドがnull可能であることに注目してほしい。
つまり、クライアントが実行時にペイメント・オブジェクトがどのように見えるかを知ることさえ難しいのだ。
これを改善することができる：

```gql
type Payment {
  creditCard: CreditCard
  giftCardCode: String
}

type CreditCard {
  number: CreditCardNumber!
  expiration: CreditCardExpiration!
}

# Represents a 16 digits credit card number
scalar CreditCardNumber

type CreditCardExpiration {
  isExpired: Boolean!
  month: Int!
  year: Int!
}
```

すでにずっとすっきりしている！
クレジットカードに関連するすべての入力フィールドを含むオブジェクトタイプを使用しました。
今、スキーマは、クレジットカードの入力が渡された場合、必須となったフィールド番号と有効期限によって示されるように、すべてのフィールドを含まなければならないことを表現しています。
以前のバージョンでは、このような条件分岐をスキーマに任せるのではなく、実装で処理しなければなりませんでした。
この種のリファクタリングが必要かもしれないことを示す一般的な匂いは、フィールドの接頭辞を見てみることです。
ある型の複数のフィールドがプレフィックスを共有している場合、それらは新しいオブジェクト型の下にある可能性があります。
これにより、ルート（この場合はPaymentオブジェクト）にフィールドを追加する代わりに、スキーマをより良い方法で進化させることができます。

この原則を別の言い方にすると、「不可能な状態を不可能にする（Make Impossible States Impossi-ble）」という言葉になる。
誰が最初に言ったのか探すのは難しいが、強く型付けされた言語に関してはよく使われる言葉だ。
その意味は、スキーマの型に注目すると、この型は一貫性のない情報を持つことを不可能にすべきだということだ。
とても簡単な例を見てみよう。
誰かが買いたい商品のセットを含むカート・オブジェクトがあります。
このカート・オブジェクトはまた、誰かが商品の代金を支払ったかどうか、これまでにいくら支払ったかを知ることができる属性を持っています。

```gql
type Cart {
  paid: Boolean
  amountPaid: Money
  items: [CartItem!]!
}
```

このスキーマを考えると、クライアントがあり得ない状態を表すデータを取得することは残念ながら可能です。
例えば、カートは支払い済みであり、amountPaidはnullであると言うことができますが、これは意味がありません：

```json
{
  "data": {
    "cart": {
      "paid": true,
      "amountPaid": null,
      "item": [...]
    } 
  }
}
```

あるいはその逆で、amountPaidがすべて揃っているにもかかわらず、カートが支払われていないと言うこともできる：

```json
{
  "data": {
    "cart": {
      "paid": false,
      "amountPaid": 10000,
      "item": [...]
    } 
  }
}
```

その代わりに、型システムのおかげで、単純にこれらの状態を許さないスキーマを構築したい。
この解決策は常に文脈に依存する。
この場合、私たちには概念が欠けていたのかもしれない。
もしかしたら、Order型は有料のカートを表すべきで、カートは単にオブジェクトの袋を表すのかもしれない。
他のケースでは、オブジェクト型の下に関連するフィールドを単純にラップすることで、これを避けることができる。
例えば、カートに支払いプロパティがあれば、それは支払いが完了したことを意味する。
この場合、nullabilityを使用して、paidとamountPaidの両方が存在することを保証することができます：

```gql
type Cart {
  payment: Payment
  items: [CartItem!]!
}
type Payment {
  paid: Boolean!
  amountPaid: Money!
}
```

次に進む前に、クライアントが使いにくくてびっくりするようなAPIの例をもう一つ紹介しよう。
この例では、オプションのソート引数を取る商品フィールドがある。
すべてのクライアントが特定のソート順を求めていないのであれば、ソート引数に値を渡すことを強制したくないので、これは理にかなっている。

```gql
type Query {
  products(sort: SortOrder): [Product!]!
}
```

問題は、スキーマがデフォルトのソートが何であるかについてまったく何も教えてくれないことだ。
その代わりに、GraphQLはデフォルト値を提供してくれますが、これはデフォルトのケースを文書化するのに非常に便利です。
そのため、解決ロジックでデフォルトのソート順を設定する代わりに、スキーマに直接エンコードすることができます：

```gql
type Query {
  products(sort: SortOrder = DESC): [Product!]!
}
```

おわかりのように、スキーマを使いやすく、理解しやすくする方法はたくさんあります：

- フィールドが1つのことをうまく行うようにし、巧妙なフィールドや汎用的なフィールドは可能な限り避ける。
- スキーマが強制できる場合は、実行時ロジックを避ける。
- フィールドと引数の間の結合を表現するために、複雑なオブジェクト型と入力型を使う。
不可能な状態」を避ける。
- デフォルト値を使用して、オプションの入力や引数を使用する際のデフォルトの振る舞いを示す。
オプションの入力や引数を使用する場合、デフォルト値を使用してデフォルトの動作を示します。

### Specific or Generic

特定か汎用かという大きな議論は、APIコミュニティが長年抱えてきたものだ。
一方では、私たちが提供するユースケースに非常に特化しているということは、その特定の機能に関心のあるクライアントに対して非常によく最適化されているということだ。
もう一方では、一部のクライアントに特化しすぎたAPIは、他のクライアントにとってカスタマイズの余地が少なくなることを意味する。
未知のクライアントを多く扱っている場合は特にそうだ。

しかし、GraphQLの基本理念は、クライアントに必要なものを正確に消費させることなので、それを念頭にスキーマを構築し、特定のクライアントのニーズに答えるシンプルなフィールドを選択することは、一般的に良い考えです。
あまりに汎用的なフィールドは、誰のためにも最適化されない傾向があり、また推論も難しくなる。フィールドは多くの場合、1つのことだけを行い、それを本当にうまく行うべきです。フィールドが複数のことを行おうとしていることを示すのに良いのは、ブーリアン引数です。
これを別のフィールドに分割することで、よりよい設計になることがよくあります。よくある例を挙げましょう：

```gql
type Query {
  posts(first: Int!, includeArchived: Boolean): [Post!]!
}
```

投稿フィールドをアーカイブ投稿と通常の投稿の両方を扱えるようにする代わりに、2つのフィールドに分離したらどうだろう：

```gql
type Query {
  posts(first: Int!): [Post!]!
  archivedPosts(first: Int!): [Post!]!
}
```


これを2つの異なるユースケースに分けるだけで、より読みやすく、最適化しやすく、キャッシュしやすく、クライアントが推論しやすいスキーマができる。
しかし、これは基本的な例です。ジェネリックフィールドを過剰に使用する最も一般的な例は、おそらく次のような非常に複雑なフィルターでしょう：

```gql
query {
  posts(where: [
    { attribute: DATE, gt: "2019-08-30" },
    { attribute: TITLE, includes: "GraphQL" }
  ]) {
    id 
    title 
    date
  } 
}
```

SQLに近いこの種のフィルタリング構文は非常に強力だが、ほとんどの場合避けることができる。
これらは非常に汎用的であるため、サーバーチームが単一のリゾルバ内ですべてのパフォーマンスエッジケースを処理することを余儀なくされるだけでなく、特定のユースケースに焦点を当てていないため、クライアントでも発見して使用することが難しくなる。

例えば、実際の検索やフィルタリングのユースケースを実装する場合、フィルタは非常に便利です。
しかし、このような汎用的なフィールドがどれだけ必要かを意識するようにしてください。
特定のユースケースを別の方法で公開できないでしょうか？例えば

```gql
type Query {
  filterPostsByTitle(
    includingTitle: String!,
    afterDate: DateTime
  ): [Post!]!
}
```

この特定か汎用かの議論は、あなたが構築しようとしているAPIの種類に大きく依存することを覚えておいてほしい。
例えば、ある種の検索インターフェースのために、様々なSQLライクなフィルタをサポートするAPIを構築するのであれば、ジェネリックなルートを選ぶことは非常に理にかなっているかもしれない。
しかしこの時点では、あなたは実際のユースケースを実装しているに過ぎない！

#### Anemic GraphQL

Anemic GraphQLは、偉大なマーティン・ファウラーが広めたパターンであるAnemic Domain Modelから私が盗んだものだ。
Anemic GraphQLとは、アクションやユースケース、機能性を考えてスキーマを設計するのではなく、純粋にデータのダムバッグとしてスキーマを設計することを意味する。
これは例によって最もよく表現される：

```gql
type Discount {
  amount: Money!
}
type Product {
  price: Money!
  discounts: [Discount!]!
}
```

この商品タイプは、eコマースストアの商品を表しています。
この例では、商品は単に価格と現在適用されている割引のリストを持っています。
顧客が実際に支払う価格を表示したいとします。
てもシンプルでしょう？私たちは、商品の価格を取得し、その価格からすべての割引を削除します。

```js
const discountAmount = accounts.reduce((amount, discount) => {
  amount + discount.amount
}, 0);
const totalPrice = product.price - discountAmount
```

クライアントは当分の間、この価格を喜んで顧客に表示することができる。
商品タイプが進化するまでは。数ヶ月後、商品に税金が追加されたとします：

```gql
type Product {
  price: Money!
  discounts: [Discount!]!
  taxes: Money!
}
```

税金が追加された今、クライアントの最初のロジックはもう成り立たない。
それを防ぐにはどうすればよかったのか？クライアントが実際に興味を持っていたもの、つまり合計金額を表示するのはどうだろう？

```gql
type Product {
  price: Money!
  discounts: [Discount!]!
  taxes: Money!
  totalPrice: Money!
}
```

こうすることで、クライアントは興味のあるものを正確に消費し、何がtotalPriceに影響を与えることになろうとも、正確な値を永遠に得ることができ、何かが追加されるたびにもろいクライアントコードを更新する必要がなくなる。
これは、我々のドメインに従ってスキーマを設計したからであり、単にクライアントが消費できるようにデータを公開したからではない。
これがどのように変異に適用されるかを見てみよう。
ここでは、eコマースのトランザクション中にチェックアウトを更新するための変異を示します：

```gql
type Mutation {
  updateCheckout(
    input: UpdateCheckoutInput
  ): UpdateCheckoutPayload
}
input UpdateCheckoutInput {
  email: Email
  address: Address
  items: [ItemInput!]
  creditCard: CreditCard
  billingAddress: Address
}
```

一見すると、これは顧客にとって素晴らしいことのように思える。
チェックアウトのあらゆる属性を変更できるのですから。
しかしよく見ると、この方法にはいくつかの問題があることに気づきます：


- ミューテーションはデータに焦点を当て、振る舞いには焦点を当てないため、クライアントは特定のアクションをどのように行うかを推測する必要があります。あるアイテムをチェックアウトに追加する際に、実は他のいくつかの属性の更新が必要だとしたらどうでしょう？クライアントは実行時のエラーによって初めてそのことを知るだろうし、最悪の場合、1つの属性の更新を忘れて間違った状態になってしまうかもしれない。
- カートに追加 "のような特定のアクションを取りたいときに、更新するフィールドのセットを選択する必要があるため、私たちはクライアントに認知的な過負荷を加えています。
- 私たちは、チェックアウトの潜在的な動作ではなく、チェックアウトの内部データの形状に焦点を当てているため、これらのアクションを実行することが可能であることを明示的に示しません。
- 私たちはすべてをnullにする必要があり、スキーマの表現力を一般的に低くしています。

このような粗視化されたジェネリック・ミューテーションに代わるものとして、細視化されたアプローチがある：

```gql
type Mutation {
  addItemToCheckout(
    input: AddItemToCheckoutInput
  ): AddItemToCheckoutPayload
}
input AddItemToCheckoutInput {
  checkoutID: ID!
  item: ItemInput!
}
```

私たちは、今説明した多くの問題に対処してきた：

- 我々のスキーマは強く型付けされている。この変異では何もオプションではありません。私たちのクライアントは、チェックアウトにアイテムを追加するために何を提供すればよいかを正確に知ることができます。
- もう推測する必要はありません。どのデータを更新すべきかを探す代わりに、アイテムを追加するのです。私たちのクライアントは、このような場合、どのデータを更新する必要があるかは気にせず、ただアイテムを追加したいだけなのです。
- この変異の実行中に起こりうるエラーの可能性は大幅に減少した。我々のリゾルバはより細かいエラーを返すことができる。
- この変異を使用することによって、クライアントがおかしな状態になることはない。

この設計の興味深い副次的な効果として、このような変異のサーバーサイドの実装は、一つのことに集中し、入力とペイロードが予測可能であるため、一般的に理解するのも書くのもずっと簡単です。
パブ/サブスクリプションがある世界では、どのイベントが特定の変異によってトリガーされるべきかを確認するのもずっと簡単です。

### The Relay Specification

他のスキーマ設計の概念に飛び込む前に、Relay仕様について話さなければならない。
RelayはGraphQL用のJavaScriptクライアントで、当初はFacebookがGraphQLとともにリリースしたものでした。
Relayは、GraphQLを消費するクライアント・アプリケーションを構築するための強力な抽象化です。
しかし、これを実現するために、Relayは対話するGraphQL APIについていくつかの前提を置いています：

- グローバル識別子を使用してオブジェクトを再取得するメソッド
- データセットのページ分割に役立つConnectionの概念
- 突然変異に特有の構造

これらの点については、設計上の注意点について説明するときに詳しく説明します。
しかし今のところは、Relayについて話すときには、Relayクライアントが期待する特定の前提条件や設計上の考慮事項について話すということを覚えておいてください。

### Lists & Pagination

ほとんどのスキーマは最終的にリスト型のフィールドを公開することになる。
これまで見てきた単純な例のほとんどは、単純なリスト型としてこれらを公開している：

```gql
type Product {
  variants: [ProductVariant!]!
}
```

これはクライアントにリストを取得させる一番簡単な方法ですが、 後でとんでもないことになる可能性があります。
この例では、variants フィールドはクライアントに返されるアイテムの数を制御できません。
これは、ある商品に対して variants がいくつあっても、実行時にすべてクライアントに返されることを意味します。
このため、バックエンドのパフォーマンスの問題でフィールドを削除しなければならなかったり、クライアントが UI に表示したいのは最初の数項目だけなので、自分でフィルタリングをしなければならなかったり (膨大な量のデータを無駄にする) ということがよくあります。

このような理由から、ページネーションは優れたAPIにとって不可欠な要素であることがほとんどだ。
大きなデータセットを "ページ "に分割することで、クライアントに大量のデータを送信させることなく、データの一部を取得させることができる。
ページネーションは、クライアントとサーバーの双方にとって素晴らしい体験となる：

- サーバーサイドでは、ページネーションは、データセットの特定の部分をロードするのに役立ちます。
- クライアントサイドでは、これはユーザーエクスペリエンスとパフォーマンスを向上させます。ユーザーが何千もの項目のリストをスクロールする必要はありません。

実際、ページネーションはGraphQLスキーマでさまざまな方法で行われます。2つの主なアプローチを取り上げましょう。

#### Offset Pagination

APIのページ分割で最も広く使われているテクニックは、オフセットページ分割と呼ばれるものである。
オフセット・ペイジネーションでは、クライアントは受信に興味のあるアイテムの数と、ページ分割されたリストを移動するのに役立つオフセットまたはページ・パラメータを指示する。
HTTP APIでは、これはしばしば次のようになる：

```html
GET /products?limit=250&page=3
```
GraphQLを使えば、フィールド上でこの動作を再現することができる：

```gql
type Query {
  products(limit: Int!, page: Int!): [Product!]!
}
```

このタイプのページネーションは、バックエンドで実装する最も簡単な方法であることが多いので、素晴らしいものである。
また、クライアントにとっては、興味のあるページにスキップしたり、リストをページネーションしながら位置を追跡したりできるので、多くの柔軟性が得られる。しかし効果的ではあるが、APIプロバイダーが成長するにつれて、その多くがこの手法の問題に気づき始める。
最初の理由は、多くの場合データベースのパフォーマンスだ。私たちが設計した商品フィールドを、それを満たすためのデータベースクエリがどのようなものかを想像してみると、通常は次のようになる：

```sql
SELECT * FROM products
WHERE user_id = %user_id
LIMIT 250 OFFSET 500;
```

この種のSQLクエリは、非常に大きなデータセットに対してうまくスケールしないことがよくあります。offsetパラメータが大きくなると、データベース実装はそのオフセットに到達するために、その数値までのすべての行を読み込む必要があります。

オフセットページ分割の2つ目の一般的な問題は、一貫性のない結果を返す可能性があるということです。
これは、クライアントがページ分割を行っている間にリストが変更されると、クライアントが要求したページで返される項目が変更される可能性があるためです。
アイテムがリストに追加されている間に、クライアントが最初のページをフェッチしたとします。クライアントが2ページ目をロードすると、新しい結果によって「プッシュダウン」されたため、1ページ目から重複した結果を受け取る可能性があります。
この問題を回避する方法はありますが、それでも対処が必要です。
これら2つの理由から、多くのAPIプロバイダーはカーソルベースのページネーションに移行している。

#### Cursor Pagination

カーソルのページネーションは異なる観点からこの問題にアプローチします。
カーソルはリスト上の項目を指す安定した識別子です。
クライアントはこのカーソルを使って、APIにこのカーソルの前か後の結果を与えるように指示することができます。
実際にはこのようになります：

```gql
type Query {
  products(limit: Int!, after: String): [Product!]!
}
```


カーソルのページネーションに「ページ」という概念が存在しないことに注意してください。
クライアントが知っている唯一の情報は、"次 "または "前 "の数個のアイテムですが、一般的に何ページあるかは知りませんし、どのページにもスキップすることはできません。
オフセットページ分割のパフォーマンス上の欠点は、次のことができるため解消されます。カーソルを使用して結果を取得します：

```sql
SELECT * FROM products
WHERE user_id = %user_id
AND id >= 15
ORDER BY id DESC
LIMIT 10
```

カーソルのページネーションでは、クライアントに次のいくつかの要素を要求できるように、サーバーは常に何らかの方法で「次の」カーソルが何であるかを提供します。
例えば

```json
{
  "data": {
    "products": {
      "next": "def456",
      "items": [{},{},{}]
    }
  }
}
```

クライアントは次のカーソルを取り、それを使って次の10個のアイテムをフェッチする：

```gql
query {
  products(first: 10, after: "def456) {
    next 
    items {
      name
      price
    }
  }
}
```

クライアントが別のページにスキップする機能が絶対に必要でない限り、カーソルによるページネーションはGraphQL APIに適した選択です。
今日、ほとんどのGraphQL APIはカーソルベースのページ分割を使用していますが、これは主にRelayの接続パターンによるものです。

#### Relay Connections

先に取り上げたように、RelayにはGraphQLスキーマをどのように設計すべきかについて一定の前提があります。
それらの前提の1つは、GraphQL APIがページネーションをどのように扱うべきかということです。
当然のことながら、Relayはカーソルによるページネーションに強く基づいていますが、その設計方法は非常に興味深いものです。
Relayはページ分割されたリストを呼び出す 接続。接続の抽象化をよりよく理解するために、クライアントが接続フィールドをクエリするときの様子から始めましょう：

```gql
query {
  products(first: 10, after: "abc123") {
    edges {
      cursor
      node {
        name
      } 
    }
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
    }
  }
}
```

ここには解き明かすべきことがたくさんある。
Connectionsは2つのフィールドを公開する接続タイプを返す。
edgesフィールドは要求したデータを含み、pageInfoはページネーション自体のメタデータを含むフィールドです。
edgesフィールドはアイテムをすぐに返すのではなく、その特定のアイテムのための特別な接続メタデータを持つエッジタイプを返します。
このようにして、リスト内の各アイテムのカーソルを知ることができる。
最後に、エッジ・リストのノード・フィールドは、私たちが探しているデータ（この場合は商品）を含んでいます。
このようなクエリの結果は次のようになります：

```json
{
  "data": {
    "products": {
      "edges": [
        {
          "cursor": "Y3Vyc29yOnYyOpHOAA28Nw==",
          "node": {
            "name": "Production Ready GraphQL Book"
          }
        }
      ],
      "pageInfo": {
        "endCursor": "Y3Vyc29yOnYyOpHOAA28Nw==",
        "hasNextPage": true,
        "hasPreviousPage": false
      }
    }
  }
}
```

そして、クライアントはpageInfoメタデータのendCursorを取得し、それを使ってすでに取得した項目の次の項目を取得する。接続の完全なスキーマは通常次のようになります：

```gql
type ProductConnection {
  edges: [ProductEdge]
  pageInfo: PageInfo!
}
type ProductEdge {
  cursor: String!
  node: Product!
}
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}
type Product {
  name: String!
}
```

最初は、この接続パターンは冗長すぎるように見える。結局のところ、ほとんどのクライアントが興味を持っているのは商品のリストを取得することであり、なぜそれをこの奇妙な「エッジ」の概念に包むのだろうか？
コネクション・パターンはクライアントに一定のオーバーヘッドをもたらす一方で、より複雑なシナリオを設計するのに非常に有用であることがわかった。
たとえば GitHub API では、コネクション・エッジを使ってアイテムそのものではなくリレーションに関するデータをエンコードしています。
たとえば、Team.members の接続とエッジは、User 型そのものではなくエッジ型のそのチームにおけるユーザーの役割を持ちます：

```gql
type TeamMemberEdge {
  cursor: String!
  node: User!
  role: TeamMemberRole!
}
```

Relayで定義されている接続パターンでは、カーソルベースのページ分割が必要ですが、オフセットベースのページ分割を選択する場合でも、エッジ型は良いアイデアであることに注意してください。
上の例で見られるように、いくつかのフィールドはコレクション内の型のメンバシップに固有のものです。

#### Custom Connection Fields


プロバイダがコネクション型やエッジ型とともに提供することが多いフィールドがいくつかある。
クライアントはしばしば、edges { node }構文が冗長すぎると感じる。
あるプロバイダーが提供しているのは、エッジ部分をスキップしてすべてのノードを直接取得する方法だ。
ページ分割されたリストの利点はそのまま得られますが、edgesパターンの冗長さはありません：

```gql
query {
  products(first: 100) {
    nodes { 
      name
    }
  }
}
```

このヘルパー・フィールドを実装する場合は、両方のオプションを指定することを忘れないこと。
これまで見てきたように、エッジ・パターンはリレーションシップを設計する際に多くの利点を与えてくれます。

コネクションによく追加される次のフィールドは、totalCountフィールドで、クライアントがリストで見つかった（ページネーション前の）ノードの総量を要求できるようにする。
このフィールドを推奨するのはためらわれる。すべてのコネクションにデフォルトでこれを追加しないでください。
でtotalCountを計算する を計算するのは、コレクションがどこから解決されるかによって、非常に遅くなることがよくあります。
このフィールドが特定のケースで役に立つことは否定しませんが、このフィールドを公開する前にパフォーマンスを念頭に置く必要があります。
一旦そこにあると、パフォーマンスの問題で削除したり維持したりするのは非常に困難です。

#### Pagination Summary

ページネーションに使用される非常に一般的なページ番号リンクは、オフセットベースのページネーションでは非常に簡単に実装できますが、カーソルベースのページネーションではほとんど不可能です。
しかし、将来的に起こりうる欠点を覚えておいてください。
単純なリスト型よりも優れた方法で関係を表現できるようにするために、オフセット・ペイジネーションであっても「接続スタイル」パターンを使用することを強くお勧めします。

あなたのユースケースがカーソルベースのページネーションでサポートできるのであれば、GraphQL APIを設計する際に接続パターンを選択することを強くお勧めします：


- カーソルによるページネーションは一般的に、精度とパフォーマンスの面で優れた選択肢です。
- RelayクライアントをあなたのAPIとシームレスに統合することができます。
- これはおそらく、現在のところGraphQLで最も一般的なパターンであり、次のような利点があります。
他のAPIとの一貫性を保つことができます。
- コネクションパターンを使用すると、より複雑なユースケースを設計できます。
Connection型とEdge型があります。

### Sharing Types

スキーマが大きくなるにつれて、魅力的なことは、異なるフィールドやユースケースにわたって型を再利用することだろう。
時には、それはまったく理にかなっている。しかし、共有しようとしすぎてうまくいくことはめったにありません。
これは私がGraphQLスキーマで見てきた最も一般的な問題かもしれません。
型を再利用することの魅力（たとえばクライアント側の構造の再利用のため）は素晴らしいものですが、それは最終的には多くの苦痛につながる可能性があります。
良い例は、先ほど話した接続パターンに関連するものです。ある組織がユーザーのページ分割された接続を持っているこのスキーマを想像してみてください：

```gql
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}
type UserEdge {
  node: User
}
type User {
  login: String!
}
type Organization {
  users: UserConnection!
}
```

ここで、チームの概念を追加し、チームにはメンバがいるとします。
よくある間違いは、同じUserConnectionをmembersフィールドに再利用することです。結局のところ、チームのメンバーも組織のユーザーも、すべてユーザーなのです。

```gql
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}
type UserEdge {
  node: User
}
type User {
  login: String!
}
type Organization {
  users: UserConnection!
  teams: [Team]
}
type Team {
  members: UserConnection!
}
```

このように型を再利用することの問題点は、将来、型が時間とともにどのように分岐していくかについて多くの驚きをもたらすことである。
この例は、私が何度も見てきたものだ。チームメンバーが組織のユーザーとは異なる機能を持っていることに気づくと、私たちは立ち往生してしまう：

```gql
type UserEdge {
  isTeamLeader: Boolean
  isOrganizationAdmin: Boolean
}
```

UserEdgeには、チーム内のUserに関連する情報を置きたいところですが、組織UserとチームMemberの両方で共有されているため、どちらか一方に特化した情報を追加することはできません。
もし、TeamMemberConnectionとOrganizationUserConnectionがあったらと想像してみてください。
エッジとコネクションには自由にデータをエンコードできる。
これは型を共有することの危険性を示す良い例です。
もう1つのよくあるアプローチは、入力を共有しようとすることだ。
例えば、createX変異とupdateX変異はよく似ています。update変異は更新するリソースのidを取ることが多いですが、残りの属性はcreate変異と驚くほど似ています。
両者の間で入力を共有するというアプローチがあります：

```gql
input ProductInput {
  name: String
  price: MoneyInput
}
type Mutation {
  createProduct(input: ProductInput):
    CreateProductPayload
  updateProduct(id: ID!, input: ProductInput):
    UpdateProductPayload
}
```

このアプローチは生成されたクライアントがフォームとロジックを再利用できるようにするために便利ですが、私たちが見た接続の例と似たような問題を引き起こす可能性もあります。
create入力は通常もう少し多くのnullでないフィールドを持ちます。
なぜなら、例えば名前のない商品を作成することはできないからです。
更新の変異で再利用するため、入力フィールドをNULLにしなければなりません。
変異の設計についてはこの章の後のほうで詳しく説明します。

ここで取り上げた2つの例は、私が一般的に型を共有することを推奨する理由である。を共有できることが明白でない限り、タイプを共有しようと頑張りすぎないことを推奨する理由である。疑問がある場合は、通常、デメリットがメリットを上回る。

### Global Identification
GraphQL APIで人気を博したもう1つのコンセプトは、オブジェクトのグローバル識別である。
これも元々はRelayから来たものですが、その後一般的に良いプラクティスとなっています。
この考え方は、GraphQLクライアントが一意の識別子を与えられたグラフ内の任意の「ノード」をフェッチできるようにすることです。
実際には、これはGraphQLサーバーがグローバルノード（id: ID!） Nodeフィールドを公開することで、クライアントはその単一のフィールドを通じて任意のノードをフェッチできるようになります。
nodeフィールドはNodeインターフェース・タイプを返します：

```gql
interface Node {
  id: ID!
}

type User implements Node {
  id: ID!
  name: String!
}
```

このNodeインターフェイスは、このオブジェクトがグローバルに一意なIDを持ち、node(id: ID!)フィールドとnodes(ids: [ID!]!)フィールドを使ってフェッチできることを示す手段である。
これらすべての目的は何でしょうか？その多くはクライアントサイドのキャッシュです。
GraphQLクライアントは、以前にフェッチしたノードを保存するために複雑な正規化キャッシュを構築することがよくあります。
Relayには単一ノードを再フェッチするメカニズムが必要であり、ノード規約を持つことで、クライアントはそれをあまり設定することなく行うことができます。
グローバル識別は絶対に必要ですか？必ずしも必要ではない。
RelayクライアントがAPIを使用することを想定しておらず、単一のグローバル識別子を使用してオブジェクトをフェッチする必要性がない場合は、実装する必要はありません。
たとえばApolloのようなクライアントは、型名と単純なIDを組み合わせてグローバル識別子を作成することができます。

とはいえ、特定の「ノード」や「オブジェクト」に対してグローバルに一意なIDを持つことは、非常に有用な原則となりうる。
実際、これらは例えばRESTリソースを識別するために使用される統一リソース識別子（URI）に似ている。REST URIのように、これらの識別子の重要な部分の1つは、ユーザがIDを構築したりハックしようとせず、APIから取得したIDを直接使用することです。
これを確実にする良い方法は、不透明な識別子を使うことだ：

```json
{
  "data": {
    "node": {
      "id": "RmFjdGlvbjoy"
    }
  }
}
```

IDを不透明にする最も一般的な方法は、Base64にすることだ。
ここでの目的は、IDがどのように作られているかを完全に隠すことではない（Base64であることをクライアントが知るのは簡単だ）。
その代わりに、この文字列が不透明であることをクライアントに思い出させるだけである。
不透明なIDは、クライアントがIDがどのように構築されるかに関連したロジックを構築していないことを期待しながら、根本的なID生成を変更することを可能にするので、素晴らしいものです。
しかし、時には、開発者にとって最高のエクスペリエンスにつながるとは限りません。
クライアント・アプリケーションを構築する際に、自分の手元にあるノードIDがどのようなものかを知るのは難しいかもしれない。
私が興味を抱いているアイデアは、不透明なIDで、まだ自分自身について少し知ることができます。
私が初めてこのようなものに出会ったのはSlack APIだったと思う。
オブジェクトのタイプに応じて異なる文字で始まる不透明なトークンがあった。グローバルIDには、開発者を助けるためにちょっとした情報を含めるのがいいのかもしれない。

これらのIDを作成する場合、このノードをグローバルにフェッチするのに役立つ情報をできるだけ多く含める必要があります。
最も基本的なケースでは、これは通常type_name:database_idですが、常にこれをデフォルトとすべきではありません。
特に分散アーキテクチャでは、ルーティング情報がないとノードをフェッチできないことがあります。
このノードへの "ルーティング "を容易にする情報があれば、必ず含めてください。
例えば、"products "は "shops "によって共有または配布されるかもしれません。
つまり、IDにはshop_id:type_name:idというショップIDが必要になるかもしれません。

要約すると

- 特にRelayをサポートするつもりがないのであれば、グローバルIDは必ずしも必要ではない。
- コネクションのように、Relayのコンテキスト以外でも有効なパターンです。
- 不透明なIDを推奨する。
- グローバルIDには、ノードにグローバルにルーティングするのに十分なコンテキストが含まれていることを確認してください、

特に分散アーキテクチャでは。

### Nullability

NullabilityはGraphQLの概念で、フィールドがクエリーされたときにNULLを返すかどうかを定義することができます。
GraphQLを紹介したときに見たように、非NULLフィールド、つまり実行時にNULLを返せないフィールドは、その型の後にbang（！）記号を使用して定義します。
デフォルトでは、すべてのフィールドはnull可能です：

```gql
type Product {
  # This field is non-null name: String!
  # Price returns null when the product is free (default)
  price: Money

  # The tags field itself can be null.
  # If it does return a list, then every
  # item within this list is non-null.
  tags: [Tag!]
}
```

スキーマで非 null としてマークされているにもかかわらず、フィールドがクエリ時に null を返すと、GraphQL サーバーはエラーになります。
フィールドがNULLであることはありえないため、GraphQLはNULL可能なものが見つかるまでフィールドの親を遡っていきます。
フィールドがすべてnull不可だった場合、クエリー全体がnullを返し、エラーになります。
例えば、以下のクエリで、topProductフィールドがnullでないとマークされ、shopフィールドがnull可能であるとマークされたとします。

```gql
query {
  shop(id: 1) {
    name
    topProduct {
      name
      price
      tags
    }
  }
}
```

ここで、nameフィールドがnullでないとマークしたにもかかわらず、nullを返すとします。
topProductもnullにはできないので、結果は次のようになります：

```json
{
  "data": {
    "shop": null
  }
}
```


shopはnull可能であったため、たとえ1つのフィールド名だけがnullを返したとしても、GraphQLはshopタイプのレスポンス全体を爆撃しなければならなかった。
この例は null可用性は、その適用方法によっては、本当に強力なものにも、とんでもない間違いにもなり得るということを思い出させてくれる。

非Nullabilityは多くの理由で優れています：

- この章の前半で説明したように、より表現力豊かで予測可能なスキーマを構築するのに役立ちます。
- クライアントが過度に防御的なコードや条件を避けることができる。
しかし、これにはいくつかの危険性があります：
- NULLでないフィールドや引数は進化しにくい。nullでないフィールドと引数は進化しにくい。nullでないものからnullにすることは、破壊的な変化だが、その逆はそうではない。
- 特に分散環境では、何がNULLになるかどうかを予測するのは非常に難しい。あなたのアーキテクチャは進化し、タイムアウトや一時的なエラー、レート制限など、あらゆるものが特定のフィールドに対してnullを返す可能性があります。

そこで、スキーマを設計する際にヌーラビリティのために私が使っているガイドラインをいくつか紹介しよう：

- 引数については、より事前に指示可能で理解しやすいAPIを可能にするため、ほとんどの場合nullでない方がよい。(引数を追加する場合、既存のクライアントを壊さないためにはnullableが最適です)
- データベースの関連付けやネットワーク呼び出しなど、いつか失敗する可能性のあるものに支えられているオブジェクト・タイプを返すフィールドは、ほとんどの場合null可能であるべきだ。
- 実行時にすでに親オブジェクトにロードされていることが分かっているオブジェクトの単純なスカラーは、一般的にnull以外にしても安全です。
- まれです： まれに：NULLになることはないだろうという確信があり、親レベルで部分的な応答が可能なオブジェクト型。(特に、その型が他のコンテキストで再利用されることになる場合は、予測が困難です）。

これらのガイドラインに従うことで、スキーマ・メンバをnon-nullableにするかnullableにするかの正しい判断ができるようになります。
いつものように、これは実装に大きく依存するので、疑問がある場合は、NULL可否を決定する前に、基礎となるシステムを理解していることを確認してください！

### Abstract Types

抽象型はGraphQLスキーマを設計するときに非常に便利です。
スキーマを設計するときに大いに役立ち、インターフェイスを基礎となる永続化レイヤーから切り離すのに本当に役立ちます。
たとえば、データベースモデルから生成されたこの型を見てみましょう：

```gql
type SocialMediaFeedCard {
  id: ID!
  title: String!
  birthdayDate: DateTime
  eventDate: DateTime
  postContent: String
}
```

このタイプが表現しようとしているのは、ソーシャルメディアへの投稿である。
問題は、この投稿が誕生日だったり、イベントだったり、単なるテキスト投稿だったりすることだ。
おわかりのように、これを設計した方法のせいで、スキーマをフルに活用しておらず、違法な状態になる可能性があります。
バースデーカードはコンテンツを持つべきでなく、単にbirthdayDateを持つべきである。
イベントもbirthdayDateを含むべきではありませんが、スキーマはこれが可能であることを示唆しています。

その代わりに、抽象型（この場合はInterface型）を使ってこの概念を設計することができる：

```gql
interface SocialMediaFeedCard {
  id: ID!
  title: String!
}
type BirthdayFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  date: DateTime!
}
type EventFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  date: DateTime!
}
type ContentFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  content: String!
}
```

スキーマはクライアントにとって即座に明確になり、私たちに来る可能性のあるカード・タイプを簡単に見ることができます。
また、null可能なフィールドも必要なくなりました。以前のような不正な状態を許さない。これが抽象型の力だ。

#### Union or Interface?

GraphQLには2種類の抽象型がある： ユニオン型とインターフェース型です。
いつどちらを使うべきでしょうか？経験則から言うと、インターフェースは振る舞いを共有するものに対して共通の契約を提供するものであるべきです。
例えばGitHubには、"スターをつける "ことができるオブジェクトのためのStarrableインターフェイスがあります：
リポジトリ、ギスト、トピックなどです。
ユニオンは、あるフィールドが異なる型を返す可能性があるが、それらの型が必ずしも共通の振る舞いを持つとは限らない場合に使用します。
この一般的な例は、さまざまな可能性のあるオブジェクト・タイプを含むことができますが、必ずしも共通の動作を共有するわけではないリスト・タイプを返す検索フィールドの場合です。

#### Don’t Overuse Interfaces

インターフェイスはスキーマの中でより強力なコントラクトを作成するためには素晴らしいものですが、共通のフィールドを共有するためだけに使われる場合など、時に過剰に利用されることがあります。
複数の型がいくつかのフィールドを共有しているが、これらの型が共通の振る舞いを共有していない場合、単にインターフェイスを混在させる誘惑を避けるようにしよう。
優れたインターフェースは、APIコンシューマーにとって意味のあるものでなければならない。
インターフェイスは、何かになったり何かを持ったりするのではなく、何かのように何かをしたり振る舞ったりするための共通の方法を記述し提供するものだ。

では、インターフェースがオブジェクトを "分類 "し、似たような属性をグループ化することに重点を置きすぎていて、相互作用や振る舞いに十分な重点を置いていないかどうか、どうすればわかるのだろうか？スキーマの "匂い "を嗅ぐのに便利なのは、ネーミングだ。スキーマの中で強い意味を持たないインターフェイスを使う場合、ネーミングはたいていぎこちなく、意味のないものになります。
例えば、ItemInterfaceはeコマースドメインのアイテムと共通のフィールドを共有することになります。カートのアイテム、チェックアウトのアイテム、オーダーのアイテムがバラバラになり始めると、このインターフェースは維持するのが面倒になるかもしれません。
もし、私たちがいろいろな種類のアイテムを見て、それらが私たちのドメイン内で非常に異なる相互作用や振る舞いをすると判断したなら、もしかしたら別の抽象化を選んだかもしれません。
ItemFieldsやItemInfoといった他の名前も同じように使われているのを見たことがある。
私が間違った理由でインターフェースが使用されているのを目にする最も一般的な方法は、使用されているGraphQL実装がコードの再利用のためにインターフェースを簡単に使用できるようにしている場合です。
コードの再利用を可能にするためにGraphQLスキーマを使用するのではなく、フィールドの再利用を容易にするためにプログラミング言語で持っているツールを使用してください。
たとえば、ヘルパー関数、コンポジション、または継承を使用します。

### Abstract Types and API Evolution

抽象型はしばしば、時間の経過とともにAPIを進化させやすいという印象を与える。
ある意味、これは正しい。あるフィールドがインターフェイス型を返し リスコフの置換原則に従うのであれば、インターフェースを実装した新しいオブジェクト型を追加しても、クライアント・アプリケーションの動作が変わることはないはずだ。

これはインターフェイスに言えることで、完全に分離した型を許すユニオンにはあまり当てはまりません。
ユニオンのメンバーやインターフェイスの実装を追加することは、厳密な意味での破壊的な変更ではありませんが（フィールド定義を削除するように、クライアントがすぐに壊れることはないかもしれません）、それでもほとんどの場合、非常にやっかいな変更であり、ほとんど破壊的とみなすことができます。
このため、しばしば「危険な変更」と呼ばれます。GraphQLクライアントは、すべてのユニオンの可能性やインターフェイス上のすべての具象型を選択することを強制されるわけではありません。
GraphQLクライアントは新しいケースに対して防御的にコーディングすべきであり、GraphQLサーバーは重要なクライアントロジックに影響を与える可能性のある型の追加に慎重になるべきです。

### Designing for Static Queries

クエリ言語であるGraphQLは、直接、明示的に使用することで輝きを放つことが多いということは、もうかなり確立されている。
しかし、SDKやクエリビルダーなど、これと似たようなツールを使用することは魅力的だ：

```gql
query.products(first: 10).fields(["name", "price"])
```

実行時に何がGraphQLサーバーに送信されるのか、まったく見えなくなります。
その代わりに、次のように直接定義されたGraphQLクエリーを取ります：

```gql
query {
  products(first: 10) {
    name
    price
  }
}   
```

非常に明示的であり、どのようなデータが求められているのか、実行時にクエリの形がどのようになるのかを誰もがすぐに知ることができる。
クエリビルダーの代わりにGraphQL言語が優れた選択肢であるだけでなく、クエリを静的なものに保つよう努力すべきである。
静的クエリとは、プログラムのいかなる変数、条件、状態に基づいても変化しないクエリのことです。
ソースコードを見れば、コードがデプロイされたときにサーバーが受け取るクエリであることがわかります。
これにより、動的なクエリよりも多くの利点が得られます：

- ソースコードを見るだけで、開発者はクライアントのデータ要件について実に良いアイデアを得ることができる。
- クエリに操作名を与えることができる。これにより、サーバー側のロギングとクエリ分析が大幅に簡素化されます。例えば、クエリ FetchProducts { products { name } です。}
- IDEのサポート、コード生成、リンティングなどです。
- これは、サーバー側でこれらのクエリを保存することを可能にします。これについては第5章で詳しく説明する。
- 最後に、私たちはGraphQLサーバーと対話するために標準的で指定された言語を使用します！

クエリーを動的に構築するコードです：

```gql
const productFields = products.map((id, index) => {
  return `product${index}: product(id: "${id}") { name }`;
})
const query = `
  query {
    ${productFields}.join('\n')
  }
`
```

このコードには商品IDのリストがあり、各IDに関連する商品オブジェクトを取得するためにGraphQLクエリを構築します。
実行時、このクエリは次のようになります：

```gql
query {
  product0: product(id: "abc") { name } 
  product1: product(id: "def") { name } 
  product2: product(id: "ghi") { name } 
  product3: product(id: "klm") { name }
}
```

ここでの問題は
- このコードには完全なGraphQLクエリが含まれていないため、コードが実行されたときに実際に何が送信されるかを確認するのは難しい。
- クエリー文字列は、実行時にそのリストにいくつの商品IDがあるかによって変化する。そのためにフィールドエイリアス（product0、product1など）を使用しています。

代わりにGraphQLのコンセプトを使えば、変数を使うことで、何があっても常に同じクエリを構築する必要性を回避できる：

```gql
query FetchProducts($ids: [ID!]!) {
  products(ids: $ids) {
    name
    price
  }
}
```

この方法では、実際のクエリ文字列自体は変更されませんが、クライアントは異なる変数のセットを提供するだけで、好きなだけ多くの製品をフェッチすることができます。
このため、少なくともほとんどのフィールドの複数バージョンを提供し、さらに必要に応じて単一のエンティティをフェッチする方法を提供することをお勧めする。
面白いことに、クライアントはGraphQLのリスト型引数に単一の値を提供することができます：

```gql
query {
  # This is valid!
  products(ids: "abc") {
    name
    price
  }
}
```

### Mutations

ミューテーションはおそらく、GraphQLを学んだり使ったりする人々が最も苦労する部分でしょう。
ミューテーションはクエリ側にあるような「単なる」フィールドであるにもかかわらず、クエリ側とはまったく異なるもののように思われがちだ。
しかしそれは理にかなっている。ミューテーションはエラーに対処しなければならないことが多く、副作用が終わった後に何を返すべきかが明確でないことがよくあり、クエリ側には必ずしもない奇妙なルールがあります。
ミューテーションに関する設計上の問題点をいくつか挙げてみましょう。

#### Input and Payload types

突然変異は単純なフィールドである。他のフィールドと同じように引数を取り、特定の型を返すことができる。
しかし、単純な型を返すのではなく、（もともとはRelayが生み出した）一般的な手法として、「ペイロード型」と呼ばれる、特定の変異の結果として使われることだけを目的とした型を返すことがある。

```gql
# An example payload type for a createCheckout mutation
type CreateProductPayload {
  product: Product
}
```

この例では、ペイロード・タイプは単純に、作成された商品という1つのフィールドを持っています。
この章の後のエラーのセクションで説明します。
なぜcreateProductミューテーションで単にProduct型を返さないのでしょうか？第一の理由は、これによって型を変更することなく変異を進化させることができるからです。
変異の結果には、変異されたもの以上のものを返す必要があることがよくあります。
ペイロード型を使用すると、変異の結果に関する他の情報、たとえば成功したフィールドを含めることができます：

```gql
# An example payload type for a createCheckout mutation
type CreateProductPayload {
  product: Product
  successful: Boolean!
}
```

これらのペイロード・タイプは、ほぼ常に一意でなければならない。
先ほど見たように、型を共有しようとすると、特に変異ペイロードの場合、後々問題を引き起こすことになる。
入力についても、同様の戦略が使える：

```gql
type Mutation {
  createProduct(input: CreateProductInput!):
    CreateProductPayload
}
input CreateProductInput {
  name: String!
  price: Money!
}
```

Relayの慣例では、変異ごとに1つの、必須かつ一意の入力タイプを使用する。その利点は、ペイロード・タイプについて説明したことと似ている：
- 入力はより進化しやすい。
- 変異はクライアントサイドで単一の変数を使用することができます。
特に多くの引数を持つようになると、少し使いやすくなる。

私は、突然変異において必須の入力引数を絶対に1つにすることに夢中になることはないが、自分のAPI内でも他のAPIとの間でも、一貫性を保つための良いパターンであることは間違いない。
しかし、必要であれば一握りの引数を使うことを恐れてはいけない。これらの入力とペイロードがどのように構造化できるかは、次のいくつかのセクションで見ていこう。

## Fine-Grained or Coarse-Grained

この章の前の「貧弱なGraphQL」のセクションで見たように、より粒度の細かい、アクションベースのGraphQL変異は多くの利点を提供します。それは素晴らしいことのように聞こえますが、暗い側面もあります。
GraphQLはほとんどの場合APIインターフェースとして使用され、これは通常ネットワーク上でやりとりすることを意味します。最適なインターフェースは通常、プログラミング言語のメソッドシグネチャのために設計されるようなものになりますが、ネットワークの性質上、パフォーマンス上の理由から、より粗いインターフェースを設計せざるを得ないことがよくあります。より細かい変異とより粗い変異の間のトレードオフは、多くの場合、クライアントからのユースケースが何であると考えるかに依存します（公開APIはそれをより難しくします）。

一般的に、粗い粒度の作成ミューテーションと、エンティティを更新するための細かい粒度のミューテーションを持つことは、経験則として良いことがわかりました。
クライアントが単一の変異で何かを作成したいが、作成されたエンティティの更新やアクションは、アイテムの追加や住所の更新など、より小さな変異で行われることがよくあります。
適切なバランスを見つけることは芸術です。このため、変異やフィールドを設計する際に、クライアントのユースケースについて考えることが非常に重要です。
全体として、これはクライアントが興味を持っている本当のユースケースとして何を特定したかによる。一つの機能で解決できることを、クライアントに5つの異なる変異やフィールドを使わせたくないのです。

本当に細かいフィールドや変異には多くの利点がありますが、コントロールフローのビジネスロジックの多くをクライアントに押し付けることになります。
例えば、一般的なユースケースは、商品を作成し、ラベルを追加し、価格を変更することです。
これがUI上で1つのアクションとして表現される場合、これらのアクションがすべて細かいアクションとして設計されていた場合、クライアントは一貫したエクスペリエンスを達成するために、部分的な失敗や再試行などを管理しなければなりません。
例えば、addLabelの変異が失敗したとします。クライアントは、商品の作成と価格の変更はうまくいったが、addLabelの変更を再試行する必要があることを認識する必要がある。
これが問題になったとき、私たちは実際のユースケースを発見し、より粗い粒度の変異がこの機能にとって意味を持ち始めたのかもしれない。
結局のところ、ネットワーク・コールにはパフォーマンス・コストがかかるため、我々が望むよりも少し粗い粒度のオペレーションが必要になることが多い。白か黒かのシナリオではないことは確かだ。

### Transactions


GraphQLの旅のどこかの時点で、トランザクションがないという話を聞いたり、少なくともGraphQLでトランザクションを行うにはどうしたらよいかと考えたりすることでしょう。
トランザクションとGraphQLとはどういう意味なのでしょうか？それはデータベースのことではないのでしょうか？以前のaddProductToCheckout変異があると想像してください。
クライアントが3つの商品を追加したいが、すべての変異を成功させたい、あるいはまったく成功させたくないとしたらどうだろう？

```gql
mutation {
  product1: addProductToCheckout(...) { id }
  product2: addProductToCheckout(...) { id }
  product3: addProductToCheckout(...) { id }
}
```

このようなクエリーの方法には、いくつかの問題があります。まず、この章の前半で取り上げた静的クエリとは正反対です。
クライアントは追加する商品の数を指定してクエリー文字列を生成する必要があり、クライアントにとっては実に使い勝手が悪い。
第2に、GraphQLはこれらの変異をすべて次々に実行するため、2回目の変異が失敗し、3回目の変異が成功する可能性があり、クライアント上で実に奇妙な状態になる可能性があります。

多くの人が、1つのトランザクションブロック内で複数の変異を実行できるGraphQL機能を求めてきた。
ほとんどの場合、このような複雑さは必要ありません。
それよりも、前のセクションで説明したように、トランザクション全体を1つのフィールドに含むような、より粒度の粗い変異を設計する方が、ほとんどの場合良いアイデアです。
この例では、複数のアイテムを追加するaddProductsToCheckout変異を追加するのと同じくらい簡単です。
これによって静的クエリの問題とトランザクションの問題が解決されます。


例えば、商品をチェックアウトに追加し、請求先住所を更新し、割引を適用するといったように、順番に実行する必要がある複数の変異がある場合、それを実際のユースケースとして含めることを恐れないでください。特に内部APIを扱っている場合は、より細かい変異を再利用しようとするのではなく、「トランザクション」を解決するための具体的なユースケースを自由に提供してください。

### Batch

トランザクションのような操作を行うもう1つの方法は、バッチ処理を使うことだ。
GraphQLでは、バッチ処理にはさまざまな意味がある。
複数のクエリドキュメントを一度にサーバーに送信するようなバッチ処理もありますが、1つのクエリ内でバッチ変異を設計することもできます。
これまで、より細かい粒度の変異と粗い粒度の変異、クエリを静的なものにする方法、そしてトランザクションをそのユースケースのための新しい変異フィールドとして設計する方法について話してきました。
この問題に取り組むもう一つの方法は、いくつかのオペレーションを入力とするミューテーションを構築することです：

```gql
type Mutation {
  updateCartItems(
    input: UpdateCartItemsInput
  ): UpdateCartItemsPayload
}
input UpdateCartItemsInput {
  cartID: ID!
  operations: [UpdateCartItemOperationInput!]!
}
input UpdateCartItemOperationInput {
  operation: UpdateCardItemOperation!
  ids: [ID!]!
}
enum UpdateCartItemOperation {
  ADD
  REMOVE
}
```

この例では、updateCartItems 変異は UpdateCartItemOperation 入力のリストを受け取ります。
各入力は、operation フィールドを通してどのような操作を表すかを記述します。
クライアントはこの変異を使用して、1 回の変異で任意の数のアイテムを追加および削除できます：

```gql
mutation {
  updateCartItems(input: {
    cardID: "abc123",
    operations: [
      { operation: ADD, ids: ["abc", "def"] },
      { operation: REMOVE, ids: ["bar", "foo"] }
    ]
  }) {
    cart {
      items {
        name
      }
    }
  }
}
```

ADDとREMOVEが両方ともidsの引数を取ったのは幸運だった。
場合によっては、異なるオペレーションが異なる入力を持つこともある。
これを設計するための最良のアイデアは、入力ユニオンを使うことだろう。
しかし、この本を書いている時点では、まだ仕様に採用されていない。
それまでの間は、すべてのフィールドをオプショナルとして提供し、代わりにリゾルバ/ランタイムレベルでこれを処理するのが適切な解決策である：

```gql
input UpdateCartItemOperationInput {
  operation: UpdateCartItemOperation!
  addInput: CartItemOperationAddInput
  removeInput: CartItemOperationRemoveInput
  updateInput: CartItemOperationUpdateInput
}
```


これは冗長で、スキーマはすべてがnull可能なので表現力は乏しいが、機能する。
これは、入力ユニオンを仕様化するまでの間、バッチ変異が本当に必要な場合に便利である。
標準ではありませんが、例えばディレクティブを使って、この入力タイプはあるフィールドしか受け付けないということを示すこともできます：

```gql
input UpdateCartItemOperationInput @oneField {
  operation: UpdateCartItemOperation!
  addInput: CartItemOperationAddInput
  removeInput: CartItemOperationRemoveInput
  updateInput: CartItemOperationUpdateInput
}
```

### Errors


エラーは私たちの多くが悩むテーマだ。
その理由の一つは、やり方が一つではないからであり、どのようにエラーを処理するかは、あなたのAPIが使用されることを意図しているコンテキストに依存するからである。
このセクションを読み進めながら、できる限りこの文脈を捉えるようにしよう。まず、GraphQL仕様がエラーについて述べていること、そしてエラーがどのように見えるかについて説明します。
基本的なGraphQLエラーは次のようになります：

{
  "message": "Could not connect to product service.",
  "locations": [ { "line": 6, "column": 7 } ],
  "path": [ "viewer", "products", 1, "name" ]
}

エラーを説明するメッセージ、クエリ文字列ドキュメントのどこでエラーが発生したかを示すロケーション、クエリのルートからエラーの発生したフィールドにつながる文字列の配列であるパスがあります。
この場合、productsフィールドのインデックス1のproductのフィールド名でした。
エラーはより多くの情報で拡張することができます。
仕様の進化に伴う名前の衝突を避けるために、extensionsキーを使用する必要があります：

```json
{
  "message": "Could not connect to product service.",
  "locations": [ { "line": 6, "column": 7 } ],
  "path": [ "viewer", "products", 1, "name" ],
  "extensions": {
    "code": "SERVICE_CONNECT_ERROR"
  }
}
```

ここでは、クライアントアプリケーションが、人間が読めるメッセージ文字列ではなく、安定した識別子に依存してエラーを処理できるように、エラーにコードを追加しました（一般的には良いアイデアです）。
クエリー結果がレスポンスの data キーの下にあるのに対し、エラーは errors キーの下で GraphQL レスポンスに追加されます：

```json
{
  "errors": [
      {
        "message": "Error when computing price.",
        "locations": [ { "line": 6, "column": 7 } ],
        "path": [ "shop", "products", 1, "price" ],
        "extensions": {
          "code": "SERVICE_CONNECT_ERROR"
        }
  } ],
    "data": {
      "shop": {
        "name": "Cool Shop",
        "products": [
          {
            "id": "1000",
            "price": 100
  }, {
            "id": "1001",
            "price": null
          },
          {
            "id": "1002",
            "price": 100
  }
  ]
  } }
}
```
上の例では、インデックス1の商品のpriceフィールドがnullを返していることに注意してください。
仕様では、エラーが発生したフィールドはnullになり、関連するエラーがerrorsキーに追加されることになっています。
この動作は、APIでこれらのエラーをどのように使用するかにいくつかの影響を与えます。例えば、変異です：

```gql
mutation {
  createProduct(name: "Computer", price: 2000) {
    product {
      name
      price
    }
  }
}
```

例えば、重複した商品が追加された場合のエラーが欲しいとします。
変異フィールドにエラーを追加すると、完全な変異のレスポンスがnullとして返されます：

```json
{
"errors": [
    {
      "message": "Name for product already exists",
      "locations": [ { "line": 2, "column": 2 } ],
      "path": [ "createProduct" ],
      "extensions": {
        "code": "PRODUCT_NAME_TAKEN"
      }
} ],
  "data": {
    "createProduct": null
} }
```

これらのエラーにはいくつかの欠点があり、このような場合には使いにくい：


- 以前に見た変異のPayloadタイプは、変異に関するメタデータをエンコードするのに適していました。この場合、フィールドはnullを返さなければならないので、たとえエラーがあったとしても、この変異のデータをクライアントに送り返す可能性を失ってしまいます。
- エラーの情報は限られているので、サーバーは通常、拡張キーの中に追加のキーを追加する必要があります。エラー自体に追加すると、追加したフィールドと仕様が衝突する危険性がある。
- エラーのペイロードはGraphQLスキーマの外側にあるため、クライアントはGraphQL型システムの利点を得られません。つまり、私たちのエラーは消費しにくいが、進化しにくいということだ。
- ほとんどのフィールドが非NULLの場合、エラーがクエリに壊滅的な影響を及ぼす可能性があるためです。

GraphQLエラーはもともと例外的なイベントやクライアントに関連する問題を表すために設計されたものであり、必ずしもエンドユーザーに中継される必要のある期待される製品やビジネスのエラーを表すものではないことを理解すれば、これはすべて理にかなっています。エラーを2つの非常に大きなカテゴリーに分けることは、何がどこに行くのかを理解するのに役立ちます：

- 開発者/クライアントのエラー： クエリー中に何か問題が発生した（タイムアウト、レート制限、間違ったIDフォーマットなど）。これらは多くの場合、クライアントアプリケーションの開発者が対処する必要があるエラーです。
- ユーザーエラー： ユーザー/クライアントが何か間違ったことをした（チェックアウトの支払いを2回行おうとした、Eメールがすでに使われている、など）これらはAPIが提供する機能の一部です。


先ほど説明したGraphQLの "errors "キーは、開発者/クライアントのエラーを捕捉するのに最適な場所です。
これは開発者によって読み取られ、GraphQLクライアントによって処理されます。
ビジネス/ドメインルールの一部であるユーザー向けのエラーについては、例外/クエリレベルのエラーとして扱うのではなく、スキーマの一部として設計することが現在のベストプラクティスです。
これを実現する方法をいくつか見てみましょう。

### Errors as data

エラーをデータとして設計する最も簡単な方法は、ペイロード・タイプに起こりうるエラーを記述するフィールドを追加することだ：

```gql
type SignUpPayload {
  emailWasTaken: Boolean!
  # nil if the Account could not be created 
  account: Account
}
```

そしてクライアントはこの情報を好きなように利用することができる。
このようなエラー処理の方法は、純粋に内部的なユースケースでは機能するが、汎用的にエラーを処理したり、突然変異間で一貫性を持たせたりするのは難しくなる。
より良い方法は、ペイロード・タイプにuserErrorsフィールドのようなものを含めることです：

```gql
type SignUpPayload {
  userErrors: [UserError!]!
  account: Account
}
type UserError {
  # The error message message: String!
  # Indicates which field cause the error, if any
  #
  # Field is an array that acts as a path to the error #
  # Example:
  #
  # ["accounts", "1", "email"]
  #
  field: [String!]

  # An optional error code for clients to match on.
  code: UserErrorCode
}
```

ステータスコードのようなエラーメカニズムと比較して、データとしてのエラーが少し厄介なのは、クライアントがuserErrorsフィールドに問い合わせる必要がないことである。
つまり、クライアントによってはNULLのアカウントが返ってくるかもしれないが、なぜそうなるのかわからないということだ。解決策の一つは、APIのベストプラクティスについてクライアントを教育することですが、特にそのフィールドを含めなければ、クライアントがエラーに気づく保証はありません。
クライアントは "errors "GraphQLレスポンスのエラーを無視することもできますが、少なくともそれらはGraphQL仕様によって記述されているため、多くのクライアントはすでにそのようなタイプのエラー検出メカニズムを持っていることになります。

#### Union / Result Types

人気を集めているもう1つのアプローチも「データとしてのエラー」アプローチだが、エラー用の特定のフィールドを使用する代わりに、このアプローチではユニオン・タイプを使用して、クライアントに対して起こりうる問題のある状態を表現する。
同じ "サインアップ "の例で、結果ユニオンを使って設計してみましょう：

```gql
type Mutation {
  signUp(email: string!, password: String!): SignUpPayload
}
union SignUpPayload =
  SignUpSuccess |
  UserNameTaken |
  PasswordTooWeak
mutation {
  signUp(
    email: "marc@productionreadygraphql.com",
password: "P@ssword" ){
    ... on SignUpSuccess {
      account {
id
} }
    ... on UserNameTaken {
      message
      suggestedUsername
}
    ... on PasswordTooWeak {
      message
      passwordRules
} }
}
```
ご覧のように、このアプローチにはいくつかの利点があります。ここでのユニオン型は、変異の実行中に起こりうることを非常によく記述しており、各ケースはGraphQL型システムを使って強く型付けされています。
これにより、ユーザー名が取られていた場合のsuggestedUserNameや、提供されたパスワードが弱すぎた場合のパスワードルールのリストのように、各エラーシナリオにカスタムフィールドを追加することができます。
これは、私たちが見た両方のアプローチが伝えようとしていることを例証しています：いくつかのAPIエラーは、他のフィールドや型と同じようにユースケースとして公開されることを意図しており、クライアントも同じようにそれらを利用できるべきです。

#### So, which error style should you pick?

正直なところ、"ユーザーエラー "がスキーマできちんと定義されている限り、どのように実装すべきかについて強い意見はありません。ペイロード・タイプにあるemailIsTakenのような単純なフィールドでも、クライアントの数が少なかったり、使い始めたりする場合には使用できます。ユニオンを使用することは、間違いなくエラーを定義するための非常に表現力豊かな方法です。1つ注意しなければならないのは、クライアントの新しいタイプのエラーに対して、クライアントは防御的なコーディングをしなければならないということです。例えば

```gql
mutation {
  createProduct {
    ... on Success {
      product {
        name
      }
    }
    ... on ProductNameTaken {
      message
    }
    # What if ProductPriceTooHigh gets added?
  }
}
```

ProductPriceTooHighのような新しい型をクライアントが扱えるようにしなければなりません。スキーマがバージョン管理され、クライアント・アプリケーションがスキーマに対してコンパイルされ、大文字小文字のチェックが網羅的に行われるような世界では、これは完璧でしょう！しかし、私たちのほとんどは、特にウェブAPIの世界ではこのようなチャンスはない。このような理由から、論理和型のテクニックは素晴らしく、理論的には（網羅的な大文字小文字のチェックが可能なコンパイル済み言語では）完璧なのですが、GraphQLで使用する場合には不十分である可能性があるのです。
この時点で、このようなケースでuserErrorsリストに考えられる利点は、クライアントがすでに選択した同じフィールド内のすべての新しいエラーを取得できることです。これは、たとえ完璧にエラーを処理できなくても、必要であればエラーを表示し、デバッグしやすいようにエラーメッセージを記録できることを意味します。これは、クライアントのエラー処理に対して、もう少し一般的なアプローチを奨励するかもしれない。
クライアントが新しいエラー・シナリオを処理するのを助けるために使えるひとつのアプローチは、エラー・コントラクトを定義するインターフェース・タイプを使うことである：

```gql
interface UserError {
  message: String!
  code: ErrorCode!
  path: [String!]!
}
type DuplicateProductError implements UserError {
  message: String!
  code: ErrorCode!
  path: [String!]!
  duplicateProduct: Product!
}
```

こうすることで、クライアントはエラー時にメッセージ、コード、パスを常に選択することができ、エラー固有のフィールドも選択できるようになる：

```gql
mutation {
  createProduct(name: "Book", price: 1000) {
    product {
      name
      price
    }
    userErrors {
      message
      code
      path
      ... on DuplicateProductError {
        duplicateProduct
      }
    }
  }
}
```
同じテクニックがユニオンにも適用でき、可能性のあるすべての具象型をカバーするのではなく、インターフェイスの型にマッチさせることができるので、ユーザーの助けになる：

```gql
mutation {
  createProduct(name: "Book", price: 1000) {
    ... on CreateProductSuccess {
      product {
        name
        price
      }
    }
    ... on DuplicateProductError {
      duplicateProduct
    }
    ... on UserError {
      message
      code
      path
    }
  }
}
```
全体として、ユニオン・アプローチもuserErrorsアプローチも効果的です。
これらのアプローチに共通するのは、エラーをスキーマのデータとして扱うということです。しかし、userErrorsアプローチの方が、実行時にプログラムで入力しやすいことがよくあります。
既存の複雑なアプリケーションでは、検証ルールを明示的に定義するのが難しく、より汎用的なエラー処理が必要になることがあります：

```
  user_errors = errors_from_model(product)
```


もう一方では、型を定義し、スキーマを使ってシナリオを明確に定義することができる。ただ、スキーマの進化を重要視するのであれば、ユーザーは新しいケースを処理する方法でクエリを作成する必要があることに留意してください。この章の前半で見たように、ユニオン・アプローチは不可能な状態の設計を避けることもできます。userErrorsアプローチでは、エラーが発生したときにどのフィールドがnullになるかが不明確な場合があります。
このような場合、クライアントに、ユニオンのケースでエラー・タイプとマッチさせるか、ペイロード・タイプでuserErrorsフィールドを選択させるか、どちらかを強制するものはありません。これはまだGraphQLコミュニティで解決されていない問題であり、現在のところ、変異を実行するときにどのフィールド/タイプに注意する必要があるのか、またエラーを返す可能性のあるフィールドをユーザーが理解できるようにするためのドキュメントが必要です。GraphQLエラーでは、少なくともクライアントによってエラーが正しく処理される可能性が高いことがわかります。

### Schema Organization

GraphQLスキーマは、クライアントが要件を選択しなければならない可能性の大きなグラフです。
このため、ユースケースを見つけやすくするような方法でスキーマを整理したり、少なくとも似たような概念をグループ化したりすることについて尋ねたくなる人もいます。

#### Namespaces


多くの人がGraphQLスキーマの名前空間メカニズムを求めてきた。これまでのところ、どの提案も仕様にあまり進んでいません。
この章の前の命名で取り上げたアドバイスに従えば、これが大きな問題になることはほとんどないと思います。
十分に具体的な命名をしていれば、名前空間が絶対に必要な状況はまれでしょう。
しかし、非常に明確な方法で名前空間をつけなければならない場合は、例えばプレフィックスのような命名戦略を使うことをお勧めします：

```gql
type Instagram_User { # ...
}
type Facebook_User { # ...
}
```

私が見聞きしたところでは、名前空間に関する要望のほとんどは、第8章で取り上げるスキーマステッチのような戦略を使う開発者から来るものだ。
スキーマのステッチングは、異なるスキーマをマージすることを可能にし、名前の衝突の扉を開く。繰り返しますが、これは適切な命名によって解決できることが多く、特定のGraphQL機能の代わりにビルド時のツールによって支援することができます。
結果として得られるGraphQLスキーマと、そのスキーマをサーバーサイドで構築する方法は、まったく別の問題であることを覚えておいてください。
名前空間、モジュール、および再利用可能な関数をサーバー側で使用することで、コードの整理を助けることができます。

#### Mutations

突然変異の命名に悩むチームもある。変異の名前をcreateProductにするかproductCreateにするか。
たとえば、私がShopifyにいたころ、チームはproductCreateのルートにすることに決めました。
関連する変異はSDL/introspection/GraphQLでグループ化されるので、よりよい発見ができるようにするためです。
それは理にかなっていますが、私にとっては、整理のためだけに読みにくい名前にするのはいつも悲しいことだと感じていました。

cartProductAddのような名前ではなく、addProductsToCartのような具体的で読みやすい名前を使うことを恐れないでください。ツールは を発見しやすくすることができます。私が遊んでいるアイデアのひとつは、ドキュメントや他のツールのグループ化を助けるためにtagsディレクティブを使うことです：

```gql
type Mutation {
  createProduct(...):
    CreateProductPayload @tags(names: ["product"])
  createShop(...):
    CreateShopPayload @tags(names: ["shop"])
  addImageToProduct(...):
    AddImageToProductPayload @tags(names: ["product"])
}
```

別のアイデアとしては、親フィールドや「名前空間」を使って、shop { create(...) { id }のように、親フィールドの下に似たようなフィールドをグループ化する方法がある。
しかし、仕様とツールはそのような使い方を100％明確にしているわけではないので、今のところそのような使い方をすることはお勧めしません。
変異ルート上のトップレベル・フィールドは、副作用が期待される唯一のフィールドです。つまり、以下のようにグループ化された変異では、以下のようになります：

```gql
mutation {
  products {
    deleteProduct(id: "abc") {
      product
    }
  }
}
```

deleteProductは、理論的には読み取り専用フィールドと考えるべきです。個人的には、使用しているサーバーの実装では技術的にうまくいくかもしれませんが、このルートはお勧めしません。

### Asynchronous Behavior

APIが同期的でないことがある。何かがバックグラウンドで処理される必要があるため、すぐに結果を返すことができないのです。
RESTやHTTPベースのAPIでは、これを処理する最も一般的な方法は202 Acceptedステータスコードです。
しかし、GraphQLでこれを使用するのは厄介です。リクエストの一部だけが非同期で、残りはすぐに返せるかもしれないからです。
これをモデル化するにはいくつかのアプローチがあります。
たとえば、支払い処理を扱っている場合、保留中の支払いをユニオン型の中の型として設計することができます：

```gql
type Query {
  payment(id: ID!): Payment
}
union Payment = PendingPayment | CompletedPayment
```

ユニオンの代わりに単一型を選ぶこともできる：

```gql
type Operation {
  status: OperationStatus
  result: OperationResult
}
enum OperationStatus {
  PENDING
  CANCELED
  FAILED
  COMPLETED
}
```
別の解決策は、ジョブタイプとコンセプトを使って、これらのケースをより一般的に扱うことです。これはShopifyが管理画面のGraphQL APIで採用したものです。このアイデアはとても賢いものです。ジョブはグローバルIDで識別可能で、他に2つのフィールドがあります：
- 非同期ジョブが完了したか、まだ保留中かを示すdone boolean型。
- 楽しい部分： Queryルート・タイプを返すqueryフィールド。これは、ジョブが完了した後の新しい状態をクライアントが問い合わせるのに役立ちます。

### Data-Driven Schema vs Use-Case-Driven Schema


これまで私たちは、実際のユースケースを表現する、よく練られたGraphQLスキーマの設計について多くのことを話してきた。
迷ったときは、データのためではなくビヘイビアのためにGraphQLスキーマを設計するのが私の常套手段でした。
これは通常、APIを消費する際の素晴らしいエクスペリエンスにつながりますが、APIには他にも明確な用途があります。
GitHub GraphQL APIは、ビジネス／ドメインのユースケースを念頭に置いて設計されたスキーマの良い例だ。
このスキーマは、GitHub のドメインとやりとりするアプリケーションや、一般的なユースケースを利用するアプリケーションに適しています。
「課題のオープン」「コメント」「プルリクエストのマージ」「ブランチの一覧表示」「プルリクエストのページ付け」などです。

しかし、ある種の顧客は、GraphQLの構文と機能を見て、ビジネスから必要なデータを正確に取得できる大きな可能性を見出す。結局のところ 私たちがよく耳にする「1つのGraphQLクエリで必要なものを正確に取得する」ということは、そのように解釈されるかもしれません。例えば、5分ごとにすべての問題のすべてのコメントを同期する必要があるコメント分析アプリケーションを考えてみよう。必要なデータのクエリを作成し、1つのクエリを送信し、そして利益を得る。しかし、すぐにある問題にぶつかります：

- ほとんどのAPIは、データを大量に消費するためではなく、例えば人間に結果を表示するために作られているため、リソースをページ分割する。探しているものが純粋なデータである場合、ページ分割されたフィールドはそれをより難しくする。
- タイムアウト： ほとんどのGraphQL APIプロバイダーは、巨大なGraphQLクエリが長時間実行されることを望んでおらず、タイムアウトやレート制限を積極的に使用してそのようなことが起こらないようにします（これについては第4章で詳しく説明します）。しかし、純粋にデータ駆動型のクライアントは、目的を達成するためにかなり大規模なクエリを実行する必要があるかもしれません。有効なユースケースであり、過剰な使用シナリオではないとしても、何千ものレコードをクエリすると、クエリがブロックされる可能性がかなり高い。


かなり扱いにくいですよね？一方では、純粋にデータドリブンなユースケースを持つクライアントには正当な理由があるかもしれませんが、もう一方では、あなたのGraphQL APIはこの目的のために設計されていないかもしれません（そうであるべきでもありません）。実際、これは必ずしもGraphQLの問題ではありません。現在出回っているほとんどのAPIは、ユースケース主導のクライアントを構築することを主な目的としており、大量のデータ（大規模なGraphQLリクエスト、バッチHTTPリクエスト、または大量のHTTPリクエスト）を同期したい場合に対処するのは難しいでしょう。
ユースケースが実際にデータに関するものである場合、他の方法を考えなければならない。

#### Asynchronous GraphQL Jobs

その種の大きなリクエストのほとんどは計算に時間がかかり、リクエスト中に実行することはAPIプロバイダーにとって単純に実行不可能である。もう一つのアイデアは、APIプロバイダーが非同期に実行するクエリをスケジュールし、後で結果を取得することだ。現実的には、非同期クエリを登録するエンドポイントを用意することで実装できるだろう：

```
POST /async_graphql
{
  allTheThings {
    andEvenMore {
      things
      }
  }
}


202 ACCEPTED
Location: /async_graphql/HS3HlKN76EI5es7qSTHNmA
82
And then indicating to clients they need to poll for the result somewhere else:
GET /async_graphql/HS3HlKN76EI5es7qSTHNmA
202 ACCEPTED
Location: /async_graphql/HS3HlKN76EI5es7qSTHNmA
GET /async_graphql/HS3HlKN76EI5es7qSTHNmA
200 OK
{ "data": { ... } }
```

もう一つの例として、Shopifyは "Bulk Operations "と呼ばれる非同期GraphQLジョブの素晴らしい実践例を持っている。
これらの操作には同期GraphQL APIと同じスキーマを使用していますが、リソースを自動ページ分割することができ、レート制限を受けたり、クエリのタイムアウトに直面したりするリスクはありません。これは、より長く実行される、よりデータ指向のユースケースをサポートする素晴らしい方法だ。

### Summary

優れたAPIデザインはGraphQLにとどまらない。この章で見てきたベストプラクティスのほとんどは、HTTP APIやライブラリ設計、場合によってはUI設計などにも当てはまる。この章では多くの原則を見てきましたが、GraphQLスキーマを構築する際に覚えておくべき主なポイントは4つあると思います。
- 第一に、スキーマ開発にはデザインファーストのアプローチを使うこと。ドメインを最もよく知っているチームメイトと設計について議論し、実装の詳細は無視します。
- 第二に、クライアントのユースケースの観点から設計することです。データ、型、フィールドの観点から考えるな。
- 第三に、スキーマを可能な限り表現豊かにすること。スキーマは、クライアントを良い使い方に導くものでなければならない。ドキュメンテーションはケーキの上のアイシングであるべきだ。
- 最後に、非常に一般的で巧妙なスキーマの誘惑を避けること。クライアントのユースケースに明確に答える特定のフィールドと型を構築する。
これらの一般的なプラクティスに従えば、クライアントが気に入って使用し、時間の経過とともにうまく進化するスキーマへの道をすでに歩んでいることになる。