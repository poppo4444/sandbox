## GraphQL Schema Design
これまでに、GraphQLサーバーがタイプシステムを通じて可能性をどのように表現するかについてたくさん話しました。優れたGraphQL APIの鍵は、これらの可能性を正確に設計することから始まります。任意のAPI、ライブラリ、そして単純な関数と同様に、GraphQLスキーマデザインはあなたのAPIがどれだけ使いやすく理解しやすいかに大きな影響を与えます。この章では、素晴らしいデザインを思い付く方法と、具体的にはGraphQL APIを設計する際に避けるべきパターンまたは使うべきパターンをいくつか説明します。

## 何がAPIを優れたものにするのか？
優れたGraphQL APIを設計する要素について詳しく説明する前に、最終的な結果がどのように見えるべきかについて話すことが重要です。では、一般的に何が優れたAPIを作り出すのでしょうか？おそらく私のお気に入りの表現方法はJoshua Blochから引用するものです：

```
APIは使いやすく、誤用が難しいべきです
```

優れたAPIは、正しいことを行うのを簡単にし、間違ったことを行うのを実際には難しくするべきです。任意の開発者があなたのAPIにアクセスして、彼らが何を達成でき、それをどのように行うかを比較的容易に理解することができる必要があります。私たちのAPIは、APIの最良の使用方法に開発者を導き、またバッドプラクティスから彼らを遠ざけるべきです。全てこれは我々がそれをどのように設計するかによって行われます。

あなたが私と同じような人物であれば、過去にいくつかのAPIの使用に苦労したことがあるでしょう。我々の多くは、期待外れの奇妙な振る舞い、一貫性のない表現、古すぎるドキュメンテーション、そして他にも多数の問題に遭遇したことがあります。もしあなたがよく設計されたAPIと統合する機会を持っていたなら、それが開発者をどれだけ気分良くさせ、いかに迅速に任意の開発者が提供された機能と統合することを可能にするかを知っているはずです。これが、本書で最初に取り上げるデザインが重要な理由です：それはクライアントが統合するのを楽しむAPIを作る際に非常に重要な部分です。

GraphQLは基本的に、良いAPIを設計することを何も容易にしてくれません。それは強力なタイプシステムを提供しますが、それを正しく使わなければ、我々は他の任意のAPIスタイルと同じ罠に陥ることができます。

## デザインファースト
ユーザーに喜ばれるスキーマを作成する最良の方法は、プロジェクトの初期段階からデザインを考えることです。お気に入りのライブラリを使ってすぐに実装を始めたいという誘惑はあるでしょうが、デザインファーストのアプローチを取ることでほとんどの場合、より優れたAPIが得られます。これを行わないと、設計は一般的にシステム内部でどのように実装されているかに密接に結びつき、これはエンドユーザーが気にするべきではない問題となります。

おそらくあなたは、GraphQL APIを構築することに興味がある開発者として、この本を読んでいるのではないでしょうか。しかし、十分に大きな会社で働いていれば、APIがカバーするすべての領域で最も専門知識を持つ人物ではないことはほぼ確実です。これが、自分が提供するユースケースに最も詳しいチームや人々と協力することが非常に重要である理由です。しかし、GraphQLは私たちがこの章で取り上げるいくつかのデザイン上の問題を伴っています。最良のシナリオは、GraphQLの専門家とドメインの専門家が協力して働くことです。
API、特に公開されたものは、一度公開されると変更が非常に難しいです。設計を初めに考え、概念をよく理解することで、将来的な予期せぬ変更のリスクを軽減することが可能になります。

## クライアントファースト
序章で見たように、GraphQLはクライアント中心のAPIです。この哲学は、私たちがGraphQLのAPIをどのように設計するべきかにも影響します。バックエンドのリソースやエンティティの観点からAPIを設計するのは魅力的ですが、何よりも先にクライアントのユースケースを考えてGraphQLのAPIを設計することが非常に重要です。そうすることで、クライアントのニーズに応えるAPIを構築し、使いやすく誤用しにくい設計をすることが可能になります。これを怠ると、クライアントが目指すことを達成するために推測したり大量のドキュメントを読んだり、最悪の場合はそれを達成できなくなったりする一般的なAPIになってしまうことがよくあります。
これが正しく行われていることを確認するための良い方法は、できるだけ早い段階で「最初のクライアント」と協力することです。つまり、デザインを早期にクライアントと共有し、彼らができるだけ早くAPIと統合すること、さらにはAPIデザインに沿ってモックサーバーを提供することを意味します。このプロセスについては第6章で詳しく説明します。これは特に内部やパートナーのAPIでは当然のことで、公開APIでは少し難しい場合もあります。いずれにせよ、APIの受け手になる人々と協力するよう努めるね。

クライアントファーストが常にクライアントの望む通りに行うことを意味するわけではありません。特に、公開APIを扱う際にはそうです。多くの場合、クライアントが問題に遭遇すると、彼らは直接あなたに解決策を持ってきます。彼らが提案している解汓名の実装に入る前に、まず問題について情報を集め、一歩引いて考えることが重要です。問題の背後にはもっと洗練された解決策が存在する可能性が高いです。

同様に、「You Aren’t Going to Need it（YAGNI）」というマントラも、APIの設計において非常に有用です。これはExtremeProgrammingやアジャイルソフトウェアコミュニティから来た言葉です。私たちのAPIは完全であるべきで、つまりクライアントが関心を持っているユースケースを達成するために必要な機能だけを提供するべきです。しかし、それ以上のことは何も公開してはなりません！私は何度もAPIが非推奨になったり変更が必要になったりした例を見てきました。その原因は、誰も考えていない何かが公開され、ひどい設計につながったり、最悪の場合は性能やセキュリティ上の理由からクライアントに公開されるべきでない何かが公開されたりすることです。

もう1つクライアント中心の設計が役立つことは、私たちは実装の詳細に影響されたスキーマを設計していないことを確認することです。あなたのAPIと統合する開発者は、あなたがどのデータベースを使用しているか、サーバーがどのプログラミング言語で構築されているか、バックエンドでどのような設計問題があるかなどとは関係ありません。GraphQLスキーマは機能へのエントリーポイントであり、バックエンドの実装詳細にそれを結びつけることを避けるべきです。もちろん、可用性やパフォーマンスなどの問題が設計を左右することもありますが、それも非常に慎重に、クライアントを念頭に置いて行うべきです。これはより優れたAPIを作るだけでなく、内部事情に依存した外部APIが抱える多くの問題を避けることにもなります。私たちは、外部のクライアントが使用するAPIよりもはるかに素早いペースで内部事情を変更できるようにしたいのです。スキーマを構築する際にはこれを念頭に置くようにしてください。

GraphQLの型付け特性は、データベースや他のデータソースからGraphQL APIを構築するツールを提供する多くのベンダーを引き付けるようです。あなたが "クライアントファースト" の視点でAPIを構築しているならば、これはめったに意味をなしません。これはこれまでに述べた全てに反します：
- スキーマが実装の問題に依存してしまいます。
- 結果は、テーブルやエンティティを中心に非常に一般的になります。
- クライアントのニーズは全く考慮されていません。
- 通常、必要以上に多くのことが公開されます（YAGNI）。

これらのツールが無用であると言っているわけではありません。これらは素早いプロトタイピングや、データベース上のGraphQLレイヤーが実際に必要な場合に便利です。しかし、API設計について真剣に考え、洗練されたクライアント中心の体験型APIを求める私たちにとって、これらのツールが求めている結果を得られることはめったにありません。

他のタイプのジェネレーターは、既存のAPI定義、Swagger/OpenAPIを取り、それをGraphQLスキーマに翻訳するものです。これらのツールは非常に注意深く使いましょう。APIはそれが構築されるアーキテクチャやスタイルを考慮に入れるべきです。RESTとGraphQLは異なる設計上の問題を抱えています。たとえば、REST APIでは、リソースに焦点を当て、HTTPメソッドのセマンティクスを用いてそれらと対話するべきです。非常に素朴なジェネレーターはpostUserやputProductのような変異を生成するでしょうが、実際にはGraphQLでのリモートプロシージャコールのように見えるAPIスタイルを扱っている場合、createUserやupdateUserが最も適した呼び出しになるでしょう。これらのツールを調整してまともな結果を出すことは可能ですが、人間が設計したGraphQLファーストの策定されたAPIと同じくらいきれいに設計されることはありません。当然、コンテキストによってはこの取引が受け入れられるかもしれませんが、それを理解することは重要です。

素晴らしいAPIの特性について説明したので、次に具体的な良い実践に進みましょう！

### Naming

名前はAPIがあなたに語りかけているのだ

上の引用は、またしてもJoshua BlochのHow To Design A Good API and Why it Mattersからの引用である。
私はこの引用が大好きで、主に優れたJava APIを設計することに関連しているが、GraphQLのようなウェブAPIにも非常によく当てはまる。
ネーミングを正しくするのはとても難しいが、考えることはとても重要だ。
良い名前は、ドキュメントを読んだり、最悪推測したりする前に、そのAPIが何をするものなのかという情報を即座に伝えます。
実際、良いネーミングはそれだけで正しい設計に導いてくれることが多い。
ネーミングに関しては、一貫性が王様だ。クライアントは新しいAPIを使う前に、時間をかけて理解しなければならないことを忘れないでほしい。
物事が一貫していれば、新しいAPIを発見することはユーザーにとって自然に感じられるだろう。
ここに良い例がある：

```gql
type Query {
  products(ids: [ID!]): [Product!]!
  findPosts(ids: [ID!]): [Post!]!
}

type Mutation {
  addProduct(input: AddProductInput): AddProductPayload
  createPost(input: CreatePostInput): CreatePostPayload
}
```

このスキーマは、命名に関してはまったく一貫性がない。クエリ側では、オブジェクトのリストを取得するために2つの異なる命名スキームがあることに注目してほしい。
一方では、投稿を見つけるにはfindというプレフィックスを付け、もう一方では、商品を見つけるには単純なproductsフィールドを付ける。
このようなスキーマは予測不可能なので、クライアントにとっては実に使いにくい。すでにfindPostsを使用していて、productsと統合したいクライアントは、フィールドが存在しないというエラーに遭遇するか、単に探しているものが見つからないまで、findProductsを使用してそれができると仮定する可能性が高い。
このようなアクション動詞に一貫性を持たせるだけでなく、ドメインコンセプトの名前の付け方にも一貫性を持たせるべきです。
例えば、BlogPostとPostというように、実際に異なる概念でない限り、どこかにBlogPost、どこかにPostというような名前をつけないことだ。

もう一つの良い例は、Mutationタイプにある。
一方ではaddProductを使ってショップに商品を追加できるが、ソーシャルメディアへの投稿を追加するにはcreatePostを使う。
このような接頭辞の問題はよくあります。このような不一致が積み重なると、APIを探索したり使ったりするのが本当に難しくなります。

APIの対称性も重要だ。
対称性とは、例えば、特定のエンティティが与えられたときに、対称的なアクションが可能であることを確認することである。
例えば、publishPostの変異があると、unpublishPostの変異があるように見える。
特に、スキーマ内の他の変異がそのように対称的であればなおさらです。
最小驚嘆の原則に従うことは、一般的に非常に良い考えです。

スキーマ・メンバーの命名に関しては、過度に具体的にすることも考慮すべき良いアイデアだ。
具体的にすることで、そのオブジェクトやフィールドが一体何を表しているのかについてのクライアントの混乱を避けるだけでなく、GraphQL APIプロバイダーにも役立ちます。多くの大規模システムでは、似たような概念に複数の名前が付けられています。
Event（イベント）」や「User（ユーザー）」のような非常に一般的または汎用的な名前が導入されると、多くの場合、命名領域が占有され、より具体的な概念を導入することが難しくなります。
一般的な名前は後々役に立つかもしれないので、残しておくようにしましょう。
ネーミングの失敗例を挙げよう。クエリールートのビューアーとして機能するUserオブジェクトを紹介します。
このオブジェクトには、現在ログインしているユーザーに関する情報が含まれています。

```gql
type Query {
  viewer: User!
}

type User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

数カ月後、チームは、このオブジェクトが、チームメンバーをリストアップするときなど、ログインしているユーザーの範囲外で使用されていることに気づく：

```gql
type Query {
  viewer: User!
  team(id: ID!): Team
}
type Team {
  members: [User!]!
}
type User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

しかし、チームメンバーの個人情報を公開するのは意味がないことにすぐに気づく。
ビューワーでないユーザーがこれらのフィールドにアクセスするたびにエラーを発生させるか、新しい型を作る必要がある。最初の解決策は、かなり非現実的で、クライアントにとって良いとは言えず、実装に関してもかなりもろい。
チームは大規模な非推奨化を行う必要があり、Userはむしろインターフェイスであり、ViewerとTeamMemberはおそらく独自の型であるべきだったと気づくだろう：

```gql
type Query {
  user(id: ID!): User
  viewer: Viewer!
  team(id: ID!): Team
}
type Team {
  members: [User!]!
}
interface User {
  name: String!
}
type TeamMember implements User {
  name: String!
  isAdmin: Boolean!
}
type Viewer implements User {
  name: String!
  hasTwoFactorAuthentication: Boolean
  billing: Billing!
}
```

具体的なネーミングをすることで、大きな非推奨化を避けることができたし、クライアントにとっても使いやすく、理解しやすいものになった。
正しいネーミングは正しいデザインへと導いてくれるが、間違ったネーミングは悪いデザインへと深みにはまっていくだけだ。

### Descriptions

ほとんどのGraphQLスキーマメンバは、記述を使用してドキュメント化することができる。
SDL で言えば、次のようになります：

```gql
"""
An order represents a `Checkout` that was paid by a `Customer` """
type Order {
  items: [LineItem!]!
}
```

ディスクリプションは、ドキュメントのような外部ソースで見つけるのではなく、スキーマに直接この情報をエンコードするので素晴らしい。
探索するとき GraphiQLを使用してAPIを探索するとき、ユーザーはスキーマと一緒に記述を素早く読むことができます。

スキーマのほぼすべてのエンティティを記述するのは良いアイデアだ。
良い記述は、スキーマの型が何を表しているのか、どのような突然変異が起こるのか、などを明確に伝えるべきです。
しかし、記述が素晴らしいのと同様に、スキーマの設計が不十分であることが明らかになることもある。

理想的には、記述はケーキの上のアイシングに過ぎません。あなたのAPIと統合しようとするクライアントが、あなたのAPIがどのように利用でき、どのように利用すべきかを理解するために、説明を読む必要はほとんどないはずだ。
すでに話したように、スキーマはすでに物事が何を意味し、どのように使われるべきかを伝えているはずだ。
典型的な匂いは、エッジケースを記述する記述、条件式を含む記述、文脈に応じた振る舞いを記述する記述です。
肝心なのは、記述を使うことですが、ユースケースを理解するためにユーザーを記述に依存させないことです。
GraphQLドキュメントについては第10章で詳しく説明します。

### Use the Scehma, Luke!


GraphQLはAPIを設計するために、この素晴らしく表現力豊かな型システムを提供してくれます。
それをフルに活用することで、ユーザーが理解するための実行時の動作に依存しない、驚くほど表現力豊かなAPIを実現することができます。
次の例では、名前、価格、型を持つProduct型のスキーマがあります。タイプは、"アパレル"、"食品"、"おもちゃ "などの商品のタイプである。

```gql
type Product {
  name: String!
  priceInCents: Int!
  type: String!
}
```

このスキーマの潜在的な問題のひとつは、クライアントがこの型から何が出てくるかを理解するのに非常に苦労するかもしれないということだ。
どのようにtypeフィールドを扱えばいいのだろうか？もしtypeに設定された数の項目があるなら、このスキーマを "自己文書化 "し、実行時の保証も提供する、より良い方法は、ここでenum型を使うことだろう：

```gql
enum ProductType {
  APPAREL
FOOD
TOYS
}
type Product {
  name: String!
  priceInCents: Int!
  type: ProductType!
}
```

もう1つの一般的で魅力的な設計上の問題は、スキーマの一部として完全に構造化されていないデータを持つことです。
これはしばしば、フィールドをどのようにパースするかを示す記述を持つString型か、時にはJSONのようなスカラー型として行われます。

```gql
type Product {
  metaAttributes: JSON!
}
type User {
# JSON encoded string with a list of user tags tags: String!
}
```

ほとんどの場合、より良いアプローチは、これらのことを表現するために、より強力なスキーマを使用することである。

```gql
type ProductMetaAttribute {
  key: String!
  value: String!
}
type Product {
  metaAttributes: [ProductMetaAttribute!]!
}
```

これは非常に似ているように見えるかもしれないが、型付きスキーマによって、クライアントはこの動作をはるかに優れた方法で処理できるようになり、クライアントが壊れることを恐れることなくスキーマを長期にわたって進化させることができる。
カスタムエンコーディングのスカラーや文字列を使用するとすぐに、型付けされた GraphQLスキーマが与えてくれるすべてを失うことになる。
たとえば、潜在的に再帰的なデータ構造など、どうしてもスキーマを使用しなければならない場合は、注意して使用してください。できる限り強力なスキーマを使用するようにしてください。

例えば、カスタム・スカラーは、文字列としてシリアライズされたフィールドをより有用な型に変えるのに役立つかもしれない：

```gql
type Product {
# Instead of a string description, we use a
# custom scalar to indicate to clients
# that they can treat the result of this field # as valid markdown.
description: Markdown
}
scalar Markdown
```

また、より正確な検証のための入力タイプとして使用することもできる：

```gql
input CreateUser {
  email: EmailAddress
}
# A valid email address according to RFC5322
scalar EmailAddress
```

要するに、より強力なスキーマを使う機会があれば、すぐにそれを検討すべきだということだ。
これは、単純なスカラーではなく、より複雑なオブジェクト・タイプを使用すること、列挙型を使用すること、そして意味のある場合はカスタム・スカラーを使用することでもよい。


### Expressive Schemas
GraphQLのタイプシステムにより、本当に表現豊かなAPIを構築することが可能となります。それは何を意味するのでしょうか？表現豊かなAPIは、クライアント開発者がAPIの使い方を容易に理解することを可能にします。それは使いやすく、誤用することは困難です。さらに、前節で見たように、GraphQLスキーマは、APIプロバイダーがドキュメンテーションを見たり、最悪の場合、それを最初に実装しなければならない状況になる前に、APIの使用方法を表現することを可能にします。

表現豊かなスキーマを構築する一つの方法は、nullabilityを利点に使うことです。以下は、GraphQL APIが製品を見つける方法を提供している例です。製品はグローバルIDまたは名前で参照することができますが、これは私たちが単一のショップにスコープされているためです。これを実現する一つの方法は、idとnameフィールドの両方をオプションで受け入れるfindProductフィールドを作ることです

```gql
type Query {
# IDまたは名前でクエリを検索します。なしまたは両方を渡すと、
# NotFoundエラーが発生します。
findProduct(id: ID, name: String): Product
}
```

この設計は確かにクライアントの要求を満たします。しかし、それは全く直感的ではありません。クライアントが引数を一つも提供しない場合はどうなるでしょうか？また、両方とも提供した場合はどうなりますか？これらのケースのどちらでも、サーバーはAPIが意図した使用方法ではないため、おそらくエラーを返すでしょう。同じユースケースを解決する方法がありますが、それは明示的に文書化する必要がなく、開発者がランタイムでこれを発見することはありません
```gql
type Query {
  productByID(id: ID!): Product
  productByName(name: String!): Product
}
```

これは一部の方には少し驚きかもしれません。これらのフィールドは非常に似ています；私たちはそれらのために同じフィールドを再利用できないのでしょうか？実際には、序論で少し触れたように、GraphQLで物事を行うさまざまな方法を提供することを恐れる必要はありません。製品をフェッチする5つの異なる方法を公開したとしても、既存のクライアントにオーバーヘッドを追加することはありません。これらのクライアントが単に自分たちのユースケースに最も適したものを選択するだけであることを私たちは知っています。フィールドが単一で必須になったことがわかります、つまりAPIの誤用が非常に困難になりました。スキーマ自体が、検証時にクライアントにフィールドの使用方法を指示します。もう少し複雑な例を見てみましょう

```gql
type Payment {
  creditCardNumber: String
  creditCardExp: String
  giftCardCode: String
}
```

これは、顧客が行った支払いを表すPayment型です。注文の支払い方法により、可能性として3つのフィールドが埋められます。クレジットカードが使用された場合、creditCardNumberおよびcreditCardExpフィールドを記入する必要があります。また、注文でギフトカードが使用された場合、giftCardCodeフィールドが存在します。まず改善できるポイントは、これらの一部を表現するためにより強固なスキーマを使用することです。

```gql
type Payment {
  creditCardNumber: CreditCardNumber
  creditCardExpiration: CreditCardExpiration
  giftCardCode: String
}
# 16桁のクレジットカード番号を示す
scalar CreditCardNumber
type CreditCardExpiration {
  isExpired: Boolean!
  month: Int!
  year: Int!
}
```

いくつかの問題が解決されています。クライアントが提供する形式を理解するのが難しいString型のクレジットカード有効期限の代わりに、これを月と年の両方に整数フィールドを持つCardExpirationDetails型にリファクタリングしました。これはクライアントが通過させる文字列よりも使いやすいだけでなく、この有効期限詳細タイプにフィールドを追加して進化させることもできます。たとえば、最終的にはisExpired：Booleanフィールドを追加してクライアントがこのロジックを理解するのを助けることができます。また、クレジットカード番号用にカスタムスカラーを使用しました。これは、クレジットカード番号にはかなり特定の形式があるため、クライアントに少し意味を提供します。

まだ改善の余地があります。すべてのフィールドがnull可能であることに注意してください。これは、クライアントがランタイムでの支払いオブジェクトの見た目を確認するのが非常に難しいことを意味します。それを良くすることができます。

```gql
type Payment {
  creditCard: CreditCard
  giftCardCode: String
}
type CreditCard {
  number: CreditCardNumber!
  expiration: CreditCardExpiration!
}
# Represents a 16 digits credit card number
scalar CreditCardNumber
type CreditCardExpiration {
  isExpired: Boolean!
  month: Int!
  year: Int!
}
```

すでに格段に良くなりましたね！クレジットカード関連の入力フィールドを全て含むオブジェクト型を使用しました。これにより、スキーマがクレジットカードの入力が渡された場合、その入力はすべてのフィールドを持つ必要があることを示しています。これは、現在必須となったフィールド「number」と「expiration」に示されています。前のバージョンでは、この種の条件を自分たちの実装で処理する必要がありましたが、代わりにスキーマがそれを処理してくれます。フィールド接頭辞を見ることで、このようなリファクタリングが必要かどうかを示す一般的な臭いがあります。型上の複数のフィールドが接頭辞を共有している場合、新しいオブジェクト型下にある可能性が高いです。この方法もまた、ルートでさらにフィールドを追加する代わりに、今回の場合はPaymentオブジェクトで、スキーマをより良く進化させることができます。

この原則を別の言葉で表現すると、「不可能な状態を不可能にする」という引用があります。誰が最初に言ったのかは難しいですが、強く型付けされた言語について話すとき、これはよく言われることばです。これが意味することは、スキーマの型を見ると、この型は情報が一貫していない状態を不可能にします。非常にシンプルな例を見てみましょう。Cartオブジェクトを持っており、これには購入したいアイテムのセットが含まれています。このカートオブジェクトには、誰かがアイテムのために支払いを行ったのか、そしてこれまでにどれだけ支払われたのかを知らせる属性もあります。

```gql
type Cart {
  paid: Boolean
  amountPaid: Money
  items: [CartItem!]!
}
```

このスキーマを持っていると、残念ながらクライアントは不可能な状態を表すデータを取得することが可能です。例えば、カートは支払いが完了したと表示されていますが、amountPaidがnullであるという意味がありません。

```gql
{
"data": {
    "cart": {
      "paid": true,
      "amountPaid": null,
      "item": [...]
    }
  }
}
```

またその逆も考えられます：カートは未払いだと言いつつ、amountPaidは全額存在しています。

```gql
{
"data": {
    "cart": {
      "paid": false,
      "amountPaid": 10000,
      "item": [...]
    }
  }
}
```

むしろ、型システムのおかげでこれらの状態を許可しないスキーマを作成したいと考えています。常にこの解決策は文脈によります。この場合、おそらく我々が欠落していた概念があるのかもしれません。Order型が支払ったカートを表現し、カートは単純にオブジェクトの袋を表しているのかもしれません。他のケースでは、関連フィールドをオブジェクト型の下に単純にラップすることで避けることができます。例えば、カートにpaymentプロパティがあると、それが支払われたことを意味すると言うことができます。そして、その場合にpaidとamountPaidの両方が存在することを確認するためにnullabilityを使用することができます。

```gql
type Cart {
  payment: Payment
  items: [CartItem!]!
}
type Payment {
  paid: Boolean!
  amountPaid: Money!
}
```

次に進む前に、クライアントが使用するのが難しく驚くようなAPIのもう一つの例を見てみましょう。この例では、オプションのsort引数を取るproductフィールドを持っています。これはクライアント全員に特定の並び順を求めていない場合に、sort引数の値を渡すことを強制したくないからかもしれません。

```gql
type Query {
  products(sort: SortOrder): [Product!]!
}
```

問題は、スキーマがデフォルトのソート順について何も教えてくれないことです。その代わりに、GraphQLは私たちにデフォルト値を提供しています。これらはデフォルトのケースを文書化するのに非常に有用です。したがって、解決ロジックでデフォルトのソート順を設定する代わりに、それをスキーマに直接エンコードすることができます。

```gql
type Query {
  products(sort: SortOrder = DESC): [Product!]!
}
```

ご覧の通り、スキーマを使いやすく理解しやすくする方法はたくさんあります。
- フィールドが一つのことを上手く行い、可能な限り賢明または一般的なフィールドを避けるようにします。
- スキーマがそれを強制する時にはランタイムロジックを避けるようにします。
- フィールドと引数の間のカップリングを表現するために、複雑なオブジェクトと入力タイプを使用します：「不可能な状態」を避けます。
- オプションの入力と引数を使用した場合のデフォルトの振る舞いを指示するために、デフォルト値を使用します。

### Specific or Generic

APIコミュニティが長年にわたって行ってきた具体的または汎用の大いなる議論について考えてみましょう。一方で、私たちが提供するユースケースを非常に具体的にすることは、その特定の機能に興味のあるクライアントにとって非常に最適化されていることを意味します。しかし他方では、一部のクライアントにとって特定すぎるAPIは、他のクライアントのカスタマイズの余地を少なくしてしまいます。これは特に、彼らのユースケースをまだ知らない多くの未知のクライアントを扱っている場合に特に当てはまります。

しかし、GraphQLの中心的な哲学はすべて、クライアントが必要なものを正確に消費できるようにすることであるため、そのことを念頭に置いてスキーマを構築し、特定のクライアントのニーズに答えるシンプルなフィールドを選択することは、一般的に良い考えです。一般的すぎるフィールドは誰にも最適化されていない傾向があり、また理解するのが難しくなることもあります。フィールドはよく一つのことを行い、それを非常にうまく行うべきです。フィールドが一つ以上のことをしようとしている可能性がある良い指標は、ブーリアン（真偽値）引数です。それを異なるフィールドに分割することで、より良い設計を得ることがよくあります。以下に一般的な例を示します。

```gql
type Query {
  posts(first: Int!, includeArchived: Boolean): [Post!]!
}
```

投稿のフィールドをアーカイブされた投稿と通常の投稿の両方をリスト表示できるようにするのではなく、それらを二つのフィールドに分けたらどうでしょうか。

```gql
type Query {
  posts(first: Int!): [Post!]!
  archivedPosts(first: Int!): [Post!]!
}
```

このように二つの明確なユースケースに分割するだけで、最適化やキャッシュの管理が簡単で、クライアントが理解しやすいスキーマになります。しかし、これは基本的な例です。汎用フィールドの使用が過度になる最も一般的な例は、おそらく以下のような非常に複雑なフィルターです。

```gql
query {
  posts(where: [
    { attribute: DATE, gt: "2019-08-30" },
    { attribute: TITLE, includes: "GraphQL" }
  ]) {
    id title date
  }
}
```

このようなSQLに近いフィルタリング構文は非常に強力ですが、ほとんどの場合は避けることができます。それらは非常に汎用的であるため、サーバーチームは1つのリゾルバ内のすべてのパフォーマンスエッジケースを処理する必要がありますし、また特定のユースケースにフォーカスしていないため、クライアントでも発見や使用が難しくなってしまいます。

フィルターは、実際の検索やフィルタリングのユースケースを実装している場合に非常に便利です。しかし、これらの汎用フィールドがどれだけ必要なのかを意識するようにしてください。特定のユースケースを他の方法で公開することはできますか？例えば、

```gql
type Query {
  filterPostsByTitle(
    includingTitle: String!,
    afterDate: DateTime
  ): [Post!]!
}
```

この具体的対汎用の全体的な議論は、ビルド中のAPIの種類に大いに依存します。例えば、何らかの検索インターフェイスのための各種SQL風のフィルターをサポートするAPIを作成している場合、汎用ルートを採用することが多くの意味を成すかもしれません。ただし、この時点では、あなたは実際のユースケースを実装しているだけです！

### Anemic GraphQL

アネミックGraphQLは、マーチン・ファウラーによって広められたアネミック・ドメイン・モデルから引き出したものです。アネミックGraphQLとは、行動や使用例、機能性を考えることなく、データの塊としてスキーマを設計することを意味します。これは以下の例で最もよく表現されています。

```gql
type Discount {
  amount: Money!
}
type Product {
  price: Money!
  discounts: [Discount!]!
}```

例えば、電子商取引ストアの製品を表すこのProduct型を考えてみましょう。この例では、製品には価格と、現在適用されている割引のリストがあります。そしてクライアントが顧客に支払わせる実際の価格を表示したいと想像してみてください。それは非常にシンプルですよね？製品の価格からすべての割引を差し引くだけです。

```js
const discountAmount = accounts.reduce((amount, discount) => {
  amount + discount.amount
}, 0);
const totalPrice = product.price - discountAmount
```

クライアントは当面、この価格を顧客に表示することができます。しかし、Product型が進化すると問題が発生します。数ヶ月後に製品に税金が追加されたと想像してみてください:

```gql
type Product {
  price: Money!
  discounts: [Discount!]!
  taxes: Money!
}
```

今度は税金が追加されたので、最初のクライアントのロジックはもう成り立ちません。つまり、顧客が間違った価格を見ることになります。これを防ぐ方法は何だったのでしょうか？クライアントが実際に関心を持っていたもの、すなわち合計価格を公開することはどうでしょうか？

```gql
type Product {
  price: Money!
  discounts: [Discount!]!
  taxes: Money!
  totalPrice: Money!
}```

このようにして、クライアントは彼らが興味を持っているものを正確に消費することができ、totalPriceに影響を与える要素が何であろうと、彼らは常に正確な値を得ることができます。これは、私たちがスキーマをドメインによって設計したためであり、ただデータをクライアントが消費するために公開しただけではありません。毎回何かが追加される度に脆弱なクライアントコードを更新する必要がなくなったのです。

次に、eコマーストランザクション中にチェックアウトを更新するためのミューテーションを見てみましょう:

```gql
type Mutation {
  updateCheckout(
    input: UpdateCheckoutInput
  ): UpdateCheckoutPayload
}
input UpdateCheckoutInput {
  email: Email
  address: Address
  items: [ItemInput!]
  creditCard: CreditCard
  billingAddress: Address
}```

初めて見たとき、これはクライアントにとって素晴らしいものに思えます。それは彼らにそのチェックアウトの任意の属性を変更させることができます。しかし、詳しく見てみると、このアプローチにはいくつかの問題があることがわかります：

- ミューテーションがデータに非常に重点を置き、行動には注目していないため、クライアントは特定のアクションをどのように行うべきかを推測しなければなりません。もし、チェックアウトにアイテムを追加することが他の属性の更新を必要としたらどうでしょう？クライアントはランタイムエラーを通じてしかそれを知ることができないか、最悪の場合、一つの属性を更新するのを忘れて間違った状態になる可能性があります。
- 「カートに追加」のような特定のアクションを取るときに更新するべきフィールドのセットを選択する必要があるため、クライアントに認知的な負担を強いています。
- 私たちはCheckoutの内部データの形状に焦点を当てていて、Checkoutの潜在的な行動には焦点を当てていないため、これらのアクションが可能であることを明示的に示していません。私たちは彼らに私たちのデータモデルを見て推測してもらうことになります。
- すべてをnullableにしなければならなかったため、スキーマは全体的に表現力が少なくなっています。

これらの粗大な一般的なミューテーションに対する代替策は、細分化されたアプローチを採ることです:

```gql
type Mutation {
  addItemToCheckout(
    input: AddItemToCheckoutInput
  ): AddItemToCheckoutPayload
}
input AddItemToCheckoutInput {
  checkoutID: ID!
  item: ItemInput!
}
```

我々はさきほど指摘した多くの問題を解決しました：
• スキーマは強く型付けされています。このミューテーションでは何もオプションではありません。クライアントはアイテムをチェックアウトに追加するために具体的に何を提供しなければならないかを正確に知っています。
• もう推測する必要はありません。データを更新する代わりに、アイテムを追加します。クライアントはこれらのケースで更新する必要があるデータについて気にしません。彼らはただアイテムを追加したいだけです。
• ミューテーションの実行中に発生可能なエラーのセットが大幅に削減されました。私たちのリゾルバはより細かなエラーを返すことができます。
• クライアントがこのミューテーションを使用して奇妙な状態に陥ることはありません。それは私たちのリゾルバが取り扱っています。

この設計の興味深い副次効果として、このようなミューテーションのサーバーサイドの実装は、一つのことに焦点を当てているため、そして入力やペイロードが予測可能であるため、理解しやすく書きやすいものになっています。pub/sub subscriptionsの世界では、特定のミューテーションによってどのイベントがトリガーされるべきかがはるかに明確に見えます。

### Global Identification
GraphQL APIで人気を博したもう1つのコンセプトは、オブジェクトのグローバル識別である。
これも元々はRelayから来たものですが、その後一般的に良いプラクティスとなっています。
この考え方は、GraphQLクライアントが一意の識別子を与えられたグラフ内の任意の「ノード」をフェッチできるようにすることです。
実際には、これはGraphQLサーバーがグローバルノード（id: ID!） Nodeフィールドを公開することで、クライアントはその単一のフィールドを通じて任意のノードをフェッチできるようになります。
nodeフィールドはNodeインターフェース・タイプを返します：

```gql
interface Node {
  id: ID!
}

type User implements Node {
  id: ID!
  name: String!
}
```

このNodeインターフェイスは、このオブジェクトがグローバルに一意なIDを持ち、node(id: ID!)フィールドとnodes(ids: [ID!]!)フィールドを使ってフェッチできることを示す手段である。
これらすべての目的は何でしょうか？その多くはクライアントサイドのキャッシュです。
GraphQLクライアントは、以前にフェッチしたノードを保存するために複雑な正規化キャッシュを構築することがよくあります。
Relayには単一ノードを再フェッチするメカニズムが必要であり、ノード規約を持つことで、クライアントはそれをあまり設定することなく行うことができます。
グローバル識別は絶対に必要ですか？必ずしも必要ではない。
RelayクライアントがAPIを使用することを想定しておらず、単一のグローバル識別子を使用してオブジェクトをフェッチする必要性がない場合は、実装する必要はありません。
たとえばApolloのようなクライアントは、型名と単純なIDを組み合わせてグローバル識別子を作成することができます。

とはいえ、特定の「ノード」や「オブジェクト」に対してグローバルに一意なIDを持つことは、非常に有用な原則となりうる。
実際、これらは例えばRESTリソースを識別するために使用される統一リソース識別子（URI）に似ている。REST URIのように、これらの識別子の重要な部分の1つは、ユーザがIDを構築したりハックしようとせず、APIから取得したIDを直接使用することです。
これを確実にする良い方法は、不透明な識別子を使うことだ：

```json
{
  "data": {
    "node": {
      "id": "RmFjdGlvbjoy"
    }
  }
}
```

IDを不透明にする最も一般的な方法は、Base64にすることだ。
ここでの目的は、IDがどのように作られているかを完全に隠すことではない（Base64であることをクライアントが知るのは簡単だ）。
その代わりに、この文字列が不透明であることをクライアントに思い出させるだけである。
不透明なIDは、クライアントがIDがどのように構築されるかに関連したロジックを構築していないことを期待しながら、根本的なID生成を変更することを可能にするので、素晴らしいものです。
しかし、時には、開発者にとって最高のエクスペリエンスにつながるとは限りません。
クライアント・アプリケーションを構築する際に、自分の手元にあるノードIDがどのようなものかを知るのは難しいかもしれない。
私が興味を抱いているアイデアは、不透明なIDで、まだ自分自身について少し知ることができます。
私が初めてこのようなものに出会ったのはSlack APIだったと思う。
オブジェクトのタイプに応じて異なる文字で始まる不透明なトークンがあった。グローバルIDには、開発者を助けるためにちょっとした情報を含めるのがいいのかもしれない。

これらのIDを作成する場合、このノードをグローバルにフェッチするのに役立つ情報をできるだけ多く含める必要があります。
最も基本的なケースでは、これは通常type_name:database_idですが、常にこれをデフォルトとすべきではありません。
特に分散アーキテクチャでは、ルーティング情報がないとノードをフェッチできないことがあります。
このノードへの "ルーティング "を容易にする情報があれば、必ず含めてください。
例えば、"products "は "shops "によって共有または配布されるかもしれません。
つまり、IDにはshop_id:type_name:idというショップIDが必要になるかもしれません。

要約すると

- 特にRelayをサポートするつもりがないのであれば、グローバルIDは必ずしも必要ではない。
- コネクションのように、Relayのコンテキスト以外でも有効なパターンです。
- 不透明なIDを推奨する。
- グローバルIDには、ノードにグローバルにルーティングするのに十分なコンテキストが含まれていることを確認してください、

特に分散アーキテクチャでは。

### Nullability

NullabilityはGraphQLの概念で、フィールドがクエリーされたときにNULLを返すかどうかを定義することができます。
GraphQLを紹介したときに見たように、非NULLフィールド、つまり実行時にNULLを返せないフィールドは、その型の後にbang（！）記号を使用して定義します。
デフォルトでは、すべてのフィールドはnull可能です：

```gql
type Product {
  # This field is non-null name: String!
  # Price returns null when the product is free (default)
  price: Money

  # The tags field itself can be null.
  # If it does return a list, then every
  # item within this list is non-null.
  tags: [Tag!]
}
```

スキーマで非 null としてマークされているにもかかわらず、フィールドがクエリ時に null を返すと、GraphQL サーバーはエラーになります。
フィールドがNULLであることはありえないため、GraphQLはNULL可能なものが見つかるまでフィールドの親を遡っていきます。
フィールドがすべてnull不可だった場合、クエリー全体がnullを返し、エラーになります。
例えば、以下のクエリで、topProductフィールドがnullでないとマークされ、shopフィールドがnull可能であるとマークされたとします。

```gql
query {
  shop(id: 1) {
    name
    topProduct {
      name
      price
      tags
    }
  }
}
```

ここで、nameフィールドがnullでないとマークしたにもかかわらず、nullを返すとします。
topProductもnullにはできないので、結果は次のようになります：

```json
{
  "data": {
    "shop": null
  }
}
```


shopはnull可能であったため、たとえ1つのフィールド名だけがnullを返したとしても、GraphQLはshopタイプのレスポンス全体を爆撃しなければならなかった。
この例は null可用性は、その適用方法によっては、本当に強力なものにも、とんでもない間違いにもなり得るということを思い出させてくれる。

非Nullabilityは多くの理由で優れています：

- この章の前半で説明したように、より表現力豊かで予測可能なスキーマを構築するのに役立ちます。
- クライアントが過度に防御的なコードや条件を避けることができる。
しかし、これにはいくつかの危険性があります：
- NULLでないフィールドや引数は進化しにくい。nullでないフィールドと引数は進化しにくい。nullでないものからnullにすることは、破壊的な変化だが、その逆はそうではない。
- 特に分散環境では、何がNULLになるかどうかを予測するのは非常に難しい。あなたのアーキテクチャは進化し、タイムアウトや一時的なエラー、レート制限など、あらゆるものが特定のフィールドに対してnullを返す可能性があります。

そこで、スキーマを設計する際にヌーラビリティのために私が使っているガイドラインをいくつか紹介しよう：

- 引数については、より事前に指示可能で理解しやすいAPIを可能にするため、ほとんどの場合nullでない方がよい。(引数を追加する場合、既存のクライアントを壊さないためにはnullableが最適です)
- データベースの関連付けやネットワーク呼び出しなど、いつか失敗する可能性のあるものに支えられているオブジェクト・タイプを返すフィールドは、ほとんどの場合null可能であるべきだ。
- 実行時にすでに親オブジェクトにロードされていることが分かっているオブジェクトの単純なスカラーは、一般的にnull以外にしても安全です。
- まれです： まれに：NULLになることはないだろうという確信があり、親レベルで部分的な応答が可能なオブジェクト型。(特に、その型が他のコンテキストで再利用されることになる場合は、予測が困難です）。

これらのガイドラインに従うことで、スキーマ・メンバをnon-nullableにするかnullableにするかの正しい判断ができるようになります。
いつものように、これは実装に大きく依存するので、疑問がある場合は、NULL可否を決定する前に、基礎となるシステムを理解していることを確認してください！

### Abstract Types

抽象型はGraphQLスキーマを設計するときに非常に便利です。
スキーマを設計するときに大いに役立ち、インターフェイスを基礎となる永続化レイヤーから切り離すのに本当に役立ちます。
たとえば、データベースモデルから生成されたこの型を見てみましょう：

```gql
type SocialMediaFeedCard {
  id: ID!
  title: String!
  birthdayDate: DateTime
  eventDate: DateTime
  postContent: String
}
```

このタイプが表現しようとしているのは、ソーシャルメディアへの投稿である。
問題は、この投稿が誕生日だったり、イベントだったり、単なるテキスト投稿だったりすることだ。
おわかりのように、これを設計した方法のせいで、スキーマをフルに活用しておらず、違法な状態になる可能性があります。
バースデーカードはコンテンツを持つべきでなく、単にbirthdayDateを持つべきである。
イベントもbirthdayDateを含むべきではありませんが、スキーマはこれが可能であることを示唆しています。

その代わりに、抽象型（この場合はInterface型）を使ってこの概念を設計することができる：

```gql
interface SocialMediaFeedCard {
  id: ID!
  title: String!
}
type BirthdayFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  date: DateTime!
}
type EventFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  date: DateTime!
}
type ContentFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  content: String!
}
```

スキーマはクライアントにとって即座に明確になり、私たちに来る可能性のあるカード・タイプを簡単に見ることができます。
また、null可能なフィールドも必要なくなりました。以前のような不正な状態を許さない。これが抽象型の力だ。

#### Union or Interface?

GraphQLには2種類の抽象型がある： ユニオン型とインターフェース型です。
いつどちらを使うべきでしょうか？経験則から言うと、インターフェースは振る舞いを共有するものに対して共通の契約を提供するものであるべきです。
例えばGitHubには、"スターをつける "ことができるオブジェクトのためのStarrableインターフェイスがあります：
リポジトリ、ギスト、トピックなどです。
ユニオンは、あるフィールドが異なる型を返す可能性があるが、それらの型が必ずしも共通の振る舞いを持つとは限らない場合に使用します。
この一般的な例は、さまざまな可能性のあるオブジェクト・タイプを含むことができますが、必ずしも共通の動作を共有するわけではないリスト・タイプを返す検索フィールドの場合です。

#### Don’t Overuse Interfaces

インターフェイスはスキーマの中でより強力なコントラクトを作成するためには素晴らしいものですが、共通のフィールドを共有するためだけに使われる場合など、時に過剰に利用されることがあります。
複数の型がいくつかのフィールドを共有しているが、これらの型が共通の振る舞いを共有していない場合、単にインターフェイスを混在させる誘惑を避けるようにしよう。
優れたインターフェースは、APIコンシューマーにとって意味のあるものでなければならない。
インターフェイスは、何かになったり何かを持ったりするのではなく、何かのように何かをしたり振る舞ったりするための共通の方法を記述し提供するものだ。

では、インターフェースがオブジェクトを "分類 "し、似たような属性をグループ化することに重点を置きすぎていて、相互作用や振る舞いに十分な重点を置いていないかどうか、どうすればわかるのだろうか？スキーマの "匂い "を嗅ぐのに便利なのは、ネーミングだ。スキーマの中で強い意味を持たないインターフェイスを使う場合、ネーミングはたいていぎこちなく、意味のないものになります。
例えば、ItemInterfaceはeコマースドメインのアイテムと共通のフィールドを共有することになります。カートのアイテム、チェックアウトのアイテム、オーダーのアイテムがバラバラになり始めると、このインターフェースは維持するのが面倒になるかもしれません。
もし、私たちがいろいろな種類のアイテムを見て、それらが私たちのドメイン内で非常に異なる相互作用や振る舞いをすると判断したなら、もしかしたら別の抽象化を選んだかもしれません。
ItemFieldsやItemInfoといった他の名前も同じように使われているのを見たことがある。
私が間違った理由でインターフェースが使用されているのを目にする最も一般的な方法は、使用されているGraphQL実装がコードの再利用のためにインターフェースを簡単に使用できるようにしている場合です。
コードの再利用を可能にするためにGraphQLスキーマを使用するのではなく、フィールドの再利用を容易にするためにプログラミング言語で持っているツールを使用してください。
たとえば、ヘルパー関数、コンポジション、または継承を使用します。

### Abstract Types and API Evolution

抽象型はしばしば、時間の経過とともにAPIを進化させやすいという印象を与える。
ある意味、これは正しい。あるフィールドがインターフェイス型を返し リスコフの置換原則に従うのであれば、インターフェースを実装した新しいオブジェクト型を追加しても、クライアント・アプリケーションの動作が変わることはないはずだ。

これはインターフェイスに言えることで、完全に分離した型を許すユニオンにはあまり当てはまりません。
ユニオンのメンバーやインターフェイスの実装を追加することは、厳密な意味での破壊的な変更ではありませんが（フィールド定義を削除するように、クライアントがすぐに壊れることはないかもしれません）、それでもほとんどの場合、非常にやっかいな変更であり、ほとんど破壊的とみなすことができます。
このため、しばしば「危険な変更」と呼ばれます。GraphQLクライアントは、すべてのユニオンの可能性やインターフェイス上のすべての具象型を選択することを強制されるわけではありません。
GraphQLクライアントは新しいケースに対して防御的にコーディングすべきであり、GraphQLサーバーは重要なクライアントロジックに影響を与える可能性のある型の追加に慎重になるべきです。

### Designing for Static Queries

クエリ言語であるGraphQLは、直接、明示的に使用することで輝きを放つことが多いということは、もうかなり確立されている。
しかし、SDKやクエリビルダーなど、これと似たようなツールを使用することは魅力的だ：

```gql
query.products(first: 10).fields(["name", "price"])
```

実行時に何がGraphQLサーバーに送信されるのか、まったく見えなくなります。
その代わりに、次のように直接定義されたGraphQLクエリーを取ります：

```gql
query {
  products(first: 10) {
    name
    price
  }
}   
```

非常に明示的であり、どのようなデータが求められているのか、実行時にクエリの形がどのようになるのかを誰もがすぐに知ることができる。
クエリビルダーの代わりにGraphQL言語が優れた選択肢であるだけでなく、クエリを静的なものに保つよう努力すべきである。
静的クエリとは、プログラムのいかなる変数、条件、状態に基づいても変化しないクエリのことです。
ソースコードを見れば、コードがデプロイされたときにサーバーが受け取るクエリであることがわかります。
これにより、動的なクエリよりも多くの利点が得られます：

- ソースコードを見るだけで、開発者はクライアントのデータ要件について実に良いアイデアを得ることができる。
- クエリに操作名を与えることができる。これにより、サーバー側のロギングとクエリ分析が大幅に簡素化されます。例えば、クエリ FetchProducts { products { name } です。}
- IDEのサポート、コード生成、リンティングなどです。
- これは、サーバー側でこれらのクエリを保存することを可能にします。これについては第5章で詳しく説明する。
- 最後に、私たちはGraphQLサーバーと対話するために標準的で指定された言語を使用します！

クエリーを動的に構築するコードです：

```gql
const productFields = products.map((id, index) => {
  return `product${index}: product(id: "${id}") { name }`;
})
const query = `
  query {
    ${productFields}.join('\n')
  }
`
```

このコードには商品IDのリストがあり、各IDに関連する商品オブジェクトを取得するためにGraphQLクエリを構築します。
実行時、このクエリは次のようになります：

```gql
query {
  product0: product(id: "abc") { name } 
  product1: product(id: "def") { name } 
  product2: product(id: "ghi") { name } 
  product3: product(id: "klm") { name }
}
```

ここでの問題は
- このコードには完全なGraphQLクエリが含まれていないため、コードが実行されたときに実際に何が送信されるかを確認するのは難しい。
- クエリー文字列は、実行時にそのリストにいくつの商品IDがあるかによって変化する。そのためにフィールドエイリアス（product0、product1など）を使用しています。

代わりにGraphQLのコンセプトを使えば、変数を使うことで、何があっても常に同じクエリを構築する必要性を回避できる：

```gql
query FetchProducts($ids: [ID!]!) {
  products(ids: $ids) {
    name
    price
  }
}
```

この方法では、実際のクエリ文字列自体は変更されませんが、クライアントは異なる変数のセットを提供するだけで、好きなだけ多くの製品をフェッチすることができます。
このため、少なくともほとんどのフィールドの複数バージョンを提供し、さらに必要に応じて単一のエンティティをフェッチする方法を提供することをお勧めする。
面白いことに、クライアントはGraphQLのリスト型引数に単一の値を提供することができます：

```gql
query {
  # This is valid!
  products(ids: "abc") {
    name
    price
  }
}
```

### Mutations

ミューテーションはおそらく、GraphQLを学んだり使ったりする人々が最も苦労する部分でしょう。
ミューテーションはクエリ側にあるような「単なる」フィールドであるにもかかわらず、クエリ側とはまったく異なるもののように思われがちだ。
しかしそれは理にかなっている。ミューテーションはエラーに対処しなければならないことが多く、副作用が終わった後に何を返すべきかが明確でないことがよくあり、クエリ側には必ずしもない奇妙なルールがあります。
ミューテーションに関する設計上の問題点をいくつか挙げてみましょう。

#### Input and Payload types

突然変異は単純なフィールドである。他のフィールドと同じように引数を取り、特定の型を返すことができる。
しかし、単純な型を返すのではなく、（もともとはRelayが生み出した）一般的な手法として、「ペイロード型」と呼ばれる、特定の変異の結果として使われることだけを目的とした型を返すことがある。

```gql
# An example payload type for a createCheckout mutation
type CreateProductPayload {
  product: Product
}
```

この例では、ペイロード・タイプは単純に、作成された商品という1つのフィールドを持っています。
この章の後のエラーのセクションで説明します。
なぜcreateProductミューテーションで単にProduct型を返さないのでしょうか？第一の理由は、これによって型を変更することなく変異を進化させることができるからです。
変異の結果には、変異されたもの以上のものを返す必要があることがよくあります。
ペイロード型を使用すると、変異の結果に関する他の情報、たとえば成功したフィールドを含めることができます：

```gql
# An example payload type for a createCheckout mutation
type CreateProductPayload {
  product: Product
  successful: Boolean!
}
```

これらのペイロード・タイプは、ほぼ常に一意でなければならない。
先ほど見たように、型を共有しようとすると、特に変異ペイロードの場合、後々問題を引き起こすことになる。
入力についても、同様の戦略が使える：

```gql
type Mutation {
  createProduct(input: CreateProductInput!):
    CreateProductPayload
}
input CreateProductInput {
  name: String!
  price: Money!
}
```

Relayの慣例では、変異ごとに1つの、必須かつ一意の入力タイプを使用する。その利点は、ペイロード・タイプについて説明したことと似ている：
- 入力はより進化しやすい。
- 変異はクライアントサイドで単一の変数を使用することができます。
特に多くの引数を持つようになると、少し使いやすくなる。

私は、突然変異において必須の入力引数を絶対に1つにすることに夢中になることはないが、自分のAPI内でも他のAPIとの間でも、一貫性を保つための良いパターンであることは間違いない。
しかし、必要であれば一握りの引数を使うことを恐れてはいけない。これらの入力とペイロードがどのように構造化できるかは、次のいくつかのセクションで見ていこう。

## Fine-Grained or Coarse-Grained

この章の前の「貧弱なGraphQL」のセクションで見たように、より粒度の細かい、アクションベースのGraphQL変異は多くの利点を提供します。それは素晴らしいことのように聞こえますが、暗い側面もあります。
GraphQLはほとんどの場合APIインターフェースとして使用され、これは通常ネットワーク上でやりとりすることを意味します。最適なインターフェースは通常、プログラミング言語のメソッドシグネチャのために設計されるようなものになりますが、ネットワークの性質上、パフォーマンス上の理由から、より粗いインターフェースを設計せざるを得ないことがよくあります。より細かい変異とより粗い変異の間のトレードオフは、多くの場合、クライアントからのユースケースが何であると考えるかに依存します（公開APIはそれをより難しくします）。

一般的に、粗い粒度の作成ミューテーションと、エンティティを更新するための細かい粒度のミューテーションを持つことは、経験則として良いことがわかりました。
クライアントが単一の変異で何かを作成したいが、作成されたエンティティの更新やアクションは、アイテムの追加や住所の更新など、より小さな変異で行われることがよくあります。
適切なバランスを見つけることは芸術です。このため、変異やフィールドを設計する際に、クライアントのユースケースについて考えることが非常に重要です。
全体として、これはクライアントが興味を持っている本当のユースケースとして何を特定したかによる。一つの機能で解決できることを、クライアントに5つの異なる変異やフィールドを使わせたくないのです。

本当に細かいフィールドや変異には多くの利点がありますが、コントロールフローのビジネスロジックの多くをクライアントに押し付けることになります。
例えば、一般的なユースケースは、商品を作成し、ラベルを追加し、価格を変更することです。
これがUI上で1つのアクションとして表現される場合、これらのアクションがすべて細かいアクションとして設計されていた場合、クライアントは一貫したエクスペリエンスを達成するために、部分的な失敗や再試行などを管理しなければなりません。
例えば、addLabelの変異が失敗したとします。クライアントは、商品の作成と価格の変更はうまくいったが、addLabelの変更を再試行する必要があることを認識する必要がある。
これが問題になったとき、私たちは実際のユースケースを発見し、より粗い粒度の変異がこの機能にとって意味を持ち始めたのかもしれない。
結局のところ、ネットワーク・コールにはパフォーマンス・コストがかかるため、我々が望むよりも少し粗い粒度のオペレーションが必要になることが多い。白か黒かのシナリオではないことは確かだ。

### Transactions


GraphQLの旅のどこかの時点で、トランザクションがないという話を聞いたり、少なくともGraphQLでトランザクションを行うにはどうしたらよいかと考えたりすることでしょう。
トランザクションとGraphQLとはどういう意味なのでしょうか？それはデータベースのことではないのでしょうか？以前のaddProductToCheckout変異があると想像してください。
クライアントが3つの商品を追加したいが、すべての変異を成功させたい、あるいはまったく成功させたくないとしたらどうだろう？

```gql
mutation {
  product1: addProductToCheckout(...) { id }
  product2: addProductToCheckout(...) { id }
  product3: addProductToCheckout(...) { id }
}
```

このようなクエリーの方法には、いくつかの問題があります。まず、この章の前半で取り上げた静的クエリとは正反対です。
クライアントは追加する商品の数を指定してクエリー文字列を生成する必要があり、クライアントにとっては実に使い勝手が悪い。
第2に、GraphQLはこれらの変異をすべて次々に実行するため、2回目の変異が失敗し、3回目の変異が成功する可能性があり、クライアント上で実に奇妙な状態になる可能性があります。

多くの人が、1つのトランザクションブロック内で複数の変異を実行できるGraphQL機能を求めてきた。
ほとんどの場合、このような複雑さは必要ありません。
それよりも、前のセクションで説明したように、トランザクション全体を1つのフィールドに含むような、より粒度の粗い変異を設計する方が、ほとんどの場合良いアイデアです。
この例では、複数のアイテムを追加するaddProductsToCheckout変異を追加するのと同じくらい簡単です。
これによって静的クエリの問題とトランザクションの問題が解決されます。


例えば、商品をチェックアウトに追加し、請求先住所を更新し、割引を適用するといったように、順番に実行する必要がある複数の変異がある場合、それを実際のユースケースとして含めることを恐れないでください。特に内部APIを扱っている場合は、より細かい変異を再利用しようとするのではなく、「トランザクション」を解決するための具体的なユースケースを自由に提供してください。

### Batch

トランザクションのような操作を行うもう1つの方法は、バッチ処理を使うことだ。
GraphQLでは、バッチ処理にはさまざまな意味がある。
複数のクエリドキュメントを一度にサーバーに送信するようなバッチ処理もありますが、1つのクエリ内でバッチ変異を設計することもできます。
これまで、より細かい粒度の変異と粗い粒度の変異、クエリを静的なものにする方法、そしてトランザクションをそのユースケースのための新しい変異フィールドとして設計する方法について話してきました。
この問題に取り組むもう一つの方法は、いくつかのオペレーションを入力とするミューテーションを構築することです：

```gql
type Mutation {
  updateCartItems(
    input: UpdateCartItemsInput
  ): UpdateCartItemsPayload
}
input UpdateCartItemsInput {
  cartID: ID!
  operations: [UpdateCartItemOperationInput!]!
}
input UpdateCartItemOperationInput {
  operation: UpdateCardItemOperation!
  ids: [ID!]!
}
enum UpdateCartItemOperation {
  ADD
  REMOVE
}
```

この例では、updateCartItems 変異は UpdateCartItemOperation 入力のリストを受け取ります。
各入力は、operation フィールドを通してどのような操作を表すかを記述します。
クライアントはこの変異を使用して、1 回の変異で任意の数のアイテムを追加および削除できます：

```gql
mutation {
  updateCartItems(input: {
    cardID: "abc123",
    operations: [
      { operation: ADD, ids: ["abc", "def"] },
      { operation: REMOVE, ids: ["bar", "foo"] }
    ]
  }) {
    cart {
      items {
        name
      }
    }
  }
}
```

ADDとREMOVEが両方ともidsの引数を取ったのは幸運だった。
場合によっては、異なるオペレーションが異なる入力を持つこともある。
これを設計するための最良のアイデアは、入力ユニオンを使うことだろう。
しかし、この本を書いている時点では、まだ仕様に採用されていない。
それまでの間は、すべてのフィールドをオプショナルとして提供し、代わりにリゾルバ/ランタイムレベルでこれを処理するのが適切な解決策である：

```gql
input UpdateCartItemOperationInput {
  operation: UpdateCartItemOperation!
  addInput: CartItemOperationAddInput
  removeInput: CartItemOperationRemoveInput
  updateInput: CartItemOperationUpdateInput
}
```


これは冗長で、スキーマはすべてがnull可能なので表現力は乏しいが、機能する。
これは、入力ユニオンを仕様化するまでの間、バッチ変異が本当に必要な場合に便利である。
標準ではありませんが、例えばディレクティブを使って、この入力タイプはあるフィールドしか受け付けないということを示すこともできます：

```gql
input UpdateCartItemOperationInput @oneField {
  operation: UpdateCartItemOperation!
  addInput: CartItemOperationAddInput
  removeInput: CartItemOperationRemoveInput
  updateInput: CartItemOperationUpdateInput
}
```

### Errors


エラーは私たちの多くが悩むテーマだ。
その理由の一つは、やり方が一つではないからであり、どのようにエラーを処理するかは、あなたのAPIが使用されることを意図しているコンテキストに依存するからである。
このセクションを読み進めながら、できる限りこの文脈を捉えるようにしよう。まず、GraphQL仕様がエラーについて述べていること、そしてエラーがどのように見えるかについて説明します。
基本的なGraphQLエラーは次のようになります：

{
  "message": "Could not connect to product service.",
  "locations": [ { "line": 6, "column": 7 } ],
  "path": [ "viewer", "products", 1, "name" ]
}

エラーを説明するメッセージ、クエリ文字列ドキュメントのどこでエラーが発生したかを示すロケーション、クエリのルートからエラーの発生したフィールドにつながる文字列の配列であるパスがあります。
この場合、productsフィールドのインデックス1のproductのフィールド名でした。
エラーはより多くの情報で拡張することができます。
仕様の進化に伴う名前の衝突を避けるために、extensionsキーを使用する必要があります：

```json
{
  "message": "Could not connect to product service.",
  "locations": [ { "line": 6, "column": 7 } ],
  "path": [ "viewer", "products", 1, "name" ],
  "extensions": {
    "code": "SERVICE_CONNECT_ERROR"
  }
}
```

ここでは、クライアントアプリケーションが、人間が読めるメッセージ文字列ではなく、安定した識別子に依存してエラーを処理できるように、エラーにコードを追加しました（一般的には良いアイデアです）。
クエリー結果がレスポンスの data キーの下にあるのに対し、エラーは errors キーの下で GraphQL レスポンスに追加されます：

```json
{
  "errors": [
      {
        "message": "Error when computing price.",
        "locations": [ { "line": 6, "column": 7 } ],
        "path": [ "shop", "products", 1, "price" ],
        "extensions": {
          "code": "SERVICE_CONNECT_ERROR"
        }
  } ],
    "data": {
      "shop": {
        "name": "Cool Shop",
        "products": [
          {
            "id": "1000",
            "price": 100
  }, {
            "id": "1001",
            "price": null
          },
          {
            "id": "1002",
            "price": 100
  }
  ]
  } }
}
```
上の例では、インデックス1の商品のpriceフィールドがnullを返していることに注意してください。
仕様では、エラーが発生したフィールドはnullになり、関連するエラーがerrorsキーに追加されることになっています。
この動作は、APIでこれらのエラーをどのように使用するかにいくつかの影響を与えます。例えば、変異です：

```gql
mutation {
  createProduct(name: "Computer", price: 2000) {
    product {
      name
      price
    }
  }
}
```

例えば、重複した商品が追加された場合のエラーが欲しいとします。
変異フィールドにエラーを追加すると、完全な変異のレスポンスがnullとして返されます：

```json
{
"errors": [
    {
      "message": "Name for product already exists",
      "locations": [ { "line": 2, "column": 2 } ],
      "path": [ "createProduct" ],
      "extensions": {
        "code": "PRODUCT_NAME_TAKEN"
      }
} ],
  "data": {
    "createProduct": null
} }
```

これらのエラーにはいくつかの欠点があり、このような場合には使いにくい：


- 以前に見た変異のPayloadタイプは、変異に関するメタデータをエンコードするのに適していました。この場合、フィールドはnullを返さなければならないので、たとえエラーがあったとしても、この変異のデータをクライアントに送り返す可能性を失ってしまいます。
- エラーの情報は限られているので、サーバーは通常、拡張キーの中に追加のキーを追加する必要があります。エラー自体に追加すると、追加したフィールドと仕様が衝突する危険性がある。
- エラーのペイロードはGraphQLスキーマの外側にあるため、クライアントはGraphQL型システムの利点を得られません。つまり、私たちのエラーは消費しにくいが、進化しにくいということだ。
- ほとんどのフィールドが非NULLの場合、エラーがクエリに壊滅的な影響を及ぼす可能性があるためです。

GraphQLエラーはもともと例外的なイベントやクライアントに関連する問題を表すために設計されたものであり、必ずしもエンドユーザーに中継される必要のある期待される製品やビジネスのエラーを表すものではないことを理解すれば、これはすべて理にかなっています。エラーを2つの非常に大きなカテゴリーに分けることは、何がどこに行くのかを理解するのに役立ちます：

- 開発者/クライアントのエラー： クエリー中に何か問題が発生した（タイムアウト、レート制限、間違ったIDフォーマットなど）。これらは多くの場合、クライアントアプリケーションの開発者が対処する必要があるエラーです。
- ユーザーエラー： ユーザー/クライアントが何か間違ったことをした（チェックアウトの支払いを2回行おうとした、Eメールがすでに使われている、など）これらはAPIが提供する機能の一部です。


先ほど説明したGraphQLの "errors "キーは、開発者/クライアントのエラーを捕捉するのに最適な場所です。
これは開発者によって読み取られ、GraphQLクライアントによって処理されます。
ビジネス/ドメインルールの一部であるユーザー向けのエラーについては、例外/クエリレベルのエラーとして扱うのではなく、スキーマの一部として設計することが現在のベストプラクティスです。
これを実現する方法をいくつか見てみましょう。

### Errors as data

エラーをデータとして設計する最も簡単な方法は、ペイロード・タイプに起こりうるエラーを記述するフィールドを追加することだ：

```gql
type SignUpPayload {
  emailWasTaken: Boolean!
  # nil if the Account could not be created 
  account: Account
}
```

そしてクライアントはこの情報を好きなように利用することができる。
このようなエラー処理の方法は、純粋に内部的なユースケースでは機能するが、汎用的にエラーを処理したり、突然変異間で一貫性を持たせたりするのは難しくなる。
より良い方法は、ペイロード・タイプにuserErrorsフィールドのようなものを含めることです：

```gql
type SignUpPayload {
  userErrors: [UserError!]!
  account: Account
}
type UserError {
  # The error message message: String!
  # Indicates which field cause the error, if any
  #
  # Field is an array that acts as a path to the error #
  # Example:
  #
  # ["accounts", "1", "email"]
  #
  field: [String!]

  # An optional error code for clients to match on.
  code: UserErrorCode
}
```

ステータスコードのようなエラーメカニズムと比較して、データとしてのエラーが少し厄介なのは、クライアントがuserErrorsフィールドに問い合わせる必要がないことである。
つまり、クライアントによってはNULLのアカウントが返ってくるかもしれないが、なぜそうなるのかわからないということだ。解決策の一つは、APIのベストプラクティスについてクライアントを教育することですが、特にそのフィールドを含めなければ、クライアントがエラーに気づく保証はありません。
クライアントは "errors "GraphQLレスポンスのエラーを無視することもできますが、少なくともそれらはGraphQL仕様によって記述されているため、多くのクライアントはすでにそのようなタイプのエラー検出メカニズムを持っていることになります。

#### Union / Result Types

人気を集めているもう1つのアプローチも「データとしてのエラー」アプローチだが、エラー用の特定のフィールドを使用する代わりに、このアプローチではユニオン・タイプを使用して、クライアントに対して起こりうる問題のある状態を表現する。
同じ "サインアップ "の例で、結果ユニオンを使って設計してみましょう：

```gql
type Mutation {
  signUp(email: string!, password: String!): SignUpPayload
}
union SignUpPayload =
  SignUpSuccess |
  UserNameTaken |
  PasswordTooWeak
mutation {
  signUp(
    email: "marc@productionreadygraphql.com",
password: "P@ssword" ){
    ... on SignUpSuccess {
      account {
id
} }
    ... on UserNameTaken {
      message
      suggestedUsername
}
    ... on PasswordTooWeak {
      message
      passwordRules
} }
}
```
ご覧のように、このアプローチにはいくつかの利点があります。ここでのユニオン型は、変異の実行中に起こりうることを非常によく記述しており、各ケースはGraphQL型システムを使って強く型付けされています。
これにより、ユーザー名が取られていた場合のsuggestedUserNameや、提供されたパスワードが弱すぎた場合のパスワードルールのリストのように、各エラーシナリオにカスタムフィールドを追加することができます。
これは、私たちが見た両方のアプローチが伝えようとしていることを例証しています：いくつかのAPIエラーは、他のフィールドや型と同じようにユースケースとして公開されることを意図しており、クライアントも同じようにそれらを利用できるべきです。

#### So, which error style should you pick?

正直なところ、"ユーザーエラー "がスキーマできちんと定義されている限り、どのように実装すべきかについて強い意見はありません。ペイロード・タイプにあるemailIsTakenのような単純なフィールドでも、クライアントの数が少なかったり、使い始めたりする場合には使用できます。ユニオンを使用することは、間違いなくエラーを定義するための非常に表現力豊かな方法です。1つ注意しなければならないのは、クライアントの新しいタイプのエラーに対して、クライアントは防御的なコーディングをしなければならないということです。例えば

```gql
mutation {
  createProduct {
    ... on Success {
      product {
        name
      }
    }
    ... on ProductNameTaken {
      message
    }
    # What if ProductPriceTooHigh gets added?
  }
}
```

ProductPriceTooHighのような新しい型をクライアントが扱えるようにしなければなりません。スキーマがバージョン管理され、クライアント・アプリケーションがスキーマに対してコンパイルされ、大文字小文字のチェックが網羅的に行われるような世界では、これは完璧でしょう！しかし、私たちのほとんどは、特にウェブAPIの世界ではこのようなチャンスはない。このような理由から、論理和型のテクニックは素晴らしく、理論的には（網羅的な大文字小文字のチェックが可能なコンパイル済み言語では）完璧なのですが、GraphQLで使用する場合には不十分である可能性があるのです。
この時点で、このようなケースでuserErrorsリストに考えられる利点は、クライアントがすでに選択した同じフィールド内のすべての新しいエラーを取得できることです。これは、たとえ完璧にエラーを処理できなくても、必要であればエラーを表示し、デバッグしやすいようにエラーメッセージを記録できることを意味します。これは、クライアントのエラー処理に対して、もう少し一般的なアプローチを奨励するかもしれない。
クライアントが新しいエラー・シナリオを処理するのを助けるために使えるひとつのアプローチは、エラー・コントラクトを定義するインターフェース・タイプを使うことである：

```gql
interface UserError {
  message: String!
  code: ErrorCode!
  path: [String!]!
}
type DuplicateProductError implements UserError {
  message: String!
  code: ErrorCode!
  path: [String!]!
  duplicateProduct: Product!
}
```

こうすることで、クライアントはエラー時にメッセージ、コード、パスを常に選択することができ、エラー固有のフィールドも選択できるようになる：

```gql
mutation {
  createProduct(name: "Book", price: 1000) {
    product {
      name
      price
    }
    userErrors {
      message
      code
      path
      ... on DuplicateProductError {
        duplicateProduct
      }
    }
  }
}
```
同じテクニックがユニオンにも適用でき、可能性のあるすべての具象型をカバーするのではなく、インターフェイスの型にマッチさせることができるので、ユーザーの助けになる：

```gql
mutation {
  createProduct(name: "Book", price: 1000) {
    ... on CreateProductSuccess {
      product {
        name
        price
      }
    }
    ... on DuplicateProductError {
      duplicateProduct
    }
    ... on UserError {
      message
      code
      path
    }
  }
}
```
全体として、ユニオン・アプローチもuserErrorsアプローチも効果的です。
これらのアプローチに共通するのは、エラーをスキーマのデータとして扱うということです。しかし、userErrorsアプローチの方が、実行時にプログラムで入力しやすいことがよくあります。
既存の複雑なアプリケーションでは、検証ルールを明示的に定義するのが難しく、より汎用的なエラー処理が必要になることがあります：

```
  user_errors = errors_from_model(product)
```


もう一方では、型を定義し、スキーマを使ってシナリオを明確に定義することができる。ただ、スキーマの進化を重要視するのであれば、ユーザーは新しいケースを処理する方法でクエリを作成する必要があることに留意してください。この章の前半で見たように、ユニオン・アプローチは不可能な状態の設計を避けることもできます。userErrorsアプローチでは、エラーが発生したときにどのフィールドがnullになるかが不明確な場合があります。
このような場合、クライアントに、ユニオンのケースでエラー・タイプとマッチさせるか、ペイロード・タイプでuserErrorsフィールドを選択させるか、どちらかを強制するものはありません。これはまだGraphQLコミュニティで解決されていない問題であり、現在のところ、変異を実行するときにどのフィールド/タイプに注意する必要があるのか、またエラーを返す可能性のあるフィールドをユーザーが理解できるようにするためのドキュメントが必要です。GraphQLエラーでは、少なくともクライアントによってエラーが正しく処理される可能性が高いことがわかります。

### Schema Organization

GraphQLスキーマは、クライアントが要件を選択しなければならない可能性の大きなグラフです。
このため、ユースケースを見つけやすくするような方法でスキーマを整理したり、少なくとも似たような概念をグループ化したりすることについて尋ねたくなる人もいます。

#### Namespaces


多くの人がGraphQLスキーマの名前空間メカニズムを求めてきた。これまでのところ、どの提案も仕様にあまり進んでいません。
この章の前の命名で取り上げたアドバイスに従えば、これが大きな問題になることはほとんどないと思います。
十分に具体的な命名をしていれば、名前空間が絶対に必要な状況はまれでしょう。
しかし、非常に明確な方法で名前空間をつけなければならない場合は、例えばプレフィックスのような命名戦略を使うことをお勧めします：

```gql
type Instagram_User { # ...
}
type Facebook_User { # ...
}
```

私が見聞きしたところでは、名前空間に関する要望のほとんどは、第8章で取り上げるスキーマステッチのような戦略を使う開発者から来るものだ。
スキーマのステッチングは、異なるスキーマをマージすることを可能にし、名前の衝突の扉を開く。繰り返しますが、これは適切な命名によって解決できることが多く、特定のGraphQL機能の代わりにビルド時のツールによって支援することができます。
結果として得られるGraphQLスキーマと、そのスキーマをサーバーサイドで構築する方法は、まったく別の問題であることを覚えておいてください。
名前空間、モジュール、および再利用可能な関数をサーバー側で使用することで、コードの整理を助けることができます。

#### Mutations

突然変異の命名に悩むチームもある。変異の名前をcreateProductにするかproductCreateにするか。
たとえば、私がShopifyにいたころ、チームはproductCreateのルートにすることに決めました。
関連する変異はSDL/introspection/GraphQLでグループ化されるので、よりよい発見ができるようにするためです。
それは理にかなっていますが、私にとっては、整理のためだけに読みにくい名前にするのはいつも悲しいことだと感じていました。

cartProductAddのような名前ではなく、addProductsToCartのような具体的で読みやすい名前を使うことを恐れないでください。ツールは を発見しやすくすることができます。私が遊んでいるアイデアのひとつは、ドキュメントや他のツールのグループ化を助けるためにtagsディレクティブを使うことです：

```gql
type Mutation {
  createProduct(...):
    CreateProductPayload @tags(names: ["product"])
  createShop(...):
    CreateShopPayload @tags(names: ["shop"])
  addImageToProduct(...):
    AddImageToProductPayload @tags(names: ["product"])
}
```

別のアイデアとしては、親フィールドや「名前空間」を使って、shop { create(...) { id }のように、親フィールドの下に似たようなフィールドをグループ化する方法がある。
しかし、仕様とツールはそのような使い方を100％明確にしているわけではないので、今のところそのような使い方をすることはお勧めしません。
変異ルート上のトップレベル・フィールドは、副作用が期待される唯一のフィールドです。つまり、以下のようにグループ化された変異では、以下のようになります：

```gql
mutation {
  products {
    deleteProduct(id: "abc") {
      product
    }
  }
}
```

deleteProductは、理論的には読み取り専用フィールドと考えるべきです。個人的には、使用しているサーバーの実装では技術的にうまくいくかもしれませんが、このルートはお勧めしません。

### Asynchronous Behavior

APIが同期的でないことがある。何かがバックグラウンドで処理される必要があるため、すぐに結果を返すことができないのです。
RESTやHTTPベースのAPIでは、これを処理する最も一般的な方法は202 Acceptedステータスコードです。
しかし、GraphQLでこれを使用するのは厄介です。リクエストの一部だけが非同期で、残りはすぐに返せるかもしれないからです。
これをモデル化するにはいくつかのアプローチがあります。
たとえば、支払い処理を扱っている場合、保留中の支払いをユニオン型の中の型として設計することができます：

```gql
type Query {
  payment(id: ID!): Payment
}
union Payment = PendingPayment | CompletedPayment
```

ユニオンの代わりに単一型を選ぶこともできる：

```gql
type Operation {
  status: OperationStatus
  result: OperationResult
}
enum OperationStatus {
  PENDING
  CANCELED
  FAILED
  COMPLETED
}
```
別の解決策は、ジョブタイプとコンセプトを使って、これらのケースをより一般的に扱うことです。これはShopifyが管理画面のGraphQL APIで採用したものです。このアイデアはとても賢いものです。ジョブはグローバルIDで識別可能で、他に2つのフィールドがあります：
- 非同期ジョブが完了したか、まだ保留中かを示すdone boolean型。
- 楽しい部分： Queryルート・タイプを返すqueryフィールド。これは、ジョブが完了した後の新しい状態をクライアントが問い合わせるのに役立ちます。

### Data-Driven Schema vs Use-Case-Driven Schema


これまで私たちは、実際のユースケースを表現する、よく練られたGraphQLスキーマの設計について多くのことを話してきた。
迷ったときは、データのためではなくビヘイビアのためにGraphQLスキーマを設計するのが私の常套手段でした。
これは通常、APIを消費する際の素晴らしいエクスペリエンスにつながりますが、APIには他にも明確な用途があります。
GitHub GraphQL APIは、ビジネス／ドメインのユースケースを念頭に置いて設計されたスキーマの良い例だ。
このスキーマは、GitHub のドメインとやりとりするアプリケーションや、一般的なユースケースを利用するアプリケーションに適しています。
「課題のオープン」「コメント」「プルリクエストのマージ」「ブランチの一覧表示」「プルリクエストのページ付け」などです。

しかし、ある種の顧客は、GraphQLの構文と機能を見て、ビジネスから必要なデータを正確に取得できる大きな可能性を見出す。結局のところ 私たちがよく耳にする「1つのGraphQLクエリで必要なものを正確に取得する」ということは、そのように解釈されるかもしれません。例えば、5分ごとにすべての問題のすべてのコメントを同期する必要があるコメント分析アプリケーションを考えてみよう。必要なデータのクエリを作成し、1つのクエリを送信し、そして利益を得る。しかし、すぐにある問題にぶつかります：

- ほとんどのAPIは、データを大量に消費するためではなく、例えば人間に結果を表示するために作られているため、リソースをページ分割する。探しているものが純粋なデータである場合、ページ分割されたフィールドはそれをより難しくする。
- タイムアウト： ほとんどのGraphQL APIプロバイダーは、巨大なGraphQLクエリが長時間実行されることを望んでおらず、タイムアウトやレート制限を積極的に使用してそのようなことが起こらないようにします（これについては第4章で詳しく説明します）。しかし、純粋にデータ駆動型のクライアントは、目的を達成するためにかなり大規模なクエリを実行する必要があるかもしれません。有効なユースケースであり、過剰な使用シナリオではないとしても、何千ものレコードをクエリすると、クエリがブロックされる可能性がかなり高い。


かなり扱いにくいですよね？一方では、純粋にデータドリブンなユースケースを持つクライアントには正当な理由があるかもしれませんが、もう一方では、あなたのGraphQL APIはこの目的のために設計されていないかもしれません（そうであるべきでもありません）。実際、これは必ずしもGraphQLの問題ではありません。現在出回っているほとんどのAPIは、ユースケース主導のクライアントを構築することを主な目的としており、大量のデータ（大規模なGraphQLリクエスト、バッチHTTPリクエスト、または大量のHTTPリクエスト）を同期したい場合に対処するのは難しいでしょう。
ユースケースが実際にデータに関するものである場合、他の方法を考えなければならない。

#### Asynchronous GraphQL Jobs

その種の大きなリクエストのほとんどは計算に時間がかかり、リクエスト中に実行することはAPIプロバイダーにとって単純に実行不可能である。もう一つのアイデアは、APIプロバイダーが非同期に実行するクエリをスケジュールし、後で結果を取得することだ。現実的には、非同期クエリを登録するエンドポイントを用意することで実装できるだろう：

```
POST /async_graphql
{
  allTheThings {
    andEvenMore {
      things
      }
  }
}


202 ACCEPTED
Location: /async_graphql/HS3HlKN76EI5es7qSTHNmA
82
And then indicating to clients they need to poll for the result somewhere else:
GET /async_graphql/HS3HlKN76EI5es7qSTHNmA
202 ACCEPTED
Location: /async_graphql/HS3HlKN76EI5es7qSTHNmA
GET /async_graphql/HS3HlKN76EI5es7qSTHNmA
200 OK
{ "data": { ... } }
```

もう一つの例として、Shopifyは "Bulk Operations "と呼ばれる非同期GraphQLジョブの素晴らしい実践例を持っている。
これらの操作には同期GraphQL APIと同じスキーマを使用していますが、リソースを自動ページ分割することができ、レート制限を受けたり、クエリのタイムアウトに直面したりするリスクはありません。これは、より長く実行される、よりデータ指向のユースケースをサポートする素晴らしい方法だ。

### Summary

優れたAPIデザインはGraphQLにとどまらない。この章で見てきたベストプラクティスのほとんどは、HTTP APIやライブラリ設計、場合によってはUI設計などにも当てはまる。この章では多くの原則を見てきましたが、GraphQLスキーマを構築する際に覚えておくべき主なポイントは4つあると思います。
- 第一に、スキーマ開発にはデザインファーストのアプローチを使うこと。ドメインを最もよく知っているチームメイトと設計について議論し、実装の詳細は無視します。
- 第二に、クライアントのユースケースの観点から設計することです。データ、型、フィールドの観点から考えるな。
- 第三に、スキーマを可能な限り表現豊かにすること。スキーマは、クライアントを良い使い方に導くものでなければならない。ドキュメンテーションはケーキの上のアイシングであるべきだ。
- 最後に、非常に一般的で巧妙なスキーマの誘惑を避けること。クライアントのユースケースに明確に答える特定のフィールドと型を構築する。
これらの一般的なプラクティスに従えば、クライアントが気に入って使用し、時間の経過とともにうまく進化するスキーマへの道をすでに歩んでいることになる。
