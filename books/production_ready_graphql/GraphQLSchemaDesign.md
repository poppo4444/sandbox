### Global Identification
GraphQL APIで人気を博したもう1つのコンセプトは、オブジェクトのグローバル識別である。
これも元々はRelayから来たものですが、その後一般的に良いプラクティスとなっています。
この考え方は、GraphQLクライアントが一意の識別子を与えられたグラフ内の任意の「ノード」をフェッチできるようにすることです。
実際には、これはGraphQLサーバーがグローバルノード（id: ID!） Nodeフィールドを公開することで、クライアントはその単一のフィールドを通じて任意のノードをフェッチできるようになります。
nodeフィールドはNodeインターフェース・タイプを返します：

```gql
interface Node {
  id: ID!
}

type User implements Node {
  id: ID!
  name: String!
}
```

このNodeインターフェイスは、このオブジェクトがグローバルに一意なIDを持ち、node(id: ID!)フィールドとnodes(ids: [ID!]!)フィールドを使ってフェッチできることを示す手段である。
これらすべての目的は何でしょうか？その多くはクライアントサイドのキャッシュです。
GraphQLクライアントは、以前にフェッチしたノードを保存するために複雑な正規化キャッシュを構築することがよくあります。
Relayには単一ノードを再フェッチするメカニズムが必要であり、ノード規約を持つことで、クライアントはそれをあまり設定することなく行うことができます。
グローバル識別は絶対に必要ですか？必ずしも必要ではない。
RelayクライアントがAPIを使用することを想定しておらず、単一のグローバル識別子を使用してオブジェクトをフェッチする必要性がない場合は、実装する必要はありません。
たとえばApolloのようなクライアントは、型名と単純なIDを組み合わせてグローバル識別子を作成することができます。

とはいえ、特定の「ノード」や「オブジェクト」に対してグローバルに一意なIDを持つことは、非常に有用な原則となりうる。
実際、これらは例えばRESTリソースを識別するために使用される統一リソース識別子（URI）に似ている。REST URIのように、これらの識別子の重要な部分の1つは、ユーザがIDを構築したりハックしようとせず、APIから取得したIDを直接使用することです。
これを確実にする良い方法は、不透明な識別子を使うことだ：

```json
{
  "data": {
    "node": {
      "id": "RmFjdGlvbjoy"
    }
  }
}
```

IDを不透明にする最も一般的な方法は、Base64にすることだ。
ここでの目的は、IDがどのように作られているかを完全に隠すことではない（Base64であることをクライアントが知るのは簡単だ）。
その代わりに、この文字列が不透明であることをクライアントに思い出させるだけである。
不透明なIDは、クライアントがIDがどのように構築されるかに関連したロジックを構築していないことを期待しながら、根本的なID生成を変更することを可能にするので、素晴らしいものです。
しかし、時には、開発者にとって最高のエクスペリエンスにつながるとは限りません。
クライアント・アプリケーションを構築する際に、自分の手元にあるノードIDがどのようなものかを知るのは難しいかもしれない。
私が興味を抱いているアイデアは、不透明なIDで、まだ自分自身について少し知ることができます。
私が初めてこのようなものに出会ったのはSlack APIだったと思う。
オブジェクトのタイプに応じて異なる文字で始まる不透明なトークンがあった。グローバルIDには、開発者を助けるためにちょっとした情報を含めるのがいいのかもしれない。

これらのIDを作成する場合、このノードをグローバルにフェッチするのに役立つ情報をできるだけ多く含める必要があります。
最も基本的なケースでは、これは通常type_name:database_idですが、常にこれをデフォルトとすべきではありません。
特に分散アーキテクチャでは、ルーティング情報がないとノードをフェッチできないことがあります。
このノードへの "ルーティング "を容易にする情報があれば、必ず含めてください。
例えば、"products "は "shops "によって共有または配布されるかもしれません。
つまり、IDにはshop_id:type_name:idというショップIDが必要になるかもしれません。

要約すると

- 特にRelayをサポートするつもりがないのであれば、グローバルIDは必ずしも必要ではない。
- コネクションのように、Relayのコンテキスト以外でも有効なパターンです。
- 不透明なIDを推奨する。
- グローバルIDには、ノードにグローバルにルーティングするのに十分なコンテキストが含まれていることを確認してください、

特に分散アーキテクチャでは。

### Nullability

NullabilityはGraphQLの概念で、フィールドがクエリーされたときにNULLを返すかどうかを定義することができます。
GraphQLを紹介したときに見たように、非NULLフィールド、つまり実行時にNULLを返せないフィールドは、その型の後にbang（！）記号を使用して定義します。
デフォルトでは、すべてのフィールドはnull可能です：

```gql
type Product {
  # This field is non-null name: String!
  # Price returns null when the product is free (default)
  price: Money

  # The tags field itself can be null.
  # If it does return a list, then every
  # item within this list is non-null.
  tags: [Tag!]
}
```

スキーマで非 null としてマークされているにもかかわらず、フィールドがクエリ時に null を返すと、GraphQL サーバーはエラーになります。
フィールドがNULLであることはありえないため、GraphQLはNULL可能なものが見つかるまでフィールドの親を遡っていきます。
フィールドがすべてnull不可だった場合、クエリー全体がnullを返し、エラーになります。
例えば、以下のクエリで、topProductフィールドがnullでないとマークされ、shopフィールドがnull可能であるとマークされたとします。

```gql
query {
  shop(id: 1) {
    name
    topProduct {
      name
      price
      tags
    }
  }
}
```

ここで、nameフィールドがnullでないとマークしたにもかかわらず、nullを返すとします。
topProductもnullにはできないので、結果は次のようになります：

```json
{
  "data": {
    "shop": null
  }
}
```


shopはnull可能であったため、たとえ1つのフィールド名だけがnullを返したとしても、GraphQLはshopタイプのレスポンス全体を爆撃しなければならなかった。
この例は null可用性は、その適用方法によっては、本当に強力なものにも、とんでもない間違いにもなり得るということを思い出させてくれる。

非Nullabilityは多くの理由で優れています：

- この章の前半で説明したように、より表現力豊かで予測可能なスキーマを構築するのに役立ちます。
- クライアントが過度に防御的なコードや条件を避けることができる。
しかし、これにはいくつかの危険性があります：
- NULLでないフィールドや引数は進化しにくい。nullでないフィールドと引数は進化しにくい。nullでないものからnullにすることは、破壊的な変化だが、その逆はそうではない。
- 特に分散環境では、何がNULLになるかどうかを予測するのは非常に難しい。あなたのアーキテクチャは進化し、タイムアウトや一時的なエラー、レート制限など、あらゆるものが特定のフィールドに対してnullを返す可能性があります。

そこで、スキーマを設計する際にヌーラビリティのために私が使っているガイドラインをいくつか紹介しよう：

- 引数については、より事前に指示可能で理解しやすいAPIを可能にするため、ほとんどの場合nullでない方がよい。(引数を追加する場合、既存のクライアントを壊さないためにはnullableが最適です)
- データベースの関連付けやネットワーク呼び出しなど、いつか失敗する可能性のあるものに支えられているオブジェクト・タイプを返すフィールドは、ほとんどの場合null可能であるべきだ。
- 実行時にすでに親オブジェクトにロードされていることが分かっているオブジェクトの単純なスカラーは、一般的にnull以外にしても安全です。
- まれです： まれに：NULLになることはないだろうという確信があり、親レベルで部分的な応答が可能なオブジェクト型。(特に、その型が他のコンテキストで再利用されることになる場合は、予測が困難です）。

これらのガイドラインに従うことで、スキーマ・メンバをnon-nullableにするかnullableにするかの正しい判断ができるようになります。
いつものように、これは実装に大きく依存するので、疑問がある場合は、NULL可否を決定する前に、基礎となるシステムを理解していることを確認してください！

### Abstract Types

抽象型はGraphQLスキーマを設計するときに非常に便利です。
スキーマを設計するときに大いに役立ち、インターフェイスを基礎となる永続化レイヤーから切り離すのに本当に役立ちます。
たとえば、データベースモデルから生成されたこの型を見てみましょう：

```gql
type SocialMediaFeedCard {
  id: ID!
  title: String!
  birthdayDate: DateTime
  eventDate: DateTime
  postContent: String
}
```

このタイプが表現しようとしているのは、ソーシャルメディアへの投稿である。
問題は、この投稿が誕生日だったり、イベントだったり、単なるテキスト投稿だったりすることだ。
おわかりのように、これを設計した方法のせいで、スキーマをフルに活用しておらず、違法な状態になる可能性があります。
バースデーカードはコンテンツを持つべきでなく、単にbirthdayDateを持つべきである。
イベントもbirthdayDateを含むべきではありませんが、スキーマはこれが可能であることを示唆しています。

その代わりに、抽象型（この場合はInterface型）を使ってこの概念を設計することができる：

```gql
interface SocialMediaFeedCard {
  id: ID!
  title: String!
}
type BirthdayFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  date: DateTime!
}
type EventFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  date: DateTime!
}
type ContentFeedCard implements SocialMediaFeedCard {
  id: ID!
  title: String!
  content: String!
}
```

スキーマはクライアントにとって即座に明確になり、私たちに来る可能性のあるカード・タイプを簡単に見ることができます。
また、null可能なフィールドも必要なくなりました。以前のような不正な状態を許さない。これが抽象型の力だ。

#### Union or Interface?

GraphQLには2種類の抽象型がある： ユニオン型とインターフェース型です。
いつどちらを使うべきでしょうか？経験則から言うと、インターフェースは振る舞いを共有するものに対して共通の契約を提供するものであるべきです。
例えばGitHubには、"スターをつける "ことができるオブジェクトのためのStarrableインターフェイスがあります：
リポジトリ、ギスト、トピックなどです。
ユニオンは、あるフィールドが異なる型を返す可能性があるが、それらの型が必ずしも共通の振る舞いを持つとは限らない場合に使用します。
この一般的な例は、さまざまな可能性のあるオブジェクト・タイプを含むことができますが、必ずしも共通の動作を共有するわけではないリスト・タイプを返す検索フィールドの場合です。

#### Don’t Overuse Interfaces

インターフェイスはスキーマの中でより強力なコントラクトを作成するためには素晴らしいものですが、共通のフィールドを共有するためだけに使われる場合など、時に過剰に利用されることがあります。
複数の型がいくつかのフィールドを共有しているが、これらの型が共通の振る舞いを共有していない場合、単にインターフェイスを混在させる誘惑を避けるようにしよう。
優れたインターフェースは、APIコンシューマーにとって意味のあるものでなければならない。
インターフェイスは、何かになったり何かを持ったりするのではなく、何かのように何かをしたり振る舞ったりするための共通の方法を記述し提供するものだ。

では、インターフェースがオブジェクトを "分類 "し、似たような属性をグループ化することに重点を置きすぎていて、相互作用や振る舞いに十分な重点を置いていないかどうか、どうすればわかるのだろうか？スキーマの "匂い "を嗅ぐのに便利なのは、ネーミングだ。スキーマの中で強い意味を持たないインターフェイスを使う場合、ネーミングはたいていぎこちなく、意味のないものになります。
例えば、ItemInterfaceはeコマースドメインのアイテムと共通のフィールドを共有することになります。カートのアイテム、チェックアウトのアイテム、オーダーのアイテムがバラバラになり始めると、このインターフェースは維持するのが面倒になるかもしれません。
もし、私たちがいろいろな種類のアイテムを見て、それらが私たちのドメイン内で非常に異なる相互作用や振る舞いをすると判断したなら、もしかしたら別の抽象化を選んだかもしれません。
ItemFieldsやItemInfoといった他の名前も同じように使われているのを見たことがある。
私が間違った理由でインターフェースが使用されているのを目にする最も一般的な方法は、使用されているGraphQL実装がコードの再利用のためにインターフェースを簡単に使用できるようにしている場合です。
コードの再利用を可能にするためにGraphQLスキーマを使用するのではなく、フィールドの再利用を容易にするためにプログラミング言語で持っているツールを使用してください。
たとえば、ヘルパー関数、コンポジション、または継承を使用します。

### Abstract Types and API Evolution

抽象型はしばしば、時間の経過とともにAPIを進化させやすいという印象を与える。
ある意味、これは正しい。あるフィールドがインターフェイス型を返し リスコフの置換原則に従うのであれば、インターフェースを実装した新しいオブジェクト型を追加しても、クライアント・アプリケーションの動作が変わることはないはずだ。

これはインターフェイスに言えることで、完全に分離した型を許すユニオンにはあまり当てはまりません。
ユニオンのメンバーやインターフェイスの実装を追加することは、厳密な意味での破壊的な変更ではありませんが（フィールド定義を削除するように、クライアントがすぐに壊れることはないかもしれません）、それでもほとんどの場合、非常にやっかいな変更であり、ほとんど破壊的とみなすことができます。
このため、しばしば「危険な変更」と呼ばれます。GraphQLクライアントは、すべてのユニオンの可能性やインターフェイス上のすべての具象型を選択することを強制されるわけではありません。
GraphQLクライアントは新しいケースに対して防御的にコーディングすべきであり、GraphQLサーバーは重要なクライアントロジックに影響を与える可能性のある型の追加に慎重になるべきです。

### Designing for Static Queries

クエリ言語であるGraphQLは、直接、明示的に使用することで輝きを放つことが多いということは、もうかなり確立されている。
しかし、SDKやクエリビルダーなど、これと似たようなツールを使用することは魅力的だ：

```gql
query.products(first: 10).fields(["name", "price"])
```

実行時に何がGraphQLサーバーに送信されるのか、まったく見えなくなります。
その代わりに、次のように直接定義されたGraphQLクエリーを取ります：

```gql
query {
  products(first: 10) {
    name
    price
  }
}   
```

非常に明示的であり、どのようなデータが求められているのか、実行時にクエリの形がどのようになるのかを誰もがすぐに知ることができる。
クエリビルダーの代わりにGraphQL言語が優れた選択肢であるだけでなく、クエリを静的なものに保つよう努力すべきである。
静的クエリとは、プログラムのいかなる変数、条件、状態に基づいても変化しないクエリのことです。
ソースコードを見れば、コードがデプロイされたときにサーバーが受け取るクエリであることがわかります。
これにより、動的なクエリよりも多くの利点が得られます：

- ソースコードを見るだけで、開発者はクライアントのデータ要件について実に良いアイデアを得ることができる。
- クエリに操作名を与えることができる。これにより、サーバー側のロギングとクエリ分析が大幅に簡素化されます。例えば、クエリ FetchProducts { products { name } です。}
- IDEのサポート、コード生成、リンティングなどです。
- これは、サーバー側でこれらのクエリを保存することを可能にします。これについては第5章で詳しく説明する。
- 最後に、私たちはGraphQLサーバーと対話するために標準的で指定された言語を使用します！

クエリーを動的に構築するコードです：

```gql
const productFields = products.map((id, index) => {
  return `product${index}: product(id: "${id}") { name }`;
})
const query = `
  query {
    ${productFields}.join('\n')
  }
`
```

このコードには商品IDのリストがあり、各IDに関連する商品オブジェクトを取得するためにGraphQLクエリを構築します。
実行時、このクエリは次のようになります：

```gql
query {
  product0: product(id: "abc") { name } 
  product1: product(id: "def") { name } 
  product2: product(id: "ghi") { name } 
  product3: product(id: "klm") { name }
}
```

ここでの問題は
- このコードには完全なGraphQLクエリが含まれていないため、コードが実行されたときに実際に何が送信されるかを確認するのは難しい。
- クエリー文字列は、実行時にそのリストにいくつの商品IDがあるかによって変化する。そのためにフィールドエイリアス（product0、product1など）を使用しています。

代わりにGraphQLのコンセプトを使えば、変数を使うことで、何があっても常に同じクエリを構築する必要性を回避できる：

```gql
query FetchProducts($ids: [ID!]!) {
  products(ids: $ids) {
    name
    price
  }
}
```

この方法では、実際のクエリ文字列自体は変更されませんが、クライアントは異なる変数のセットを提供するだけで、好きなだけ多くの製品をフェッチすることができます。
このため、少なくともほとんどのフィールドの複数バージョンを提供し、さらに必要に応じて単一のエンティティをフェッチする方法を提供することをお勧めする。
面白いことに、クライアントはGraphQLのリスト型引数に単一の値を提供することができます：

```gql
query {
  # This is valid!
  products(ids: "abc") {
    name
    price
  }
}
```

### Mutations

ミューテーションはおそらく、GraphQLを学んだり使ったりする人々が最も苦労する部分でしょう。
ミューテーションはクエリ側にあるような「単なる」フィールドであるにもかかわらず、クエリ側とはまったく異なるもののように思われがちだ。
しかしそれは理にかなっている。ミューテーションはエラーに対処しなければならないことが多く、副作用が終わった後に何を返すべきかが明確でないことがよくあり、クエリ側には必ずしもない奇妙なルールがあります。
ミューテーションに関する設計上の問題点をいくつか挙げてみましょう。

#### Input and Payload types

突然変異は単純なフィールドである。他のフィールドと同じように引数を取り、特定の型を返すことができる。
しかし、単純な型を返すのではなく、（もともとはRelayが生み出した）一般的な手法として、「ペイロード型」と呼ばれる、特定の変異の結果として使われることだけを目的とした型を返すことがある。

```gql
# An example payload type for a createCheckout mutation
type CreateProductPayload {
  product: Product
}
```

この例では、ペイロード・タイプは単純に、作成された商品という1つのフィールドを持っています。
この章の後のエラーのセクションで説明します。
なぜcreateProductミューテーションで単にProduct型を返さないのでしょうか？第一の理由は、これによって型を変更することなく変異を進化させることができるからです。
変異の結果には、変異されたもの以上のものを返す必要があることがよくあります。
ペイロード型を使用すると、変異の結果に関する他の情報、たとえば成功したフィールドを含めることができます：

```gql
# An example payload type for a createCheckout mutation
type CreateProductPayload {
  product: Product
  successful: Boolean!
}
```

これらのペイロード・タイプは、ほぼ常に一意でなければならない。
先ほど見たように、型を共有しようとすると、特に変異ペイロードの場合、後々問題を引き起こすことになる。
入力についても、同様の戦略が使える：

```gql
type Mutation {
  createProduct(input: CreateProductInput!):
    CreateProductPayload
}
input CreateProductInput {
  name: String!
  price: Money!
}
```

Relayの慣例では、変異ごとに1つの、必須かつ一意の入力タイプを使用する。その利点は、ペイロード・タイプについて説明したことと似ている：
- 入力はより進化しやすい。
- 変異はクライアントサイドで単一の変数を使用することができます。
特に多くの引数を持つようになると、少し使いやすくなる。

私は、突然変異において必須の入力引数を絶対に1つにすることに夢中になることはないが、自分のAPI内でも他のAPIとの間でも、一貫性を保つための良いパターンであることは間違いない。
しかし、必要であれば一握りの引数を使うことを恐れてはいけない。これらの入力とペイロードがどのように構造化できるかは、次のいくつかのセクションで見ていこう。

## Fine-Grained or Coarse-Grained

この章の前の「貧弱なGraphQL」のセクションで見たように、より粒度の細かい、アクションベースのGraphQL変異は多くの利点を提供します。それは素晴らしいことのように聞こえますが、暗い側面もあります。
GraphQLはほとんどの場合APIインターフェースとして使用され、これは通常ネットワーク上でやりとりすることを意味します。最適なインターフェースは通常、プログラミング言語のメソッドシグネチャのために設計されるようなものになりますが、ネットワークの性質上、パフォーマンス上の理由から、より粗いインターフェースを設計せざるを得ないことがよくあります。より細かい変異とより粗い変異の間のトレードオフは、多くの場合、クライアントからのユースケースが何であると考えるかに依存します（公開APIはそれをより難しくします）。

一般的に、粗い粒度の作成ミューテーションと、エンティティを更新するための細かい粒度のミューテーションを持つことは、経験則として良いことがわかりました。
クライアントが単一の変異で何かを作成したいが、作成されたエンティティの更新やアクションは、アイテムの追加や住所の更新など、より小さな変異で行われることがよくあります。
適切なバランスを見つけることは芸術です。このため、変異やフィールドを設計する際に、クライアントのユースケースについて考えることが非常に重要です。
全体として、これはクライアントが興味を持っている本当のユースケースとして何を特定したかによる。一つの機能で解決できることを、クライアントに5つの異なる変異やフィールドを使わせたくないのです。

本当に細かいフィールドや変異には多くの利点がありますが、コントロールフローのビジネスロジックの多くをクライアントに押し付けることになります。
例えば、一般的なユースケースは、商品を作成し、ラベルを追加し、価格を変更することです。
これがUI上で1つのアクションとして表現される場合、これらのアクションがすべて細かいアクションとして設計されていた場合、クライアントは一貫したエクスペリエンスを達成するために、部分的な失敗や再試行などを管理しなければなりません。
例えば、addLabelの変異が失敗したとします。クライアントは、商品の作成と価格の変更はうまくいったが、addLabelの変更を再試行する必要があることを認識する必要がある。
これが問題になったとき、私たちは実際のユースケースを発見し、より粗い粒度の変異がこの機能にとって意味を持ち始めたのかもしれない。
結局のところ、ネットワーク・コールにはパフォーマンス・コストがかかるため、我々が望むよりも少し粗い粒度のオペレーションが必要になることが多い。白か黒かのシナリオではないことは確かだ。

### Transactions


GraphQLの旅のどこかの時点で、トランザクションがないという話を聞いたり、少なくともGraphQLでトランザクションを行うにはどうしたらよいかと考えたりすることでしょう。
トランザクションとGraphQLとはどういう意味なのでしょうか？それはデータベースのことではないのでしょうか？以前のaddProductToCheckout変異があると想像してください。
クライアントが3つの商品を追加したいが、すべての変異を成功させたい、あるいはまったく成功させたくないとしたらどうだろう？

```gql
mutation {
  product1: addProductToCheckout(...) { id }
  product2: addProductToCheckout(...) { id }
  product3: addProductToCheckout(...) { id }
}
```

このようなクエリーの方法には、いくつかの問題があります。まず、この章の前半で取り上げた静的クエリとは正反対です。
クライアントは追加する商品の数を指定してクエリー文字列を生成する必要があり、クライアントにとっては実に使い勝手が悪い。
第2に、GraphQLはこれらの変異をすべて次々に実行するため、2回目の変異が失敗し、3回目の変異が成功する可能性があり、クライアント上で実に奇妙な状態になる可能性があります。

多くの人が、1つのトランザクションブロック内で複数の変異を実行できるGraphQL機能を求めてきた。
ほとんどの場合、このような複雑さは必要ありません。
それよりも、前のセクションで説明したように、トランザクション全体を1つのフィールドに含むような、より粒度の粗い変異を設計する方が、ほとんどの場合良いアイデアです。
この例では、複数のアイテムを追加するaddProductsToCheckout変異を追加するのと同じくらい簡単です。
これによって静的クエリの問題とトランザクションの問題が解決されます。


例えば、商品をチェックアウトに追加し、請求先住所を更新し、割引を適用するといったように、順番に実行する必要がある複数の変異がある場合、それを実際のユースケースとして含めることを恐れないでください。特に内部APIを扱っている場合は、より細かい変異を再利用しようとするのではなく、「トランザクション」を解決するための具体的なユースケースを自由に提供してください。

### Batch

トランザクションのような操作を行うもう1つの方法は、バッチ処理を使うことだ。
GraphQLでは、バッチ処理にはさまざまな意味がある。
複数のクエリドキュメントを一度にサーバーに送信するようなバッチ処理もありますが、1つのクエリ内でバッチ変異を設計することもできます。
これまで、より細かい粒度の変異と粗い粒度の変異、クエリを静的なものにする方法、そしてトランザクションをそのユースケースのための新しい変異フィールドとして設計する方法について話してきました。
この問題に取り組むもう一つの方法は、いくつかのオペレーションを入力とするミューテーションを構築することです：

```gql
type Mutation {
  updateCartItems(
    input: UpdateCartItemsInput
  ): UpdateCartItemsPayload
}
input UpdateCartItemsInput {
  cartID: ID!
  operations: [UpdateCartItemOperationInput!]!
}
input UpdateCartItemOperationInput {
  operation: UpdateCardItemOperation!
  ids: [ID!]!
}
enum UpdateCartItemOperation {
  ADD
  REMOVE
}
```

この例では、updateCartItems 変異は UpdateCartItemOperation 入力のリストを受け取ります。
各入力は、operation フィールドを通してどのような操作を表すかを記述します。
クライアントはこの変異を使用して、1 回の変異で任意の数のアイテムを追加および削除できます：

```gql
mutation {
  updateCartItems(input: {
    cardID: "abc123",
    operations: [
      { operation: ADD, ids: ["abc", "def"] },
      { operation: REMOVE, ids: ["bar", "foo"] }
    ]
  }) {
    cart {
      items {
        name
      }
    }
  }
}
```

ADDとREMOVEが両方ともidsの引数を取ったのは幸運だった。
場合によっては、異なるオペレーションが異なる入力を持つこともある。
これを設計するための最良のアイデアは、入力ユニオンを使うことだろう。
しかし、この本を書いている時点では、まだ仕様に採用されていない。
それまでの間は、すべてのフィールドをオプショナルとして提供し、代わりにリゾルバ/ランタイムレベルでこれを処理するのが適切な解決策である：

```gql
input UpdateCartItemOperationInput {
  operation: UpdateCartItemOperation!
  addInput: CartItemOperationAddInput
  removeInput: CartItemOperationRemoveInput
  updateInput: CartItemOperationUpdateInput
}
```


これは冗長で、スキーマはすべてがnull可能なので表現力は乏しいが、機能する。
これは、入力ユニオンを仕様化するまでの間、バッチ変異が本当に必要な場合に便利である。
標準ではありませんが、例えばディレクティブを使って、この入力タイプはあるフィールドしか受け付けないということを示すこともできます：

```gql
input UpdateCartItemOperationInput @oneField {
  operation: UpdateCartItemOperation!
  addInput: CartItemOperationAddInput
  removeInput: CartItemOperationRemoveInput
  updateInput: CartItemOperationUpdateInput
}
```

### Errors


エラーは私たちの多くが悩むテーマだ。
その理由の一つは、やり方が一つではないからであり、どのようにエラーを処理するかは、あなたのAPIが使用されることを意図しているコンテキストに依存するからである。
このセクションを読み進めながら、できる限りこの文脈を捉えるようにしよう。まず、GraphQL仕様がエラーについて述べていること、そしてエラーがどのように見えるかについて説明します。
基本的なGraphQLエラーは次のようになります：

{
  "message": "Could not connect to product service.",
  "locations": [ { "line": 6, "column": 7 } ],
  "path": [ "viewer", "products", 1, "name" ]
}

エラーを説明するメッセージ、クエリ文字列ドキュメントのどこでエラーが発生したかを示すロケーション、クエリのルートからエラーの発生したフィールドにつながる文字列の配列であるパスがあります。
この場合、productsフィールドのインデックス1のproductのフィールド名でした。
エラーはより多くの情報で拡張することができます。
仕様の進化に伴う名前の衝突を避けるために、extensionsキーを使用する必要があります：

```json
{
  "message": "Could not connect to product service.",
  "locations": [ { "line": 6, "column": 7 } ],
  "path": [ "viewer", "products", 1, "name" ],
  "extensions": {
    "code": "SERVICE_CONNECT_ERROR"
  }
}
```

ここでは、クライアントアプリケーションが、人間が読めるメッセージ文字列ではなく、安定した識別子に依存してエラーを処理できるように、エラーにコードを追加しました（一般的には良いアイデアです）。
クエリー結果がレスポンスの data キーの下にあるのに対し、エラーは errors キーの下で GraphQL レスポンスに追加されます：

```json
{
  "errors": [
      {
        "message": "Error when computing price.",
        "locations": [ { "line": 6, "column": 7 } ],
        "path": [ "shop", "products", 1, "price" ],
        "extensions": {
          "code": "SERVICE_CONNECT_ERROR"
        }
  } ],
    "data": {
      "shop": {
        "name": "Cool Shop",
        "products": [
          {
            "id": "1000",
            "price": 100
  }, {
            "id": "1001",
            "price": null
          },
          {
            "id": "1002",
            "price": 100
  }
  ]
  } }
}
```
上の例では、インデックス1の商品のpriceフィールドがnullを返していることに注意してください。
仕様では、エラーが発生したフィールドはnullになり、関連するエラーがerrorsキーに追加されることになっています。
この動作は、APIでこれらのエラーをどのように使用するかにいくつかの影響を与えます。例えば、変異です：

```gql
mutation {
  createProduct(name: "Computer", price: 2000) {
    product {
      name
      price
    }
  }
}
```

例えば、重複した商品が追加された場合のエラーが欲しいとします。
変異フィールドにエラーを追加すると、完全な変異のレスポンスがnullとして返されます：

```json
{
"errors": [
    {
      "message": "Name for product already exists",
      "locations": [ { "line": 2, "column": 2 } ],
      "path": [ "createProduct" ],
      "extensions": {
        "code": "PRODUCT_NAME_TAKEN"
      }
} ],
  "data": {
    "createProduct": null
} }
```

これらのエラーにはいくつかの欠点があり、このような場合には使いにくい：


- 以前に見た変異のPayloadタイプは、変異に関するメタデータをエンコードするのに適していました。この場合、フィールドはnullを返さなければならないので、たとえエラーがあったとしても、この変異のデータをクライアントに送り返す可能性を失ってしまいます。
- エラーの情報は限られているので、サーバーは通常、拡張キーの中に追加のキーを追加する必要があります。エラー自体に追加すると、追加したフィールドと仕様が衝突する危険性がある。
- エラーのペイロードはGraphQLスキーマの外側にあるため、クライアントはGraphQL型システムの利点を得られません。つまり、私たちのエラーは消費しにくいが、進化しにくいということだ。
- ほとんどのフィールドが非NULLの場合、エラーがクエリに壊滅的な影響を及ぼす可能性があるためです。

GraphQLエラーはもともと例外的なイベントやクライアントに関連する問題を表すために設計されたものであり、必ずしもエンドユーザーに中継される必要のある期待される製品やビジネスのエラーを表すものではないことを理解すれば、これはすべて理にかなっています。エラーを2つの非常に大きなカテゴリーに分けることは、何がどこに行くのかを理解するのに役立ちます：

- 開発者/クライアントのエラー： クエリー中に何か問題が発生した（タイムアウト、レート制限、間違ったIDフォーマットなど）。これらは多くの場合、クライアントアプリケーションの開発者が対処する必要があるエラーです。
- ユーザーエラー： ユーザー/クライアントが何か間違ったことをした（チェックアウトの支払いを2回行おうとした、Eメールがすでに使われている、など）これらはAPIが提供する機能の一部です。


先ほど説明したGraphQLの "errors "キーは、開発者/クライアントのエラーを捕捉するのに最適な場所です。
これは開発者によって読み取られ、GraphQLクライアントによって処理されます。
ビジネス/ドメインルールの一部であるユーザー向けのエラーについては、例外/クエリレベルのエラーとして扱うのではなく、スキーマの一部として設計することが現在のベストプラクティスです。
これを実現する方法をいくつか見てみましょう。

### Errors as data

エラーをデータとして設計する最も簡単な方法は、ペイロード・タイプに起こりうるエラーを記述するフィールドを追加することだ：

```gql
type SignUpPayload {
  emailWasTaken: Boolean!
  # nil if the Account could not be created 
  account: Account
}
```

そしてクライアントはこの情報を好きなように利用することができる。
このようなエラー処理の方法は、純粋に内部的なユースケースでは機能するが、汎用的にエラーを処理したり、突然変異間で一貫性を持たせたりするのは難しくなる。
より良い方法は、ペイロード・タイプにuserErrorsフィールドのようなものを含めることです：

```gql
type SignUpPayload {
  userErrors: [UserError!]!
  account: Account
}
type UserError {
  # The error message message: String!
  # Indicates which field cause the error, if any
  #
  # Field is an array that acts as a path to the error #
  # Example:
  #
  # ["accounts", "1", "email"]
  #
  field: [String!]

  # An optional error code for clients to match on.
  code: UserErrorCode
}
```

ステータスコードのようなエラーメカニズムと比較して、データとしてのエラーが少し厄介なのは、クライアントがuserErrorsフィールドに問い合わせる必要がないことである。
つまり、クライアントによってはNULLのアカウントが返ってくるかもしれないが、なぜそうなるのかわからないということだ。解決策の一つは、APIのベストプラクティスについてクライアントを教育することですが、特にそのフィールドを含めなければ、クライアントがエラーに気づく保証はありません。
クライアントは "errors "GraphQLレスポンスのエラーを無視することもできますが、少なくともそれらはGraphQL仕様によって記述されているため、多くのクライアントはすでにそのようなタイプのエラー検出メカニズムを持っていることになります。

#### Union / Result Types

人気を集めているもう1つのアプローチも「データとしてのエラー」アプローチだが、エラー用の特定のフィールドを使用する代わりに、このアプローチではユニオン・タイプを使用して、クライアントに対して起こりうる問題のある状態を表現する。
同じ "サインアップ "の例で、結果ユニオンを使って設計してみましょう：

```gql
type Mutation {
  signUp(email: string!, password: String!): SignUpPayload
}
union SignUpPayload =
  SignUpSuccess |
  UserNameTaken |
  PasswordTooWeak
mutation {
  signUp(
    email: "marc@productionreadygraphql.com",
password: "P@ssword" ){
    ... on SignUpSuccess {
      account {
id
} }
    ... on UserNameTaken {
      message
      suggestedUsername
}
    ... on PasswordTooWeak {
      message
      passwordRules
} }
}
```
ご覧のように、このアプローチにはいくつかの利点があります。ここでのユニオン型は、変異の実行中に起こりうることを非常によく記述しており、各ケースはGraphQL型システムを使って強く型付けされています。
これにより、ユーザー名が取られていた場合のsuggestedUserNameや、提供されたパスワードが弱すぎた場合のパスワードルールのリストのように、各エラーシナリオにカスタムフィールドを追加することができます。
これは、私たちが見た両方のアプローチが伝えようとしていることを例証しています：いくつかのAPIエラーは、他のフィールドや型と同じようにユースケースとして公開されることを意図しており、クライアントも同じようにそれらを利用できるべきです。

#### So, which error style should you pick?

正直なところ、"ユーザーエラー "がスキーマできちんと定義されている限り、どのように実装すべきかについて強い意見はありません。ペイロード・タイプにあるemailIsTakenのような単純なフィールドでも、クライアントの数が少なかったり、使い始めたりする場合には使用できます。ユニオンを使用することは、間違いなくエラーを定義するための非常に表現力豊かな方法です。1つ注意しなければならないのは、クライアントの新しいタイプのエラーに対して、クライアントは防御的なコーディングをしなければならないということです。例えば

```gql
mutation {
  createProduct {
    ... on Success {
      product {
        name
      }
    }
    ... on ProductNameTaken {
      message
    }
    # What if ProductPriceTooHigh gets added?
  }
}
```

ProductPriceTooHighのような新しい型をクライアントが扱えるようにしなければなりません。スキーマがバージョン管理され、クライアント・アプリケーションがスキーマに対してコンパイルされ、大文字小文字のチェックが網羅的に行われるような世界では、これは完璧でしょう！しかし、私たちのほとんどは、特にウェブAPIの世界ではこのようなチャンスはない。このような理由から、論理和型のテクニックは素晴らしく、理論的には（網羅的な大文字小文字のチェックが可能なコンパイル済み言語では）完璧なのですが、GraphQLで使用する場合には不十分である可能性があるのです。
この時点で、このようなケースでuserErrorsリストに考えられる利点は、クライアントがすでに選択した同じフィールド内のすべての新しいエラーを取得できることです。これは、たとえ完璧にエラーを処理できなくても、必要であればエラーを表示し、デバッグしやすいようにエラーメッセージを記録できることを意味します。これは、クライアントのエラー処理に対して、もう少し一般的なアプローチを奨励するかもしれない。
クライアントが新しいエラー・シナリオを処理するのを助けるために使えるひとつのアプローチは、エラー・コントラクトを定義するインターフェース・タイプを使うことである：

```gql
interface UserError {
  message: String!
  code: ErrorCode!
  path: [String!]!
}
type DuplicateProductError implements UserError {
  message: String!
  code: ErrorCode!
  path: [String!]!
  duplicateProduct: Product!
}
```

こうすることで、クライアントはエラー時にメッセージ、コード、パスを常に選択することができ、エラー固有のフィールドも選択できるようになる：

```gql
mutation {
  createProduct(name: "Book", price: 1000) {
    product {
      name
      price
    }
    userErrors {
      message
      code
      path
      ... on DuplicateProductError {
        duplicateProduct
      }
    }
  }
}
```
同じテクニックがユニオンにも適用でき、可能性のあるすべての具象型をカバーするのではなく、インターフェイスの型にマッチさせることができるので、ユーザーの助けになる：

```gql
mutation {
  createProduct(name: "Book", price: 1000) {
    ... on CreateProductSuccess {
      product {
        name
        price
      }
    }
    ... on DuplicateProductError {
      duplicateProduct
    }
    ... on UserError {
      message
      code
      path
    }
  }
}
```
全体として、ユニオン・アプローチもuserErrorsアプローチも効果的です。
これらのアプローチに共通するのは、エラーをスキーマのデータとして扱うということです。しかし、userErrorsアプローチの方が、実行時にプログラムで入力しやすいことがよくあります。
既存の複雑なアプリケーションでは、検証ルールを明示的に定義するのが難しく、より汎用的なエラー処理が必要になることがあります：

```
  user_errors = errors_from_model(product)
```


もう一方では、型を定義し、スキーマを使ってシナリオを明確に定義することができる。ただ、スキーマの進化を重要視するのであれば、ユーザーは新しいケースを処理する方法でクエリを作成する必要があることに留意してください。この章の前半で見たように、ユニオン・アプローチは不可能な状態の設計を避けることもできます。userErrorsアプローチでは、エラーが発生したときにどのフィールドがnullになるかが不明確な場合があります。
このような場合、クライアントに、ユニオンのケースでエラー・タイプとマッチさせるか、ペイロード・タイプでuserErrorsフィールドを選択させるか、どちらかを強制するものはありません。これはまだGraphQLコミュニティで解決されていない問題であり、現在のところ、変異を実行するときにどのフィールド/タイプに注意する必要があるのか、またエラーを返す可能性のあるフィールドをユーザーが理解できるようにするためのドキュメントが必要です。GraphQLエラーでは、少なくともクライアントによってエラーが正しく処理される可能性が高いことがわかります。

### Schema Organization

GraphQLスキーマは、クライアントが要件を選択しなければならない可能性の大きなグラフです。
このため、ユースケースを見つけやすくするような方法でスキーマを整理したり、少なくとも似たような概念をグループ化したりすることについて尋ねたくなる人もいます。

#### Namespaces


多くの人がGraphQLスキーマの名前空間メカニズムを求めてきた。これまでのところ、どの提案も仕様にあまり進んでいません。
この章の前の命名で取り上げたアドバイスに従えば、これが大きな問題になることはほとんどないと思います。
十分に具体的な命名をしていれば、名前空間が絶対に必要な状況はまれでしょう。
しかし、非常に明確な方法で名前空間をつけなければならない場合は、例えばプレフィックスのような命名戦略を使うことをお勧めします：

```gql
type Instagram_User { # ...
}
type Facebook_User { # ...
}
```

私が見聞きしたところでは、名前空間に関する要望のほとんどは、第8章で取り上げるスキーマステッチのような戦略を使う開発者から来るものだ。
スキーマのステッチングは、異なるスキーマをマージすることを可能にし、名前の衝突の扉を開く。繰り返しますが、これは適切な命名によって解決できることが多く、特定のGraphQL機能の代わりにビルド時のツールによって支援することができます。
結果として得られるGraphQLスキーマと、そのスキーマをサーバーサイドで構築する方法は、まったく別の問題であることを覚えておいてください。
名前空間、モジュール、および再利用可能な関数をサーバー側で使用することで、コードの整理を助けることができます。

#### Mutations

突然変異の命名に悩むチームもある。変異の名前をcreateProductにするかproductCreateにするか。
たとえば、私がShopifyにいたころ、チームはproductCreateのルートにすることに決めました。
関連する変異はSDL/introspection/GraphQLでグループ化されるので、よりよい発見ができるようにするためです。
それは理にかなっていますが、私にとっては、整理のためだけに読みにくい名前にするのはいつも悲しいことだと感じていました。

cartProductAddのような名前ではなく、addProductsToCartのような具体的で読みやすい名前を使うことを恐れないでください。ツールは を発見しやすくすることができます。私が遊んでいるアイデアのひとつは、ドキュメントや他のツールのグループ化を助けるためにtagsディレクティブを使うことです：

```gql
type Mutation {
  createProduct(...):
    CreateProductPayload @tags(names: ["product"])
  createShop(...):
    CreateShopPayload @tags(names: ["shop"])
  addImageToProduct(...):
    AddImageToProductPayload @tags(names: ["product"])
}
```

別のアイデアとしては、親フィールドや「名前空間」を使って、shop { create(...) { id }のように、親フィールドの下に似たようなフィールドをグループ化する方法がある。
しかし、仕様とツールはそのような使い方を100％明確にしているわけではないので、今のところそのような使い方をすることはお勧めしません。
変異ルート上のトップレベル・フィールドは、副作用が期待される唯一のフィールドです。つまり、以下のようにグループ化された変異では、以下のようになります：

```gql
mutation {
  products {
    deleteProduct(id: "abc") {
      product
    }
  }
}
```

deleteProductは、理論的には読み取り専用フィールドと考えるべきです。個人的には、使用しているサーバーの実装では技術的にうまくいくかもしれませんが、このルートはお勧めしません。

### Asynchronous Behavior

APIが同期的でないことがある。何かがバックグラウンドで処理される必要があるため、すぐに結果を返すことができないのです。
RESTやHTTPベースのAPIでは、これを処理する最も一般的な方法は202 Acceptedステータスコードです。
しかし、GraphQLでこれを使用するのは厄介です。リクエストの一部だけが非同期で、残りはすぐに返せるかもしれないからです。
これをモデル化するにはいくつかのアプローチがあります。
たとえば、支払い処理を扱っている場合、保留中の支払いをユニオン型の中の型として設計することができます：

```gql
type Query {
  payment(id: ID!): Payment
}
union Payment = PendingPayment | CompletedPayment
```

ユニオンの代わりに単一型を選ぶこともできる：

```gql
type Operation {
  status: OperationStatus
  result: OperationResult
}
enum OperationStatus {
  PENDING
  CANCELED
  FAILED
  COMPLETED
}
```
別の解決策は、ジョブタイプとコンセプトを使って、これらのケースをより一般的に扱うことです。これはShopifyが管理画面のGraphQL APIで採用したものです。このアイデアはとても賢いものです。ジョブはグローバルIDで識別可能で、他に2つのフィールドがあります：
- 非同期ジョブが完了したか、まだ保留中かを示すdone boolean型。
- 楽しい部分： Queryルート・タイプを返すqueryフィールド。これは、ジョブが完了した後の新しい状態をクライアントが問い合わせるのに役立ちます。

### Data-Driven Schema vs Use-Case-Driven Schema


これまで私たちは、実際のユースケースを表現する、よく練られたGraphQLスキーマの設計について多くのことを話してきた。
迷ったときは、データのためではなくビヘイビアのためにGraphQLスキーマを設計するのが私の常套手段でした。
これは通常、APIを消費する際の素晴らしいエクスペリエンスにつながりますが、APIには他にも明確な用途があります。
GitHub GraphQL APIは、ビジネス／ドメインのユースケースを念頭に置いて設計されたスキーマの良い例だ。
このスキーマは、GitHub のドメインとやりとりするアプリケーションや、一般的なユースケースを利用するアプリケーションに適しています。
「課題のオープン」「コメント」「プルリクエストのマージ」「ブランチの一覧表示」「プルリクエストのページ付け」などです。

しかし、ある種の顧客は、GraphQLの構文と機能を見て、ビジネスから必要なデータを正確に取得できる大きな可能性を見出す。結局のところ 私たちがよく耳にする「1つのGraphQLクエリで必要なものを正確に取得する」ということは、そのように解釈されるかもしれません。例えば、5分ごとにすべての問題のすべてのコメントを同期する必要があるコメント分析アプリケーションを考えてみよう。必要なデータのクエリを作成し、1つのクエリを送信し、そして利益を得る。しかし、すぐにある問題にぶつかります：

- ほとんどのAPIは、データを大量に消費するためではなく、例えば人間に結果を表示するために作られているため、リソースをページ分割する。探しているものが純粋なデータである場合、ページ分割されたフィールドはそれをより難しくする。
- タイムアウト： ほとんどのGraphQL APIプロバイダーは、巨大なGraphQLクエリが長時間実行されることを望んでおらず、タイムアウトやレート制限を積極的に使用してそのようなことが起こらないようにします（これについては第4章で詳しく説明します）。しかし、純粋にデータ駆動型のクライアントは、目的を達成するためにかなり大規模なクエリを実行する必要があるかもしれません。有効なユースケースであり、過剰な使用シナリオではないとしても、何千ものレコードをクエリすると、クエリがブロックされる可能性がかなり高い。


かなり扱いにくいですよね？一方では、純粋にデータドリブンなユースケースを持つクライアントには正当な理由があるかもしれませんが、もう一方では、あなたのGraphQL APIはこの目的のために設計されていないかもしれません（そうであるべきでもありません）。実際、これは必ずしもGraphQLの問題ではありません。現在出回っているほとんどのAPIは、ユースケース主導のクライアントを構築することを主な目的としており、大量のデータ（大規模なGraphQLリクエスト、バッチHTTPリクエスト、または大量のHTTPリクエスト）を同期したい場合に対処するのは難しいでしょう。
ユースケースが実際にデータに関するものである場合、他の方法を考えなければならない。

#### Asynchronous GraphQL Jobs

その種の大きなリクエストのほとんどは計算に時間がかかり、リクエスト中に実行することはAPIプロバイダーにとって単純に実行不可能である。もう一つのアイデアは、APIプロバイダーが非同期に実行するクエリをスケジュールし、後で結果を取得することだ。現実的には、非同期クエリを登録するエンドポイントを用意することで実装できるだろう：

```
POST /async_graphql
{
  allTheThings {
    andEvenMore {
      things
      }
  }
}


202 ACCEPTED
Location: /async_graphql/HS3HlKN76EI5es7qSTHNmA
82
And then indicating to clients they need to poll for the result somewhere else:
GET /async_graphql/HS3HlKN76EI5es7qSTHNmA
202 ACCEPTED
Location: /async_graphql/HS3HlKN76EI5es7qSTHNmA
GET /async_graphql/HS3HlKN76EI5es7qSTHNmA
200 OK
{ "data": { ... } }
```

もう一つの例として、Shopifyは "Bulk Operations "と呼ばれる非同期GraphQLジョブの素晴らしい実践例を持っている。
これらの操作には同期GraphQL APIと同じスキーマを使用していますが、リソースを自動ページ分割することができ、レート制限を受けたり、クエリのタイムアウトに直面したりするリスクはありません。これは、より長く実行される、よりデータ指向のユースケースをサポートする素晴らしい方法だ。

### Summary

優れたAPIデザインはGraphQLにとどまらない。この章で見てきたベストプラクティスのほとんどは、HTTP APIやライブラリ設計、場合によってはUI設計などにも当てはまる。この章では多くの原則を見てきましたが、GraphQLスキーマを構築する際に覚えておくべき主なポイントは4つあると思います。
- 第一に、スキーマ開発にはデザインファーストのアプローチを使うこと。ドメインを最もよく知っているチームメイトと設計について議論し、実装の詳細は無視します。
- 第二に、クライアントのユースケースの観点から設計することです。データ、型、フィールドの観点から考えるな。
- 第三に、スキーマを可能な限り表現豊かにすること。スキーマは、クライアントを良い使い方に導くものでなければならない。ドキュメンテーションはケーキの上のアイシングであるべきだ。
- 最後に、非常に一般的で巧妙なスキーマの誘惑を避けること。クライアントのユースケースに明確に答える特定のフィールドと型を構築する。
これらの一般的なプラクティスに従えば、クライアントが気に入って使用し、時間の経過とともにうまく進化するスキーマへの道をすでに歩んでいることになる。

www.DeepL.com/Translator（無料版）で翻訳しました。