## Tooling

過去数年間にGraphQLが成功を収めてきた理由の多くは、GraphQLの驚くべきツールエコシステムと、その型システムと仕様によって構築できる驚くべきツールに帰することができます。本章では、スケールアップする必要があるあらゆる本格的なGraphQLプラットフォームにとって必須のツールを紹介します。まだまだ構築するものが多く、オープンソースやベンダー提供のものにはまだ不足している事実があります。ApolloがGraphQL領域の開発者ツールの主要プレイヤーです。本章では、GraphQL API開発における高品質な体験を確保するための私のお気に入りのツールをいくつか探求します。

### Linting

リンターは、私たちのほとんどが少なくとも一度は使用したことのあるものです。JavaScriptの世界にいるなら、すでにほぼ普及しているESLintに馴染みがあるかもしれません。我々は同じツール群を我々のGraphQL開発経験に適用することができます。GraphQLの型システムとその内省機能は、私たちがGraphQLの定義を読み取り、それを分析することを可能にします。
あなたのスキーマが大きくなるほど、また寄稿者の数が増えるほど、API全体での一貫性を保つことがますます難しくなります。第2章で見た良い設計実践は、強制するのが難しくなり、しばしば特定のGraphQLチームがゲートキーピングチームになり、これは大規模な組織では簡単にはスケールアップできません。リンターは、これらの実践を一連のルールに符号化し、スキーマに変更が加えられるたびに自動的にこれらのルールを実行することを可能にします。これらのリンターはローカルで、開発中に実行することもできますが、自動化されたテストやCIパイプライン中にはより強力な方法で実行することも可能です。
2018年のいくつかのカンファレンスでは、GitHubで私たちが構築したツールの一部を紹介しました。これらのツールの1つは、GraphQL Doctorというリンターでした。それ以来、いくつかの人々がそのアイデアを試してみました。私はオープンソースのGraphQLドクターが存在すると思います。我々はリンターを構築し、エンジニアのほとんどが気付く場所に適用しました：GitHub自体。我々のリンターは最終的に、GraphQLの変更を分析し、必要に応じてベストプラクティスを推奨するプルリクエストボットになりました:
それらを自分で構築したくない場合、すでにいくつかのツールが存在します。素晴らしい例としてgraphql-schema-linter、JavaScriptのGraphQL Schema linterがあります。

#### Change Management

リンターは品質と一貫性を保つだけでなく、スキーマの開発に取り組む開発者が潜在的に危険な変更を認識することで、統合者を壊すのを防ぐ助けにもなります。
リントに使用する同じツールもスキーマバージョンを比較し、それらの間で何が変わったかを判断します。各変更はその後分析され、GraphQLドクターはそれらの変更が破壊的であるかどうかを伝えます。スキーマ間の差異リストを取得することは面倒ですが、幸いなことにあれこれ助けてくれるツールがあります：
- GraphQL Schema Comparatorは私が書いたツールで、GraphQLドクターが内部的に使用しています。
- GraphQL-JSにはスキーマ比較器が含まれていますが、少し隠れています。
- Sangria、ScalaのGraphQL実装もスキーマ比較器を含んでいます。
- 最後に、ApolloのPlatformがこれらの変更を検出するのに役立ちます。
これらのツールの多くが破壊的対非破壊的な変更の分類を助けてくれます。変更がクライアントに何らかの影響を及ぼすのかどうかを知ることは非常に重要です。チームが成長すると、これらの手動で見ていくのは難しく、このようなツールが大いに役立つことになります。

### Analytics

GraphQLのしばしば見過ごされがちな特徴の1つは、クライアントが特定の型のすべてのフィールドを求める方法がないという事実であり、これはSELECT *のようなものです。これはGraphQLに対する反対意見のように聞こえるかもしれませんが、実際には驚くべき分析能力や使用状況分析を構築することを可能にします。典型的なエンドポイントベースのAPIを考えてみてください：私たちは消費されるリソース、返されるステータスコード、送信または返されるヘッダーを追跡することができます。しかし、私たちが知っている唯一のことは、クライアントがどのリソースに興味を持っていたか、実際にどのプロパティを使用していたかではありません。/user/:idのリソースでaddressというプロパティを非推奨にする場合、リソースが正確にどのように使用されているかについての情報がないので、私たちは全員に影響を与えていると考える必要があります。GraphQLでは、Userタイプのaddressが選択されたかどうかを知ることができます。これは、APIの使用方法を理解する上で非常に強力です。
さまざまなクライアント、特に公開APIを持つAPIでは、各フィールドや引数まで使用状況を追跡することが非常に有用となることがあります。GitHubでは、公開APIに対する全てのリクエストを取り、現行のスキーマに対してそれを分析しました。クエリは非常に大きく、使用情報を収集するために各フィールドを通過するのは高価なため、このプロセスをクエリを実行しているプロセスの外でハンドルするのが良い考えです。
これにより、クライアントのクエリタイムが影響を受けることはありません。

画像

分析するための各クエリに対して、後で役立つ可能性がある何かを含めるのが良い考えです：
- このクエリの背後にいるアクター：これはアクセストークン、現在のユーザー、現在のアプリケーションなどである可能性があります。
- 発生した可能性のあるエラー、パースエラーやGraphQLエラー（特定のフィールドが存在しない場合など）を含みます。
- レゾルバの時間、全クエリ時間、パフォーマンス章で話し合ったすべてのこと。

また、遭遇する可能性のある別の問題は、クエリがスキーマのすべてのバージョンに対して有効ではなく、確実にスキーマが同じままでいることを期待していないということです。これが、クエリの情報と一緒に、このクエリを実行したスキーマのバージョンに関する情報を送信するのが良い考えである理由です。解析サービスに毎回全スキーマSDLを送る代わりに、スキーマのハッシュを計算し、そのハッシュを解析サービスに送ることができます。
解析サービスが新しいクエリを受け取ると、最初にスキーマをフェッチする必要があります。これは異なる方法で達成することができます。一貫性のために、私たちはgitを使ってスキーマSDLをロードしました。これは常にAPIリポジトリに保存されています。これは、私たちもスキーマハッシュと一緒にgit shaを含めました。スキーマを持ってからは、分析が容易になります。クエリのルートから始めて、クエリ内のすべてのフィールドを見て、それらを検証し、メタデータ（フィールドが非推奨か？フィーチャーフラグの下だけでアクセス可能か？etc.）を含めて分析し、後で検索することができる形式に格納します。
これを行う一つの方法は、全クエリを「非正規化」して使用されたエンティティの組に変換することです：

- フィールドのリスト（その親タイプと一緒に）
- 使用された引数のリスト（その親フィールドとタイプとともに）
- 使用されたフラグメントスプレッドのリスト（インターフェースとユニオンタイプに対してユーザーが問い合わせている具象タイプを探すときに非常に便利）
- 使用されたEnum値

これらを手元にある任意の時系列データベースやデータウェアハウスに保存します。これら全てのエンティティとともに、クエリを行った人物を符号化することで、以下のような検索が可能になります：

- User.nameを問い合わせる統合者のトップ10リストを見つける
- 共に頻繁に使用されるフィールドを見つける
- 特定の統合者の最も遅いフィールドを見つける
- すべての非推奨フィールドの使用を見る
- 必須でない引数を削除しても安全かどうかを調べる
- 限界はありません！APIがどのように使用されているかを理解し/またはデバッグするのに役立つ他の文脈的データを追加します。

#### Removing sensitive parameters

クエリからセンシティブなパラメータとユーザーデータを削除し、それらを保存して分析するのが一般的な手法です。HTTPリクエストに対する多くのパラメータブラックリストがありますが、GraphQLではクエリ文字列の中を見る必要があります。良いトリックは、クエリを有効に保ち、ユーザーから提供された任意のセンシティブなデータをプレースホルダーに置き換えることです。次のようなクエリが与えられた場合：

```graphql
mutation {
    createUser(
      name: "REDACTED",
      age: null,
      profession: "REDACTED"
  ){
    name
    age
  }
}
```

我々は全てのユーザーが提供したデータをプレースホルダの値、またはフィールドがnullableであればnullに置き換えることができます：

```graphql
mutation {
  createUser(
    name: "REDACTED",
    age: null,
    profession: "REDACTED"
  ){
    name
    age
  }
}
```

このようにすれば、クエリはスキーマに対して有効なままです。私たちはどの引数とフィールドが使用されたかを分析することができますが、実際のユーザーが提供する値を見ることはありません。リストや入力タイプ内のパラメータもサニタイズすることを忘れないでください。
ご覧の通り、このような解析器を構築することは必ずしも簡単な作業ではありませんが、非常に有用であることがあります。残念ながら、これはあなたのアーキテクチャに大きく依存しているため、そのようなものをボックスから出すツールはそれほど多くありません。一度にApolloが友人になる話題です。

### Summary

GraphQLのスキーマは私たちが理解し、スキーマを安定させ、よく設計されたものに保つための多くの素晴らしいツールを使用することを可能にします。我々はこの機会を逃してはなりません。リンターを使用して一貫性とベストプラクティスを強制する、破壊的変更検出器を使用してAPIが安定していることを確認する、そして最後に、クエリに対するできるだけ多くのデータを収集します。クエリを理解し、APIのどの部分がヒットしたかを理解する能力は、過去に何度も私たちを救った超能力です。
