## Implementing GraphQL Servers

前回までの章では、GraphQLがどのようにして生まれ、クエリ言語と型システムがどのようにして複数のクライアントがサーバーによって公開された可能性を通じてさまざまなユースケースを消費することを可能にしたかを見てきました。また、GraphQLスキーマを設計する際に考えるべき点についても取り上げました。しかし、私たちはこの概念については話しましたが、実際にはGraphQLサーバーがどのように作成し実装されるかについては触れていませんでした。本章では、GraphQLサーバーの実装における主要な概念といくつかの例を見ていきます。全ての言語固有のライブラリは異なる方法で物事を行うため、ここでは特定の方法よりも原則に重点を置いていきます。

### GraphQL Server Basics


理論的には、GraphQLサーバーの構築は簡単ですが、実際にはそれなりに難しさも伴います。もしGraphQLサーバーの基本的な概念を既に理解しているなら、次のセクションに進んでください。基本的に、GraphQLサーバーを構築するためには主に以下の3つが必要です。

型システムの定義（第2章で設計していたもの）
型システムに従って要求されたクエリを満たすためのランタイム実行エンジン (これがこの章の主題です)
ほとんどの場合、クエリ文字列と変数を受け付けるHTTPサーバーが必要
ほぼ全ての言語にはGraphQLサーバーの実装があり、全てが異なる方法でこれら2つの要素を達成させます。ユーザーはAPIのための型システムとランタイム挙動を定義し、ライブラリは通常、実行アルゴリズムを含むGraphQLの仕様を実装します。クエリを満たすためには型システム以上のもの、つまり型システムの背後にある動作とデータが必要です。GraphQLでは特定のフィールドのデータを満たすために使われる概念は「リゾルバ」と呼ばれます。基本的に、リゾルバは単純な関数です。

```graphql
function resolveName(parent, arguments, context) {
  return parent.name;
}
```

リゾルバは単一フィールドのデータを解決する役割を担っています。GraphQLエンジンは、特定のフィールドに到達した時点でそのフィールドのリゾルバを呼び出します。実際には、GraphQLクエリの基本的な実行は、木構造のデータ構造を深さ優先探索することによく似ています。

GraphQLクエリの各ステップまたはノードで、GraphQLサーバーは通常、その単一フィールドに関連したリゾルバ関数を実行します。上記の例で見るように、resolve関数は通常3つから4つの引数を取ります。第一引数は通常、親オブジェクトです。これは親リゾルバ関数によって返されたオブジェクトです。上記の画像を見てみると、これはnameリゾルバがuserリゾルバが返したuserオブジェクトを受け取ることを意味します。二番目の引数はフィールドの引数です。例えば、フィールドuserがid引数で呼び出された場合、userフィールドのリゾルバ関数はそのid引数に対して提供された値を受け取るでしょう。最後に、第三引数は通常、コンテキスト引数です。これは特定のクエリのグローバルデータとコンテキストデータを含むオブジェクトで、任意のリゾルバがアクセス可能なデータを含むために使用されることが多いです。

これを具体的な状況に置き換えてみましょう。次のようなクエリがあるとします：

```graphql
query {
  user(id: "abc") {
    name
  }
}
```

GraphQLサーバーはまず、"root"オブジェクト（実装によって異なります）、id引数、そしてグローバルコンテキストオブジェクトを使ってuserリゾルバを呼び出すと想像してみてください。その後、userリゾルバの結果を取得し、それを使ってnameリゾルバを呼び出します。nameリゾルバは第一引数としてuserオブジェクトを受け取り、追加の引数はなく、グローバルコンテキストオブジェクトを受け取ります。

型システムが整い、各フィールドで実行するためのリゾルバが準備できていれば、GraphQLの実装でクエリを実行するために必要なものはすべて揃っています。もしまだGraphQLサーバーを実装したことがなければ、お気に入りの言語のGraphQLの実装で遊んでみて、準備ができたら再度この記事を読むことをお勧めします。これから少し高度な概念と考慮事項に進んでいきます。


### Code First vs Schema First

おそらく過去数年間で、GraphQLサーバーの実装に関して最も大きな議論が巻き起こったのは、「コードファースト」アプローチか「スキーマファースト」アプローチのどちらが最良であるかという問題です。これらのアプローチは、サーバーサイドにおいて型システムが構築される方法を指します。

#### Schema First

スキーマファーストの場合、開発者は主に前章で取り上げたスキーマ定義言語（SDL）を使ってスキーマを構築します。JavaScriptにおいて、参照実装を使用した場合、スキーマファーストアプローチは以下のようになります：

```js
var { graphql, buildSchema } = require('graphql');
  var schema = buildSchema(`
    type Query {
      hello: String
    }
`);
```

スキーマの文字列がbuildSchemaに渡され、GraphQLのスキーマがメモリ内で構築されます。スキーマを持つことは素晴らしいことですが、クライアントがそれを要求したときにこのhelloフィールドが何を返すべきかについてのロジックがなければ、それはほとんど無意味です。スキーマファーストのアプローチでは通常、SDLを使って定義されたフィールドとタイプに対応するようにリゾルバーを定義させます。再び、GraphQL JavaScriptの参照実装を使用した場合、それは以下のように見えます：

```js
// Define a resolver object that can augment // the schema at runtime
var root = {
  hello: () => {
    return 'Hello world!';
}, };
// Run the GraphQL query '{ hello }' and print out the response // Use the `root` resolver object we created earlier. graphql(schema, '{ hello }', root).then((response) => {
  console.log(response);
});
```

スキーマファーストのアプローチは、設計ファーストのアプローチと混同してはなりません。これは、前章で取り上げたスキーマ設計について述べたように、APIを構築する際にはほぼ常に良い考えです。スキーマファーストということは、私たちが使用しているプログラミング言語で利用可能な構造物でそれを純粋に定義するのではなく、SDLを直接利用してスキーマを構築しているということです。これは私たちがコードファーストを探求するにつれて明確になるでしょう。
スキーマファーストのアプローチには大きな利点があります。その一つは、私たちが共通の言語、すなわちSDL自体を使ってスキーマを構築しているという事実です。これによりエンジニアは、結果として得られるGraphQLのスキーマが何であるかを大いに自信を持って分かります。そしてそれだけでなく、スキーマ開発者は、実装についてすぐに考えるのではなく、GraphQLについて考えることを強制します。
SDLは一般的に優れたツールです。それは、異なる言語を使用しているチーム間、あるいは単にクライアントとサーバー間での共通の言語として機能します。しかし、それはまたコンピュータ間の共通の言語としても機能します：大量のツールがSDL自体に対して動作するため、それらは言語に中立です。これは大きな利点であり、特にGraphQLのツールがあなたが構築しようとしているプログラミング言語でうまく動作しない場合には特にそうです。
SDLは素晴らしいツールですが、全てを行うことはできません。例えば、先ほどの例で見たように、SDL自体はフィールドが要求されたときに実行すべきロジックを記述するメカニズムを提供しません。これは理にかなっています、GraphQLのスキーマ言語はインターフェースを記述するために作られていますが、ネットワーク呼び出しを行ったり、データベースのリクエストを送ったり、APIサーバーで通常必要とする任意のロジックを実行するために必要な強力なプログラミング言語ではありません。
スキーマの記述とランタイムで何が起こるかを分離する必要性は、スキーマファーストのアプローチでは難しさになり得ます。スキーマが十分に大きくなると、型定義とそれらがマップされたリゾルバーが実際に有効であることを確認することは大きな挑戦である可能性があります。スキーマの変更は全てリゾルバーに反映させるべきであり、それは逆もまた真です。

最後に、もう一つの問題は、SDLを使用すると再利用可能なツールや型定義ヘルパーを定義することが難しくなるということです。スキーマが大きくなり、より多くのチームメンバーがスキーマに貢献するにつれて、スキーマ定義の振る舞いを完全に入力するのではなく、再利用可能な関数やクラスにカプセル化することがよく有用になります。これはスキーマを不一致のリスクに晒します。
これらの問題はすべて、慎重なツール作りで主に解決可能ですが、それらを解決するためには何らかの段階でコードを関与させる必要があります。では、最初からコードを使うとどうなるでしょうか？

#### Code First

コードファーストのアプローチは、そのスキーマファーストのアプローチに対する代替案です。SDLを使う代わりに、私たちが使用できるプログラミング言語の基本機能を使います。以下に、GraphQL Ruby ライブラリからの例を挙げます。これにより、この点が明確になるかもしれません：

```ruby
class PostType < Types::BaseObject
  name "Post"
  description "A blog post"
  field :title, String, null: false
  field :comments, [Types::CommentType], null: true,
    description: "This post's comments"
  def title(post, _, _)
    post.title
end
  def comments(post, _, _)
    object.comments
end end
```

ご覧の通り、GraphQL RubyはRubyクラスを使ってGraphQLオブジェクトタイプを表現します。SDLとして表現すると、このクラスは次のように見えます：

```ruby
type Post {
  title: String!
  comments: [Comment]
}
```

この場合、スキーマを定義するためにRubyを使用することで、GraphQLスキーマの開発に携わるエンジニアはRubyに関する全てのツールを、例えば、一般的な機能用のモジュールを含むか、またはタイプをプログラム的に定義する等、いつものように使用することができます。GitHubでよく使う一例として、接続タイプの生成があります。接続タイプは、GraphQLにおけるページネーションを行う方法です。通常、スタートするためには多くの定型文が必要です：
• XConnectionタイプ（例えばPostConnection）を定義する
• エッジタイプ（例えばPostEdge）を定義する

コードファーストのアプローチを用いることにより、プロバイダーはAPIの異なるバージョンを、完全なスキーマを構築せずに提供することが可能となります。例えば、我々のすべてのページネートされたリストに対して完全な接続タイプをタイプしなければならない代わりに、コードファーストのシナリオでは、このタイプ生成を自動化するコードを単に書くことができます。

```ruby
# Connection.build creates a connection type as
# well as the edge type for paginating comments
field :comments, Connection.build(Types::Comment)
  description: "This post's comments"
```

コードファーストを用いると、我々はSDLではなく、単純にコードを使って遊んでいるだけなので、何を構築することも可能です。また、もう一つの大きな利点としては、通常、コードファーストのアプローチではスキーマとリゾルバー、インターフェースとランタイムロジックを同じ場所で定義します。これはメンテナンスの観点から非常に重要で、特に数百から数千のタイプやフィールドを扱う場合にはそうです。

しかしながら、コードファーストはSDL上で動作するツールがあなたのスキーマ定義を理解できなくなることを意味します。さらに、我々はGraphQLを非常に抽象化してしまうため、何がユーザーに公開されているのかが明確でなくなります。これは考慮する必要があり、また、それを解決することも可能です。

#### SDL Design, Code Implementation, SDL Artifact

私のお気に入りはハイブリッドなアプローチです。SDLはスキーマ設計を議論する素晴らしいツールであり、その実装に進む前に利用します。我がチームでは、GitHubのIssueやその他の課題追跡ソフトウェアを使用してまず設計を議論することを好みます。SDLを使用すると、誰でも提案されたスキーマを見ることができ、通常、同じことをプログラミング言語で書くよりもはるかに早く記述できます。

設計に満足したら、コードファーストのアプローチを使って実装に移ることができます。これにより、強力なツールを使用し、定義とリゾルバーを共有することができます。今回、プログラミング言語の抽象化が結果としてのスキーマが何になるかを見るのを難しくする可能性があると話しました。ShopifyやGitHubで見た最も強力なパターンの一つは、コード定義からSDL成果物を生成することです。この成果物はバージョン管理システムにコミットし、常に同期を保つためにコードに対してテストするべきです。

これにより、「両方の良い点を兼ね備えた」解決策を得ることができます。私たちは、スキーマをより効率的に定義するためにプログラミング言語の力を利用しますが、SDLが私たちに与える「真実の源」を保持します。コードから生成されるSDLを成果物として持つことで、レビュアーやチームメイトはGraphQLの変更が何を意味するのかを迅速に理解することができます。また、元々別の言語で定義したものであっても、SDL上で動作する任意のツールを使うことができます。これは、コードファーストのスキーマ定義アプローチを採用する場合に強く推奨されます。

#### Annotation-Based Implementations

これまでに見てきたスキーマファーストとコードファーストのアプローチの戦いの中には、スキーマ構築の別の良い方法、つまり注釈ベースのアプローチが存在します。これはFacebookのGraphQLスキーマが構築された方法だとされていますが、それはコードファーストのアプローチに近いものの、完全に同じではありません。

注釈ベースのスキーマ実装は通常、ドメインエンティティ、オブジェクト、クラスなどを使用し、それらに注釈を付けてGraphQLスキーマを生成します。ここでの大きな利点は、インターフェース層が非常に小さいことです。GraphQLスキーマを定義するために何百ものオブジェクトを必要としないのです。代わりに、既存のドメインエンティティを単純に再利用することができます。

このアプローチの危険性は、最初に「エンティティ」が良好なAPIを作成することに依存していることです。データベーススキーマや実装詳細に密接に結び付いているActiveRecordオブジェクトしか持っていない場合、注釈ベースのアプローチは結果として得られるAPIがあまり良くないか安定していない可能性があります。しかし、データベースのような実装詳細に依存しないドメインを代表するよく定義されたエンティティを持っているなら、これは非常に優れたアプローチになるかもしれません。

これの良いオープンソースの例は、GraphQLサーバーを構築するためのJavaライブラリであるgraphql-spqrです。

```java
public class User {
    private String name;
    private Date registrationDate;
    @GraphQLQuery(
      name = "name",
      description = "A person's name"
    )
    public String getName() {
        return name;
    }
    @GraphQLQuery(
      name = "registrationDate",
      description = "Date of registration"
    )
    public Date getRegistrationDate() {
        return registrationDate;
    }
}
```

Javaは一般的に注釈ベースのアプローチに馴染みがあり、それが非常にうまく機能します。全体として、これはコードファーストのアプローチに非常に似ていますが、すでによく定義されたドメインオブジェクトを持っている場合には、注釈ベースのアプローチが役立つかもしれません。

### Generating SDL Artifacts

コードファーストの文脈で語られたように、SDLアーティファクトを生成することは素晴らしい方法です。しかし、必ずしも直感的なわけではありません。幸いなことに、一部のGraphQLライブラリーはこの機能を提供しています。例えば、GraphQL-RubyにはSchema::Printerというクラスがあり、これはスキーマRubyオブジェクトを受け取り、それをSDL文字列に変換することができます。


```
# Print the SDL document based on MySchema
# An instance of GraphQL::Schema GraphQL::Schema::Printer.print_schema(MySchema)
```

JavaScriptの世界では、GraphQL-JSにはprintSchemaというユーティリティメソッドが含まれており、それはほぼ同じことを行いますが、Ruby版ほどカスタマイズ可能ではありません。

```js
import { printSchema } from 'graphql';
// Print the SDL document based on schema // A variable of type GraphQLSchema printSchema(schema)
```

スキーマプリンターをサポートしている任意の言語は良い基盤を提供してくれます。コードファーストのアプローチを通じて追加された新しいフィールドや型は、アーティファクトに反映されます。あなたのドキュメンテーションジェネレーター、リンター、その他のツールは、コードを分析する代わりに、その真実の源から操作することができます。もう一つのオプションはインタロゲーションクエリですが、これは通常ランタイムで行われ、全体のスキーマを必ずしも反映するわけではなく、トークンやユーザーのスキーマビューだけを反映します。より良いアプローチは、スキーマ全体を印刷することです。フィーチャーフラグ化されたフィールドを隠すのではなく、パートナー専用タイプを隠すのではなく、すぐにすべてを印刷し、メタデータで注釈付きにします。それにより、SDLを見て、これらのタイプが全員に利用可能であるわけではないことが明確になります。

```
directive featureFlagged(name: String!)
  on FieldDefinition | TypeDefinition
type Query {
  viewer: User
}
type User {
  name: String
  secretField: SecretType @featureFlagged(name: "secret")
}
type SecretType @featureFlagged(name: "secret") {
  name: String!
}
```

このアプローチは、変更がスキーマ全体にどのように影響を及ぼすかの信頼感を向上させるのに非常に効果的です。また、これは linting、breaking change detectors、ドキュメンテーション生成器など、開発者向けの全てのツールの基礎となることができます。私はこのスキーマアーティファクトをソースコントロールにチェックインすることを強くお勧めします。つまり、変更を加える開発者はすぐに結果となるスキーマ構造を見ることができ、スキーマの唯一の真実の源がバージョニングされます。

悪いニュースは、おそらくこの作業を行うためには、特定の実装が行えるように、メタデータ解決策がディレクティブ定義を追加することも必要である可能性があります。GraphQL Ruby ではカスタムプリンターが非常に簡単に作成できますが、GraphQL-JSにはデフォルトで単純なprintSchema関数しかありません。

幸い、そのファイルはそれほど大きくないため、あなた自身で実装することが可能かもしれません。

#### Summary

可能な限りコードファーストのアプローチを使用してスキーマを作成することを強くお勧めします。しかし、選択した特定のプログラミング言語によっては、最も成熟したライブラリがスキーマ定義スキームとして選んだものに応じて、アプローチが決まることがあります。例えば、GraphQL Ruby、Sangria（Scala）、Graphene（Python）はすでにコードファーストを好む傾向がありますが、JavaScriptの世界では、ライブラリの選択次第です。GraphQL NexusやGraphQL-JSを直接使用するツールの利用を推奨します。SQPRやtype-graphqlのような注釈ベースのアプローチも素晴らしい選択肢となる場合がありますが、GraphQLスキーマを実装の詳細に結びつけてしまわないよう注意が必要です。

### Resolver Design

どのようにスキーマを構築しているかに関わらず、ある時点でリゾルバーを書く必要があります。GraphQLの実行エンジンのリゾルバーパターンは素晴らしいものです。これにより、チームは個別のリゾルバーに取り組むことで新たな使用例を追加し、単一フィールドのロジックを考えるのが簡単になります。しかし、それが過度に使われることもあります。本質的に、GraphQLはAPIインターフェースです。あなたのドメインやビジネスロジックへのインターフェースであり、ほとんどの場合、ビジネスの真実の源ではありません。

それが現実にどのように見えるかというと、素晴らしいリゾルバーは非常に少ないコードしか含まれていません。それはユーザー入力を処理し、ドメイン層に対して呼び出しを行い、結果をAPI結果に変換します。今、「ドメイン」層がどのように見えるべきかを説明することは全く異なる話であり、それを説明するためには本一冊が必要です。しかし、一般的に、少なくとも永続性とインターフェースのレイヤーの外側での振る舞いをカプセル化することは、素晴らしいスタートとなります。そこでさまざまな検証ルールを扱い始めるのはとても魅力的ですが、リゾルバーを可能な限り「愚か」にしようと努力してください。GraphQL APIはおそらくあなたのビジネスへの唯一のエントリーポイントではないでしょう。UI、REST API、あるいはマイクロサービス間の内部RPC呼び出しがある場合、これらすべてを一貫性を持たせることが求められます。GraphQLレイヤーであまりにも多くのロジックを処理し始めると、時間の経過とともに古くなったり、まったく間違ったものになる可能性があります。

#### Beware of the Context Object

ほとんどのGraphQL実装でリゾルバーで使用することを許可されているcontext引数は非常に便利です。例えば、特定のヘッダーの値、リクエストIP、認証や認可データなどの「リクエスト」レベルの情報を保存するのに非常に役立ちます。これらは全く妥当なcontextの使い方ですが、それを使用してランタイムの振る舞いを変更すると、安定したAPIを構築する上で非常に有害になり得ます。contextを周りに追加するたびにAPIは予測可能性を失い、テストが難しくなりキャッシュも困難になります。次のリゾルバーを見てみましょう：

```ruby
def user(object, arguments, context)
  if BLACKLIST.includes?(context[:ip])
nil
else
    getUser(arguments[:id])
  end
end
```

このコードが必ずしも間違っているわけではありませんが、これらの条件分岐が多すぎると、同じcontextがすべての呼び出しで提供されることに依存します。例えば、全く異なるcontextで実行されるクエリ、内部呼び出しやIPが提供されないインターサービスの呼び出し等は、リゾルバーのロジックが破綻する結果となります。
また、可能ならば避けるべきパターンとして、クエリ実行中にcontextオブジェクトを変更することがあります。以下のような場合です：

```ruby
def user(object, arguments, context)
  user = getUser(arguments[:id])
  context[:user] = user
  user
end
```

これにより、リゾルバーは依存順序が生じ、スキーマが進化するかユーザーが考えていなかったクエリパターンを実行すると問題が発生することがほぼ確実です。contextを完全に使用せずに済むのは非常に難しいですが、そこに何を入れるかは非常に慎重に選択してください。また、クエリを実行する前にcontextの一部を必要とするようにするのも良いアイデアかもしれません。

#### Lookaheads and Order Dependent Fields

一部のライブラリでは、あなたの関数が現在解決しているフィールドの下でクエリされているフィールドについての情報を取得することができます。この情報を非常に慎重に扱ってください。例えば、注文の商品データを事前に読み込むことは魅力的に思えるかもしれません。しかし、クエリの形状やその子フィールドのクエリに依存するリゾルバーのロジックを書くことには問題があります。
• GraphQLのフィールドはクエリルート上で並行して実行できます。おそらく、並列化できないリゾルバーロジックを持つことで自分自身を永遠にロックすることは避けたいものです。
• スキーマが進化すると、リゾルバーが予期しなかった新しいクエリが登場し始めます。これは、サブクエリの処理に対して書いたロジックが古くなり、ほぼ間違いなく誤っているということを意味します。
クエリの実行についてあまりにも賢くすると、結果的に物事が最悪の方向に進むことが多いです。リゾルバーパターンの美しい点は、それが一つのことを行い、それを本当にうまくやるということです。ロジックは孤立した状態に保つよう努めてください。一般的に、クエリで型やフィールドがどこで使用されるかを想定しないでください。おそらくそれは異なるコンテキストで再利用され、依存すべき主要なものはそれが受け取るオブジェクトです。突然変異フィールドを除き、リゾルバーは純粋な関数として最も良く動作します。それらは可能な限り一貫性のある振る舞いを示し、クエリルート上で問い合わせられたときに副作用を持つべきではありません。これは、クエリコンテキストを全て変異させることを避け、実行順序に全く依存しないことを意味します。

#### Summary

素晴らしいリゾルバーを書くというのは言う方が簡単で、しかし私たちは次の基本原則に焦点を当てることで、私たちが正しい方向に進んでいることを確認することができます：
- ビジネスロジックはGraphQLレイヤーから可能な限り遠ざけます。
- context引数を可能な限り不変に保ちます。
- フィールドが特定の順序で呼び出されることに依存しない、またはcontext内の特定の値が他のフィールドによって埋められたと仮定しないでください。

### Schema Metadata

十分に複雑なGraphQL APIは、いずれ型システムにメタデータや任意の追加情報を加える必要があります。型システムではフィールド、それらの型、およびそのnullabilityを記述することができますが、全てを行うことはできません。スキーマメンバーに追加したい他の多くのものがあります。たとえば、GitHubのGraphQLフレームワークでは、エンジニアがスキーマバージョン（内部または公開）、タイプが開発中であるかどうか、特別な機能フラグの背後に隠されているか、特定のスキーマメンバーにアクセスするために必要なoauthスコープ等をタグ付けることができます。これらについては後で詳しく説明します。

コードファーストのアプローチを使用している場合、メタデータは簡単です。私たちはそれを好きな方法で行うことができます。GraphQL Rubyでは、基本クラスを定義し、そこから拡張することができます。これにより、自分たちのDSLとメタデータを定義できます。例えば：

```ruby
class PostType < MyBetterObjectType
  name "Post"
  description "A blog post"
  under_development since: "2012-07-12"
  schema :internal
  scopes :read_posts
  # Field definitions
end
```

GraphQL Nexusでも、ほとんどのスキーマメンバーにこの種のメタデータを設定することができます。たとえば、フィールドIDに複雑さ属性を設定することなど：

```ruby
export const User = objectType({
  name: "User",
  definition(t) {
    t.id("id", {
      complexity: 2,
    });
  },
});
```

スキーマファーストまたはSDLファーストのアプローチでは、通常、スキーマ指令を介してメタデータが作成されます。これらの指示は、カスタムユースケースを可能にするためにフレームワークによって解釈されます。だから、私たちがちょうど見た例のようなカスタムRuby DSLを持つ代わりに、同じメタデータをSDLファーストのアプローチで以下のように定義することができます:

```
type Post
  @underDevelopment(since: "2012-07-12")
  @schema(schema: "internal")
  @oauth(scopes: ["read_posts"]) {
  title: String!
  comments: [Comment]
}
```

このメタデータを他のマシンが消費したり、クライアントがそれを内省を通じて取得したりする方法についての話は複雑です。この本を書いている時点では、これを最善にどうやって行うかについての議論がまだ進行中です。これは、スキーマディレクティブが現在、内省リクエストを通じて公開されていないためです。私のお勧めは、実際の内省クエリがそれをサポートしていなくても、このメタデータを生成するSDLにエンコードすることです。これにより、少なくともツールがこのメタデータを帯域外で消費することを可能にします。現時点で、SDLダンプと内省ペイロードの違いは少し厄介であり、最終的に仕様で対処されることを期待しています。

スキーマメタデータは、新しい機能をAPIに追加する開発者を導く素晴らしい方法です。これにより、全ての開発者にコードをコピーするように頼む代わりに、一部のメタデータに基づいて実行する再利用可能なコードを書くことができます。例えば、oauth_scopeメタデータ属性は、SDLにこれを公開し文書化を生成するだけでなく、このメタデータを定義している全てのリゾルバーのチェックを自動化することも可能にします。これは、複数の開発者が拡張する可能性があるGraphQLプラットフォームを作成する人にとって必須です。

### Multiple Schemas

私たちの中には、維持しなければならないスキーマが異なる人もいます。例えば、ShopifyにはストアフロントAPIと管理APIの両方があります。GitHubにも内部APIと公開APIの両方があります。複数のスキーマを維持することは難しい場合があります。これらのスキーマは完全に分離し、異なるものであるべきですか、それとも共通の関心事を共有すべきですか？
複数のGraphQLスキーマを維持し公開する際には主に2つの手法があります。1つ目の手法は、ビルド時に異なるスキーマを構築すること、2つ目の手法は、実行時に異なるスキーマを構築することです。

ビルド時のアプローチは最もシンプルです。異なる用途のために異なるスキーマを単純に作成します。この方法はスキーマがかなり異なる場合に最適ですが、オブジェクトタイプの定義やGraphQLプラットフォームの共通コードを共有することも可能です。例えば、以下のようなケースでは上手く機能します。

```
+-- admin
|   +-- order.rb
|   +-- schema.rb
+-- storefront
|   +-- collection.rb
|   +-- product.rb
|   +-- schema.rb
+-- common
|   +-- product_image.rb
```

この手法の大きな利点は、どのスキーマが構築されているかを非常に簡単に確認できることです。また、スキーマが自由に進化できることを保証します。このため、タイプが同一であると確信していない限り、タイプの定義を再利用しないでください。再度、コードは共有することが可能ですが、実際のGraphQLのタイプを共有することは避けてください。

ほとんどのスキーマが同じで、小さな違いがある場合には、実行時のアプローチが有用です。例えば、公開APIは内部APIの一部であったり、特定のユーザーに対して特定のタイプだけを提供するかもしれません。そのような場合、スキーマメタデータが非常に便利で、非常に類似した2つのスキーマを構築し、タイプを重複して維持するのを避けられます。以下にGraphQL Nexusを使用した例を示します。これにより、オブジェクトタイプに追加の設定を定義することができます。

```
const User = objectType({
name: "User",
// Annotate this type as INTERNAL only. schema: INTERNAL,
definition(t) {
    t.int("id", { description: "Id of the user" });
  },
});
```

ここで欠けている部分は、特定のリクエストに基づいてフィールドを非表示または表示する能力が必要です。これは一般的にスキーマの可視性フィルタやスキーママスクと呼ばれます。

#### Schema Visibility

新しいRESTエンドポイントを選択したパートナーに開発したり、フィーチャーフラグの背後に新しい機能を構築する際、通常はこのエンドポイントが公開されることを望まないです。普段、その新しいリソースを認識すべきでない人は404 Not Foundを取得します。そのリソースの存在を漏らすことはないため、403 Unauthorizedを返すことはありません。フィーチャーフラグがない限り使用をブロックしたいのですが、同時に今後のリソースを漏洩するリスクも避けたいと思います。

大規模なGraphQL APIでは、同じメカニズムが必要なことが非常に一般的ですが、私たちは単一のエンドポイントを扱っています。リソースの存在を隠す代わりに、スキーマの一部、つまりフィールドやタイプ、または任意のスキーマメンバーを隠したいと思います。これは一般的にスキーマの可視性やスキーママスキングと呼ばれます。スキーマ可視性は、フィーチャーフラグの背後に新しい機能を公開したり、特定のパートナーとのみスキーマを共有したりするためだけでなく、実行時に特定の可視性マスクを適用することで、複数のスキーマのバージョンを維持する手助けができることが、次のセクションでわかるでしょう。

これは、典型的な認証とは非常に異なるということに注意してください。認証は通常、フィールドリゾルバ内で実装され、nullやエラーを返します。可視性では、クライアントがスキーマに存在するフィールドやタイプを見ることさえ望んでいません。GitHubのスキーマプレビューは、可視性が動作している良い例です。新しいスキーマ機能は、特別なプレビューヘッダーがクエリと一緒に渡されるときだけにアクセス可能です。ヘッダーを持っていないクライアントは、「フィールドが存在しないエラー」を受け取ります。

この本を執筆している時点で、残念ながらすべてのライブラリにスキーマの可視性メカニズムが実装されているわけではありません。GraphQL-JSはこの機能を持っていませんが、GraphQL RubyとGraphQL Javaの両方は、特定のスキーマメンバーの可視性を制限する能力を開発者に与えています。選択したライブラリがこれをサポートしていない場合、そしてこの章を読んで重要な機能と確信したら、それを実装するか、それについての問題を提起することをお勧めします。

スキーマメタデータと可視性を組み合わせることで、本当に強力なものが始まります。例えば、GitHubの実装では、開発者はタイプにフィーチャーフラグを付けることができます：

```ruby
class SecretFeature < ProductionReadyGraphQL::BaseType
  name "Secret"
  description "Do no leak this."
  feature_flagged :secret_flag
  # Field definitions
end
```

その後、実行時に可視性フィルタがクエリの実行に適用され、このフィーチャーフラグにオンボーディングされたユーザーだけがこのタイプが存在することを見ることができます。GraphQL Rubyはフィーチャーフラグ化されたタイプのすべてのフィールドを隠し、それらも隠すことが賢明です。

```ruby
class FeatureFlagMask
# If this returns true, the schema member will be allowed def call(schema_member, ctx)
    current_user = ctx[:current_user]
    if schema_member.feature_flagged
      FeatureFlags
        .get(schema_member.feature_flagged)
        .enabled?(current_user)
    else
      true
    end
  end
end

MySchema.execute(query_string, only: FeatureFlagMask)
```

可視性はフィーチャーフラグのような素晴らしいユースケースを可能にしますが、過度に行うべきではありません。極端になると、ユーザーが最終的にどの「バージョン」のスキーマを見ているのかをデバッグ、テスト、追跡するのが本当に難しくなります。フィーチャーフラグや内部対公開といった異なるスキーマバージョンなど、より広範なユースケースに可視性を使用しようと努めてください。

例えば、タイプを隠すとそのタイプのフィールドも隠されるなど、他のものに基づいてグラフの一部を隠すことができるくらい賢い可視性の実装を構築することは非常に難しい場合があります。インターフェースを隠すことを考えてみてください。これはそれを実装するタイプのフィールドを隠すべきです。また、あるタイプのすべてのフィールドを隠すこともできます。これはこのタイプを隠し、それが順番にそれを参照するフィールドを隠すべきです。それは本当に複雑です！フィーチャーフラグやランタイムマスキング機能の一部を達成するために必要ですが、2つの別々のGraphQL APIを構築する際には最も簡単なアプローチではないかもしれません。その場合、2つの定義とコード共有のシンプルなアプローチが、あなたにとってはより良い結果をもたらす可能性があります。

### Modular Schemas

スキーマが大きくなると、チームはしばしばそのスキーマを異なる部分にモジュール化または分割する解決策を探し始めます。merge-graphql-schemasやGraphQL Modulesのようなツールは、それをある意見に基づいて行うのに役立ちます。ソフトウェア開発全般でモジュール化は素晴らしいアイデアであることは間違いありません。しかし、スキーマ定義自体をモジュール化するという考え方は、主にSDL（Schema Definition Language）ファーストのアプローチでスキーマを構築している開発者から出てくる問題であることに気付くでしょう。なぜなら、SDLは本質的に一つの大きな定義ファイルだからです。上記のツールはSDLの一部をモジュール化し、それを1つのスキーマにマージすることをチームに可能にしてくれる素晴らしい仕事をしていますが、それが常に必要というわけではありません。

コードファーストのアプローチでは、特別なテクニックやライブラリを使わずにモジュール化することが通常非常に簡単です。私たちはコードを扱っているので、GraphQLがどうであれ、モジュール化はすでに考慮されているべきです。私が見てきたことからすると、開発者は特定のGraphQLモジュールについて少し過度に心配する傾向があり、代わりにプログラミング言語の規約を使ってモジュール化を達成するべきだと思います。クライアントが消費する結果的なGraphQLスキーマとそれがどのように定義されるかは全く別のものであることを忘れないでください。

どのように物事をモジュール化するべきかについては、サブドメインに分割することを支持しています。これは、関連する概念は互いに近い場所に存在するべきであるという意味です。以下に一般的にうまく機能するディレクトリ構造の例を示します：

```
+-- graphql
|   +-- orders
| |
| |
| |
|   +-- products
|   |   +-- product_type.rb
|   |   +-- variant_type.rb
|   +-- schema.rb
```

これらのサブドメイン内で、さらにお好みに合わせてモジュール化できますが、少なくともトップレベルではGraphQLの「メンバータイプ」ごとにモジュール化することはお勧めしません。次のようなものです：

```
+-- graphql
|   +-- object_types
| |
| |
| |
|   +-- interfaces
| | +-- ...
+-- order_type.rb
+-- product_type.rb
+-- ...
|   +-- input_types
| | +-- ...
|   +-- mutations
|   |   +-- add_product.rb
|   |   +-- delete_order.rb
|   +-- schema.rb
```

スキーマメンバーのタイプは、コードをモジュール化する際に私たちが関心を持つものではほとんどありません。我々はむしろ、ビジネス能力に応じて懸念事項を分離し、グループ化したいと考えます。非常にシンプルな状態から始め、時間をかけてこれに向かって進化させることができることを覚えておいてください。初期段階では適切なサブドメインを見つけるのはしばしば困難であり、物事は進行するにつれてよりクリアになります。それが痛み始めたときにモジュール化し、シンプルに保つことが重要です。ほとんどの場合、複雑な解決策やフレームワークは必要ありません。

### Testing

GraphQLのテストは挑戦であり、GraphQLを始めたばかりのチームが非常に難しいと感じることも多いです。GraphQLのダイナミックでカスタマイズ可能な性質は、我々のテストに自信を持つことを非常に難しくしています。実行エンジンそのもの、特にほとんどのライブラリーが提供するコンテキスト引数を考えると、予測不能さがさらに増します。GitHubでのテストについて最も重要なことは、先程取り上げたリゾルバデザインのアドバイスに従うとずっと簡単になるということでした。よくカプセル化された行動は、単純なオブジェクトとして、GraphQLリゾルバよりもずっとテストしやすく予測可能です。あなたの実際の行動がテストされている場合、残りの部分は少し楽になります。それでも、インターフェース自体をテストする必要があり、それを行う方法はいくつかあります。

#### Integration Testing

ビジネスロジックがよく分離されてテストされていても、私たちのGraphQLレイヤーのテストは依然として重要です。何しろ、GraphQLの実行エンジンはさまざまな検証と強制で結果が変更される可能性があるブラックボックスによく似ています。これに加えて、フィールドの組み合わせも予測不能な結果をもたらす可能性があります（それをできるだけ避けるために努力しています！）、他にも多くのことが考えられます。インテグレーションテストはGraphQL APIに対して行うことができるテストの中でおそらく最も簡単で安全な方法です。

クエリはスキーマ全体に及ぶことがありますが、オブジェクトのタイプ毎にテストすることは一般的にうまくいく方法です。テストについての明確な推奨事項を出すのは難しいですが、通常、オブジェクトのインテグレーションテストには以下のようなものが含まれます。
・このオブジェクトを返すフィールドが適切に働くテスト（このオブジェクトをnodeフィールドからフェッチする、findProductのようなfinderフィールドからこのオブジェクトをフェッチする等）
・オブジェクトの全てのフィールドをクエリするテスト、何も見逃していないことを確認します。
・フィールドごとに権限が異なる場合の特に権限テスト
これらが全てのオブジェクトに設定されていれば、すでにかなり良好なテストが行われています。

#### Unit Testing Resolvers

個々のフィールドをテストする価値はある、特にそれらがより複雑なパラメータセットを持つ場合。リゾルバーは通常シンプルな関数であり、これらは非常に簡単にテストすることが可能です。しかし、個々のリゾルバーのテストを少し困難にするかも知れないいくつかの事項を心に留めておく必要があります。まず、リゾルバーはフィールド結果がレスポンスペイロードに追加される前に追加の変換を行うことが多いです。タイプ強制は、ほぼ全てのGraphQLフレームワークが行ってくれることで、結果が変更される可能性があります。また、中間処理やプラグインが実装に追加されている場合があります。それから、コンテキストオブジェクトがあります。グローバルクエリを考慮に入れずに単一のリゾルバーにコンテキストオブジェクトを提供することはしばしば非常に困難です。最後に、リゾルバーが最初の引数として取得する親オブジェクトは、正しい方法でモックアップされるか提供されなければなりません。実際のクエリが実行された時にそれがいつも同じオブジェクトである保証はありません。

### Summary

GraphQLサーバーの実装は、現在のアーキテクチャがどのように見えるか、何の言語で構築しているか、最終的にどのGraphQLフレームワークを選択するかに大きく依存します。しかし、優れたGraphQLプラットフォームを構築しようとする人々に役立つと思われる基本原則がいくつかあります。
- 高度な拡張性（メタデータ、プラグインやミドルウェアなど）を持つコードファーストのフレームワークを推奨します
- GraphQLレイヤーを可能な限り薄く保ち、ロジックをすでにそうでない場合は独自のドメインレイヤーにリファクタリングします。
- リゾルバを可能な限りシンプルにし、グローバルな可変状態に依存しないようにしてください。
- 痛みを感じ始めたらモジュール化しましょう、魔法のような特定のフレームワークは必要ありません。モジュール性を実現するためにプログラミング言語を使用してください。
- ドメインロジックの大部分をドメインレイヤーでテストします。GraphQLサーバーに対する最適なアプローチはインテグレーションテストです。
- ランタイム条件に基づく小さなスキーマの変化のフィルタリングには可視性フィルタを使用しますが、大きく異なるスキーマを扱う場合にはビルド時に完全に異なるサーバーを構築することをためらわないでください。