## GraphQL入門
ほんの数年前、誰もがGraphQLを耳にするずっと前、別のAPIアーキテクチャがウェブAPIの分野を席巻していた： エンドポイントベースのAPIだ。
エンドポイントベースのAPIとは、HTTPエンドポイントを中心としたアーキテクチャに基づくAPIを指します。
これらは、HTTP上のJSON API、RPCスタイルのエンドポイント、RESTなどである。
これらのAPIにはいくつかの利点があった（そして今もある）。
実際、ウェブAPIに関しては、これらのAPIは今でもこの分野を支配している。
これには理由がある。
これらのエンドポイントは通常、実装が非常に簡単で、1つのユースケースに対して非常に適切に答えることができる。
慎重に設計すれば、エンドポイント・ベースのAPIは特定のユースケースに最適化することができる。
これらは簡単にキャッシュ可能で、発見可能で、クライアントが使用するのも簡単である。

近年、ウェブAPIの消費者の種類は爆発的に増えている。
以前はウェブブラウザがウェブAPIの主なクライアントだったが、今ではモバイルアプリや分散アーキテクチャの一部である他のサーバ、ゲーム機などにもAPIを応答させなければならない。
冷蔵庫だって、ドアを開けたらWeb APIを呼び出すかもしれない！
エンドポイントベースのAPIは、クライアントとサーバー間のやり取りをある機能やユースケースに最適化することに関しては素晴らしいものだ。
厄介なのは、クライアントの種類が爆発的に増えたため、多くのユースケースに対応する必要がある特定のAPIでは、これらのシナリオに対応するための優れたエンドポイントを構築するのがより複雑になったことだ。
例えば、eコマース・プラットフォームに取り組んでいて、商品ページの商品をフェッチするというユースケースを提供しなければならない場合、商品の詳細なビューをレンダリングする可能性のあるウェブ・ブラウザ、そのページの商品画像のみを表示する可能性のあるモバイル・アプリ、そして電線上に多くのデータを送信することを避けるためにデータの非常に最小限のバージョンを持つ可能性のある冷蔵庫を考慮しなければならない。
このようなケースで結局起きるのは、私たちが画一的なAPIを作ろうとすることだ。

## ワンサイズ・フィット・オール
One-Size-Fits-All APIとは何か？
それは、あまりにも多くのユースケースに答えようとするAPIのことだ。
私たちが望んでいたように最適化され始めたAPIは、共通のユースケースを利用する多くの異なる方法に適応できなかったために、非常に汎用的なものになってしまった。
API開発者にとって、APIは異なるクライアントと結合しているため管理が難しく、時にはサーバー上でメンテナンスするのが面倒になる。

これはエンドポイントベースのAPIではかなり一般的な問題となり、時にはREST APIだけが原因とされることもあった。
(実際には、RESTは特に責められるべきものではなく、この問題を回避する方法を提供している）。
この問題に直面したウェブAPIは、様々な方法で対応した。
あるAPIは最も単純な解決策、つまりエンドポイントを増やすこと、1つのバリエーションにつき1つのエンドポイントを追加することで対応した。

例えば
エンドポイントベースのAPIを考えてみましょう： 

```
GET /products
```

このユースケースのゲーム機バージョンを提供するために、あるAPIは以下の方法で問題を解決した：

```
GET api/playstation/products
GET api/mobile/products
```

十分に大規模なウェブAPIでは、このアプローチで何が起こったか想像がつくかもしれない。
同じユースケースのバリエーションに答えるために使われるエンドポイントの数が爆発的に増え、開発者にとってAPIを推論するのが非常に難しくなり、変更に対して非常にもろくなり、一般的にメンテナンスや進化に手間がかかるようになった。
誰もがこのアプローチを選んだわけではない。
ユースケースごとに1つのエンドポイントを維持しつつ、特定のクエリパラメータを使用できるようにすることを選択した人もいた。
最も単純なレベルでは、これは我々が必要とするクライアントのバージョンを選択するための非常に特定のクエリパラメータである可能性があります：

```
GET api/products?version=gaming
GET api/products?version=mobile
```

その他、パーシャルなど、より一般的なアプローチもあった：

```
GET api/products?partial=full
GET api/products?partial=minimal
```

そして、クライアントがサーバーから返したいものを選択できるようにすることで、より一般的なアプローチを選択したものもある。
JSON:APIの仕様では、これらをスパースフィールドセットと呼んでいる：

```
GET api/products?include=author&fields[products]=name,price
```

クエリ・パラメータにクエリ言語を作成するところまで行ったものもある。
GoogleのDrive APIにインスパイアされた例を見てみよう：

```
GET api/products?fields=name,photos(title,metadata/height)
```

今回取り上げたすべてのアプローチは、それぞれトレードオフの関係にある。
これらのトレードオフのほとんどは、最適化（エンドポイントが単一のユースケースにどれだけ最適化されているか）とカスタマイズ（エンドポイントが異なるユースケースやバリエーションにどれだけ適応できるか）の間に見出されます。
本書では、この点についてさらに詳しく説明する。

これらのアプローチのほとんどはクライアントを満足させることができるが、API開発者としては必ずしもベストなメンテナンスとは言えず、クライアント開発者にとってもサーバ開発者にとっても理解しにくいものになってしまう。
2012年頃、様々な企業がこの問題に直面し、多くの企業が優れた開発者体験を持つ、よりカスタマイズ可能なAPIを作る方法を考え始めた。
では、彼らがどのようなAPIを作ったのか見てみよう。

## 過去に戻ろう

### NetFlix

2012年、NetflixはAPIの完全な再設計を発表した。その変更に関するブログ投稿で、彼らは次のように述べている：

```
ネットフリックスは、従来のワンサイズ・フィット・オール（OSFA）のREST APIアプローチに大きな限界があることに気づきました。
その結果、完全にカスタマイズ可能な新しいAPIに移行しました。
```

800以上の異なるデバイスをサポートしなければならなかったこと、
そして、今読んでいただいたいくつかのアプローチのフォールバックを知っていれば、彼らがこの問題に対するより良い解決策を探していたとしても、それほど驚くことではない。
この投稿では、我々がどこから来たのかを理解するために重要なことにも触れている：

```
効果的ではあるが、OSFAアプローチの問題点は、API消費者ではなくAPI提供者の利便性を高めることに重点が置かれていることだ。
```

Netflixのソリューションは、一般的なクライアントレイヤーとサーバーレイヤーの間に新しい概念的なレイヤーを設け、
クライアント固有のコードをサーバー上でホストするものだ。

これは、カスタムエンドポイントをたくさん書いているように聞こえるかもしれないが、
このアーキテクチャによって、サーバー上でより管理しやすくなっている。
彼らのアプローチでは、サーバー・コードが "コンテンツの収集"（データの取得、必要なサービスの呼び出し）を行い、アダプター・レイヤーがクライアント固有の方法でデータをフォーマットする。
開発者のエクスペリエンスという点では、
これによってAPIチームはクライアント開発者にある程度のコントロールを返すことができ、クライアント・アダプタをサーバ上で構築することができる。
面白い事実：彼らはこのアプローチが気に入ったので、「サーバーで実行されるクライアント・ベース・コードを含むAPIプラットフォーム」というかなり一般的な名前で特許を申請した。

### SoundCloud

当時、同じような悩みを抱えていた会社があった： SoundCloudだ。
モノリシックなアーキテクチャからよりサービス指向のアーキテクチャに移行する中で、彼らは既存のAPIに悩まされ始めた：

```
しばらくすると、新機能を追加するのに必要な時間や、プラットフォームのニーズの違いという点で、問題が出てきた。
モバイルAPIでは、例えばウェブAPIよりもペイロードのフットプリントやリクエスト頻度を小さくするのが賢明だ。
既存のモノリスAPIはこれを考慮しておらず、モバイルのニーズを知らずに別のチームによって開発されていた。
そのため、アプリが新しいエンドポイントを必要とするたびに、まずフロントエンド・チームがバックエンド・チームにこれが本当にそうであることを納得させる必要があり、それからストーリーを書き、優先順位をつけ、選び、開発し、フロントエンド・チームに伝える必要があった。
```

ピンときただろうか？
これはNetflixが解決しようとしていた問題や、この章の前半で説明したカスタマイズ・ソリューションを実装することで起こりうる問題と非常によく似ている。
メインAPIに高度なカスタマイズオプションを追加する代わりに、ユースケースごとに独自のAPIサーバーを用意することにしたのだ。
考えてみれば、これは非常に理にかなっている。
これによって開発者は、エンドポイントベースのAPIが得意とする他のユースケースを気にすることなく、それぞれのユースケースを効果的に最適化することができる。
彼らはこのパターンを "Backends for Frontends"（BFF）と呼んでいる。
Thoughtworksの素晴らしいケーススタディには、このパターンの素晴らしい視覚化が含まれている。
ご覧のように、これは各BFFが1つ、あるいは多くの似たような経験を扱うようにするもので、開発者は1つのユースケースのために管理可能なAPIを書くことができ、汎用的な "One-Size-Fits-All "APIを書くという罠に陥るのを避けることができる。

### Enter GraphQL

2015年9月、Facebookは公式にGraphQLのリリースを発表し、それ以来その人気は急上昇している。
しかし、これまで取り上げてきた他のソリューションの後では驚かないかもしれないが、FacebookがAPIを扱う方法を再考し始めたのは2012年のことだ。
彼らは、非常によく似たコンセプトに不満を抱いていた：

```
私たちは、アプリで使用したいデータと、それらが必要とするサーバー・クエリとの違いに不満を感じていました。
私たちは、データをリソースURL、セカンダリキー、結合テーブルという観点で考えていません。
私たちは、オブジェクトのグラフと、NSObjectsやJSONのようなアプリで最終的に使用するモデルという観点で考えています。
また、データを準備するサーバーと、それを解析するクライアントの両方で、かなりの量のコードを書かなければならなかった。
```

当然のことながら、フェイスブックもよく似た問題と戦っていた。
繰り返しになるが、これらの引用には、よりクライアントにフォーカスした、エクスペリエンス主導のAPIの必要性が見て取れる。
この本を読んでいる間、これらの問題を思い出し、そしてGraphQLが単に1つの解決策であることを忘れないでください。
単にHTTPエンドポイントベースのAPIからの置き換えでもなければ、「次のREST」でもありません。
そうではなく、エクスペリエンスベースのAPIを構築し、クライアントとサーバーの境界を再定義しつつ、サーバーサイドの正気を保つという信じられないような課題に取り組む必要があるAPIを構築するための素晴らしいソリューションだと考えてください。
それを念頭に置いて、GraphQLを探求してみよう！

では、GraphQLとは何か？それを紹介する良い方法は、それが何でないかを見ることかもしれない：

- GraphQLはグラフデータベースの一種ではない
- GraphQLはライブラリではない
- GraphQLはグラフ理論に関するものではない

代わりに私が好きな表現方法を紹介しよう：
GraphQLはAPIクエリ言語と、そのようなクエリを実行できるサーバーエンジンの仕様である。
この時点では、GraphQLが何なのかを本当に理解するには少し漠然としすぎているかもしれませんが、心配しないで、例から始めましょう。
すでにGraphQLの概念に精通している方は、遠慮なく次の章にジャンプしてください。

## Hello World
これはGraphQLの「hello world」である。
現在のユーザーとその名前を尋ねるクエリーです。
このクエリでは、meとnameをフィールドと呼びます。
```gql
query {
  me {
    name
  }
}
```
クライアントはこのようなリクエストを、通常は単純な文字列としてGraphQLサーバーに送信する。
この場合、GraphQLサーバーから返ってくるレスポンスは以下のようになります：

```json
{
  "data": {
    "me": {
      "name": "Marc"
    }
  }
}
```

レスポンスとクエリが非常によく似た形をしていることに注目してほしい。
成功したGraphQLレスポンスには必ずデータキーがあり、その下にクライアントが探しているレスポンスがあります。
GraphQLでは、クライアントは単一のフィールドまで要件を定義できるため、必要なものを正確にフェッチすることができます。
単純なフィールドをフェッチするだけではありません：

```gql
query {
  me {
    name
    friends(first: 2) {
      name
      age
    }
  }
}
```

上のクエリでは、私の名前だけでなく、友人の最初の2人の名前と年齢も取得しています。
ご覧のように、複雑な関係をたどることができます。また、フィールドは引数を取ることができることもわかりました。
実際、フィールドは関数のようなものだと考えることができます。
フィールドは引数を取り、ある型を返すことができます。どのようなレスポンスが返ってくるかわかりますか？

```json
{"data": {
  "me": {
    "name": "Marc",
    "friends": [
      {
        "name": "Robert",
        "age": 30 
      }, 
      {
        "name": "Andrew",
        "age": 40 
      }
    ]
  }
}}
```

クエリの開始として表示される特別なクエリキーワードは、通常のフィールドではありません。
これはGraphQLサーバーに、スキーマのクエリールートからクエリーしたいことを伝えます。
この時点で疑問に思うかもしれないが、クライアントはどうやってこれが有効なクエリになることを知ったのだろうか？
あるいは、サーバーはどのようにしてこれが可能であることを表現したのだろうか？

## タイプシステム

GraphQLサーバーの中核には、API機能を表現するのに役立つ強力な型システムがあります。
実際、GraphQLエンジンの型システムはしばしばスキーマと呼ばれます。
スキーマを表現する一般的な方法は、GraphQLスキーマ定義言語（SDL）を使用することです。
SDLはGraphQLスキーマの標準的な表現であり、仕様できちんと定義されています。
SDLはGraphQLスキーマを表現するための素晴らしいツールであるため、本書ではスキーマの例を説明するためにSDLを使用します。
SDLのすばらしいところは、言語にとらわれないことです。
どの言語でGraphQL APIを実行していても、SDLは最終的なスキーマを記述します。
スキーマはこんな感じです：

```gql
type Shop {
  name: String!
  # Where the shop is located, null if online only. location: Location
  products: [Product!]!
}

type Location {
  address: String
}

type Product {
  name: String!
  price: Price!
}
```

### Types & Fields

GraphQLスキーマの最も基本的で重要なプリミティブはオブジェクトタイプです。
オブジェクトタイプは、GraphQL APIにおける1つの概念を記述します。
それ自体だけでは、それほど有用ではありません。
オブジェクト・タイプを完全なものにするのは、フィールドを定義するときです。
先ほどの例では、3つのフィールドを定義するShopタイプを定義しました。

fieldName： 型の構文によって、フィールドに戻り値の型を与えることができます。
例えば、Shopタイプのnameフィールドは、Shopの名前であるStringを返します。
通常、GraphQLフィールドを単純な関数と比較すると便利です。
フィールドはGraphQLサーバーによって実行され、その戻り値の型に正しくマッピングされた値を返します。
String型はユーザー定義ではありません。
これはGraphQLの定義済みスカラー型の一部です。
しかし、GraphQLの本当の力は、それ自身のオブジェクト型を返すことができるファクトフィールドにあります：

```gql
  location: Location
```

ShopのLocationフィールドは、スキーマが定義するLocation型を返す。
Location型でどのようなフィールドが利用できるかを見るには、Location型の定義を見なければならない：

```
type Location {
  address: String!
}
```

Locationタイプは、単に1つの住所フィールドを定義し、Stringを返します。
このフィールドは文字列を返す。
フィールドがそれ自身のオブジェクト・タイプを返すことができるという事実が、このような驚くべきクエリを強力にしている：

```gql
query {
  shop(id: 1) {
    location {
      address
    }
  }
}
```

GraphQLサーバーがこのようなクエリを実行できるのは、クエリの各レベルで、定義されたスキーマに対してクライアントの要求を検証できるからです。
この視覚化は役に立つかもしれない：

```gql
query {
  # 1. The shop field returns a `Shop` type.
  shop(id: 1) {
    # 2. field location on the `Shop` type 
    # Returns a `Location` type.
    location {
      # 3. field address exists on the `Location` type 
      # Returns a String.
      address
    }
  }
}
```
このクエリには、まだ奇妙な点がある。ShopタイプにLocationフィールドがあり、LocationタイプにAddressフィールドがあることはわかっています。
しかし、ショップフィールドはどこから来ているのでしょうか？

### Schema Roots

おわかりのように、GraphQLスキーマは、その能力を記述する型とフィールドを使用して定義することができる。
しかし、クライアントがこの能力の「グラフ」を照会し始めるにはどうすればいいのだろうか？
どこかにエントリーポイントがなければならない。
これが「スキーマの根」の出番だ。
GraphQLスキーマは常にクエリールートを定義しなければならない。
通常、この型をQueryと呼ぶ：

```gql
type Query {
  shop(id: ID): Shop!
}
```

クエリータイプは、GraphQL APIをリクエストするたびに暗黙的にクエリーされます。
例えば、このクエリです：

```gql
{
  shop(id: 1) {
    name
  }
}
```

上記は有効なGraphQLクエリです。
なぜなら、最初にQueryタイプを返す特定のフィールドをクエリしていないにもかかわらず、Queryルート上のshopフィールドを暗黙的に要求しているからです。
クエリルートはGraphQLスキーマ上で定義されなければなりませんが、他にも2つのタイプのルートを定義することができます。
これらについてはこの章の後半で説明します。

Arguments

クエリールートのショップフィールドが特別なことにお気づきだろうか。

```gql
type Query {
  shop(id: ID!): Shop!
}
```

関数と同様に、GraphQLフィールドは、GraphQLサーバーがフィールドの実行時解決に影響を与えるために使用できる引数を定義できます。
これらのフィールドはフィールド名の後の括弧の間に定義され、好きなだけ持つことができます：

```gql
type Query {
  shop(owner: String!, name: String!, location: Location): Shop!
}
```

引数もフィールドと同様、スカラー型か入力型を定義することができる。
入力型は型に似ていますが、inputキーワードを使って別の方法で宣言します。

```gql
type Product {
  price(format: PriceFormat): Int!
}

input PriceFormat {
  displayCents: Boolean!
  currency: String!
}
```

### Variables

引数の話題のついでに、GraphQLクエリーはクエリー内で使用する変数を定義することもできることに注意するとよいでしょう。
これにより、クライアントはクエリ文字列自体に直接変数を含めるのではなく、クエリとともに変数を送信し、GraphQLサーバーに実行させることができます：

```gql
query FetchProduct($id: ID!, $format: PriceFormat!) {
  product(id: $id) {
    price(format: $format) {
      name
    } 
  }
}
```

また、クエリにFetchProductという操作名を与えていることに注意してください。
クライアントはこのクエリーを変数とともに次のように送信します：

```json
{
  "id": "abc",
  "format": {
    "displayCents": true,
    "currency": "USD"
  }
}
```

### Aliases

サーバーはフィールドの正式名称を指定しますが、クライアントはこれらのフィールドを別の名前で受け取りたい場合があります。
この場合、フィールド・エイリアスを使うことができます：

```gql
query {
  abcProduct: product(id: "abc") {
    name
    price
  } 
}
```

この例では、クライアントはproductフィールドを要求しますが、abcProductエイリアスを定義します。
クライアントがこのクエリを実行すると、abcProductという名前のフィールドが返されます：

```json
{
  "data": {
    "abcProduct": {
      "name": "T-Shirt",
      "price": 10,
    } 
  }
}
```

これは、同じフィールドを異なる引数で複数回リクエストする場合に便利である。

### Mutations

これまで、クライアントがGraphQL APIから読み取り専用の情報を照会する方法に関する情報を取得できるようにするGraphQL Schemaプリミティブを多く取り上げてきました。
ある時点で、多くのAPIはデータの書き込みや変更を必要とする機能を追加したくなるでしょう。
GraphQLはこの目標を達成するために変異の概念を定義します。
この章の前半で発見したクエリールートと同様に、スキーマの変異への「エントリーポイント」はMutation*ルートの下にあります。
GraphQLクエリでこのルートにアクセスするには、クエリのトップレベルにmutationキーワードを含めます：

```gql
mutation {
  addProduct(name: String!, price: Price!) {
    product { 
      id
    } 
  }
}
```

このaddProduct変異は、フィールドを定義するのとよく似た方法で定義できる。を定義するのと同じ方法で定義できます：

```gql
type Mutation {
  addProduct(name: String!, price: Price!): AddProductPayload
}

type AddProductPayload {
  product: Product!
}
```

ご覧の通り、突然変異はほとんどクエリーフィールドと同じです。
わずかに異なる点が2つあります：

- ミューテーションルートの下にあるトップレベルフィールドは、副作用を持ったり、変更を加えたりすることが許可されています。
- トップレベルの変異フィールドはサーバーによってシリアルに実行されなければなりません。

残りは同じで、変異が行われた後にクライアントがクエリーできるように、引数を取り、戻り値の型を持つ。
この後の章では、優れた変異を設計する方法について詳しく説明します。

### Enums

GraphQLスキーマを使えば、かなり強力な方法でインターフェースを設計することができる。
フィールドが異なる値のセットを返すことがあり、通常のスカラーがクライアントにとって最も説明的でない場合があります。
このような場合、Enum型を使用すると便利です：

```gql
type Shop {
  # The type of products the shop specializes in 
  type: ShopType!
}
enum ShopType {
  APPAREL
  FOOD
  ELECTRONICS
}
```

列挙型は、スキーマが、フィールドの場合は返す値、引数の場合は渡す値のセットを明確に定義することを可能にする。
これらは、クライアントが使いやすいAPIを定義するのに非常に便利である。

### Abstract Types

抽象型は多くの言語の一部であり、GraphQLも同様です。抽象型により、クライアントはフィールドの戻り型が特定の動作をすることを期待できますが、実際の型（通常は具象型と呼びます）を返すことはありません。
フィールドの抽象型を返すには、主にインターフェースとユニオンの2つの方法があります。
インターフェースでは、それを実装した具象型が答えなければならない契約を定義することができる。
この例を見てみよう：

```gql
interface Discountable {
  priceWithDiscounts: Price!
  priceWithoutDiscounts: Price!
}
type Product implements Discountable {
  name: String!
  priceWithDiscounts: Price!
  priceWithoutDiscounts: Price!
}
type GiftCard implements Discountable {
  code: String!
  priceWithDiscounts: Price!
  priceWithoutDiscounts: Price!
}
```

ここでは、Discountableインタフェースを実装したProduct型がある。
これは、Product型が2つのDiscountableフィールドを定義しなければならないことを意味します。
これにより、他のフィールドがDiscountableを直接返すことができ、クライアントは実行時にどの具象型が返されるかを知ることなく、その契約のフィールド部分を結果上で直接要求できることを知ることができます。
例えば、Discountableのインターフェイス型を直接返すことで、ProductまたはGiftCardのいずれかの型のリストを返すdiscountItemsフィールドを持つことができます。

```gql
type Cart {
  discountedItems: [Discountable!]!
}
```

すべてのタイプはディスカウント可能な契約に回答することが期待されているため、クライアントは直接2つの価格フィールドを要求することができます：

```gql
  query {
    cart {
      discountedItems {
        priceWithDiscounts
        priceWithoutDiscounts
      }
    }
  }
```

クライアントが他のフィールドを問い合わせたい場合、
どの具象型に対して選択したいかを指定しなければならない。
これにはフラグメントスプレッドか型付きフラグメントを使用します：

```gql
query { 
  cart {
    discountedItems {
      priceWithDiscounts
      priceWithoutDiscounts
      ... on Product {
        name
      }
      ... on GiftCard {
        code
      } 
    }
  }
}
```
ユニオン・タイプは少し違う。
ユニオン・タイプは、特定のコントラクトを定義するのではなく、フィールドが返す可能性のあるさまざまなオブジェクトをまとめたものです。
これらはunionキーワードを使って定義します：

```gql
union CartItem = Product | GiftCard
type Cart {
  items: [CartItem]
}
```

これはコントラクトを定義せず、そのフィールドから返される可能性のある具象型を定義するだけなので、クライアントはすべてのケースで期待される具象型を指定しなければならない：

```gql
query {
  cart {
    discountedItems {
      ... on Product {
        name
      }
      ... on GiftCard {
        code
      }
    }
  }
}
```

抽象型はGraphQLスキーマにおいて非常に有用であることが多いですが、簡単に悪用されることもあります。次の章で詳しく説明します。

### Fragments

具体的な型を選択するために使用していた ... on プロダクトは、GraphQLではインラインフラグメントと呼ばれます。
インラインフラグメントは、フラグメントと呼ばれるGraphQLクエリ言語コンセプトの特定のバージョンです。
フラグメントにより、クライアントはクエリの一部を定義して別の場所で再利用することができます：

```gql
query {
  products(first: 100) {
    ...ProductFragment
  }
}

fragment ProductFragment on Product {
  name
  price
  variants
}
```

フラグメントは fragment キーワードで定義します。このキーワードは名前と適用する場所（この場合は Product）を指定します。

### Directives
スキーマ定義言語で最後に取り上げるのはディレクティブだ。ディレクティブは、さまざまなGraphQLプリミティブで使用できる注釈の一種です。
GraphQL仕様では、本当に便利な2つの組み込みディレクティブを定義している： 
@skipと@includeです。

```gql
query MyQuery($shouldInclude: Boolean) {
  myField @include(if: $shouldInclude)
}
```

この例では、@includeディレクティブは、変数shouldIncludeがtrueのときだけmyFieldフィールドがクエリされるようにします。
ディレクティブは、GraphQLサーバーの実行動作を変更できる方法でフィールドに注釈を付ける方法をクライアントに提供します。
上で見たように、ディレクティブはフィールドのように引数を受け取ることもできます。
カスタムディレクティブを追加することも可能です。
まず、ディレクティブの名前を定義し、適用する場所を決定する必要があります。

```gql
"""
Marks an element of a GraphQL schema as
only available with a feature flag activated 
"""
directive @myDirective(
  """
  The identifier of the feature flag that toggles this field. 
  """
  flag: String
) on FIELD
```

そして、このディレクティブはクライアントが使用することができる：

```gql
query {
  user(id: "1") @myDirective {
    name
  }
}
```

ディレクティブはクエリに適用することもできますが、型システムに直接使用することもできるので、スキーマにメタデータを付与するのにとても便利です：

```
"""
Marks an element of a GraphQL schema as
only available with a feature flag activated
"""
directive @featureFlagged(
  """
  The identifier of the feature flag that toggles this field. 
  """
  flag: String
) on OBJECT | FIELD_DEFINITION
```

そして、このディレクティブはスキーマのメンバに直接適用することができます：

```gql
type SpecialType @featureFlagged(flag: "secret-flag") {
  secret: String!
}
```

### Introspection

GraphQLの型システムの背後にある真の特別な力は、そのイントロスペクション機能です。
GraphQLでは、クライアントはGraphQLスキーマにクエリー可能なものを尋ねることができます。
GraphQLスキーマにはイントロスペクションのメタフィールドが含まれているため、クライアントはその型システムに関するほとんどすべてを取得することができます：

```gql
query {
  __schema {
    types {
      name
    }
  }
}
```

```json
{
  "data": {
    "__schema": {
      "types": [
        {
          "name": "Query"
        },
        {
          "name": "Product"
        },
      ]
    }
  }
}
```

これはクライアントがユースケースを発見するのに役立つだけでなく、驚くべきツールの作成を可能にする。
例えば、インタラクティブなGraphQLプレイグラウンドであるGraphiQLは、イントロスペクションのおかげで、ユーザーがGraphQLクエリをテストしたり、GraphQL APIのリファレンスを表示したりすることを可能にします。
これはGitHubのGraphQL開発者向けドキュメントからの例です：

image

しかし、それだけにとどまらない。
イントロスペクションは、クライアントが事前にコードを生成してクエリを検証するために使用され、IDEがアプリの開発中にクエリを検証するために使用され、その他多くのツールで使用されています。
イントロスペクションは、GraphQLエコシステムが急速に成長している大きな理由です。

### Summary

クライアントが要件を表現するためのクエリ言語、サーバーが可能性を表現するための型システム、そしてクライアントがこれらの可能性を発見できるようにするイントロスペクションシステムによって、GraphQLはAPIプロバイダーがクライアントが望む方法で利用できるスキーマを設計することを可能にする。
これらの機能は、本書で取り上げるツールの素晴らしいエコシステムもサポートしています。GraphQLとその型システムについての詳細がわかったところで、次はGraphQLサーバーの構築方法について説明します。