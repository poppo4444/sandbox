# Migrating From Other API Styles(他のAPIスタイルからの移行)


GraphQLはブロックの新顔であるため、多くのチームや企業が既存のAPIスタイルから自分たちのニーズに合っていることに気づいている（あるいは単に流行に乗っている）のを目にする。
この事実は、GraphQLが発表されて以来、多くの投稿で取り上げられてきた。
やり方はたくさんあるので、よくある状況をいくつか取り上げてみよう。

## Generators


GraphQLに移行するための非常に魅力的なアプローチは、他のAPIスタイルからスキーマやAPI定義を取得し、GraphQLスキーマへの変換を自動化しようとすることだ。
例えば、openapi-to-graphqlはIBMの研究グループによって作られたツールで、OpenAPI定義を有効なGraphQLスキーマに変換します。

これらは、絶対に必要なときには役に立つと思う。
しかし、APIのスタイルが異なれば、本質的に設計上の懸念も異なるため、これらのツールが理想的な仕事をすることはほとんどない。
このOpenAPI定義は、単一のパスを定義し、クライアントがHTTP動詞を使用して記事を公開したり公開解除したりできるようにするもので、HTTP、エンドポイントベースのAPIでは一般的なパターンだ。

```
paths:
  /articles/{id}/published:
    put: # The put operation publishes an article
    delete: # The delete operation unpublishes an article
```

ツールでこれを有効なGraphQLスキーマに変換するのは難しい。
私たちがGraphQLで望んでいるのは、おそらくこのような、よりRPC指向のアプローチだろう：

```gql
type Mutation {
  publishArticle(articleId: ID!): PublishArticlePayload
  unpublishArticle(articleId: ID!): UnpublishArticlePayload
}
```
これはほんの一例に過ぎないが、APIのスタイルが異なれば異なる設計が必要になることがお分かりいただけるだろう。
このような理由から、選択肢があり、時間を投資できるのであれば、RESTインターフェイスを直接GraphQLインターフェイスに変換するよりも、ユースケースを見てGraphQLインターフェイスに変換することで、APIをGraphQLに移行することを好む。
これらのツールはかなり遠くまで行くことができるが、本当によく設計された "GraphQL-native "APIを望むのであれば、常に人間の手を必要とする。

## REST & GraphQL Alongside(RESTとGraphQL)

GraphQLは必ずしもRESTを置き換えるためにあるのではなく、異なる文脈で異なる課題に取り組むための新しい方法である。
つまり、プロバイダーが必ずしもREST APIをGraphQL APIに置き換えるとは限らず、少なくともしばらくの間は両方を維持することも間違いなくあり得るということだ。
私はこの問題を解決するための複数のアプローチを見る機会があった。

### GraphQL backed by REST(RESTに支えられたGraphQL)

RESTに裏打ちされたGraphQL
RESTとGraphQLの間の移行、または両方の維持について耳にする主な方法は、既存のREST API上にGraphQL APIを構築することです。
実際、これは異なるRESTエンドポイントを呼び出すことで解決されるGraphQLスキーマを構築することを意味します。
私の経験では、パフォーマンスが維持されている限り、これは一般的に良いパターンである。
パフォーマンスの章で見たのと同じ読み込みの問題が、リゾルバがエンドポイントを呼び出すときに起こり得る。
これは、素朴に実装するとひどいパフォーマンスになる可能性があり、REST APIですでに利用できない場合は、カスタムバッチエンドポイントを構築しなければならないことがよくある。

GraphQLスキーマを構築する際には、現在のURL構造を超えて考えることを忘れないでください。
GraphQLタイプがRESTエンドポイントと1対1のマッピングにならない可能性は大いにあります。
また、特定のフィールドや型がREST呼び出しの組み合わせによって解決される可能性もあります。


### REST backed by GraphQL(RESTをGraphQLでバックアップ)

GitHub で REST API と GraphQL API の両方を維持するために当初使用していたもうひとつのソリューションは、REST API のエンドポイントを静的な GraphQL クエリでバックアップすることでした。
両方のAPIが同じモノリス内に存在するため、RESTエンドポイントはそのニーズを表す静的なGraphQLクエリを構築し、リクエストごとにGraphQLエンジンを介してクエリを実行するように変更されました。
これはネットワーク呼び出しではなく、単にRESTエンドポイントがコード内で、事前に定義されたリクエストでGraphQLを呼び出していることに注目してください。

GraphQLを真実のソースとして使用しているため、これは最初は素晴らしく聞こえるが、一定のコストがかかる。実際、私はもうこのアプローチを推奨していない。
まず、既存のRESTエンドポイントに合うようにGraphQLスキーマを設計したいという強い誘惑がある。
ジェネレーターと同じように、RESTペイロードの設計を単純にGraphQL APIにコピーしないように非常に注意しなければなりません。
それだけでなく、例えばGraphQLエラーを正しいステータスコードに変換するなど、エラー変換の非常に複雑なダンスが必要になります。

もうひとつ気をつけなければならないのは、GraphQLを呼び出すことでロジックを "再利用 "しているような印象を与えてしまうことだ。
理想的な世界では、RESTとGraphQLはどちらも単なるインターフェースであるため、多くを共有することはないだろう。
もしこのテクニックがあなたにとって魅力的だとしたら、それはあなたのGraphQLリゾルバが再利用したくなるようなロジックをたくさん含んでいるからかもしれない。

ではどうすればいいのだろうか？
RESTにGraphQLをコールダウンさせる代わりに、RESTとGraphQLの両方を独立したインターフェースにし、優れたドメイン/ビジネスレイヤーにコールダウンさせる！
これはRESTのような単一のインターフェイスを扱うときにはすでに有用だが、UI、REST API、GraphQL APIを扱うときには非常に重要になる。
ドメインロジックがうまく分離され再利用可能でなければ、GraphQLリゾルバのようにどこかに集中させるか、すべてのインターフェースレイヤーで同じことを繰り返すことになり、矛盾やバグを引き起こすことになる。
物事を2回書くことは、望まないカップリングを導入し、APIが進化したときに後で噛みつかれるようなソリューションを選ぶより、はるかに良い考えであることが多い。

## Summary

GraphQLとRESTの両方を移行または維持するための多くの実用的なソリューションがあります。
ここでのキーポイントは、新しいGraphQL APIをREST APIのGraphQLバージョンとして見るのではなく、ドメインとユースケースに対する新しいGraphQLインターフェイスとして見ることです。

REST上のGraphQLは良いパターンですが、N+1問題やその他のパフォーマンス問題に注意してください。RESTエンドポイントをGraphQLにコピーするのではなく、ユースケースを考え、それを解決するためにGraphQL APIを設計する。
コードの再利用が問題になる場合は、REST APIまたはGraphQL APIのどちらかにロジックを集中させないようにし、このロジックには別のレイヤーを探しましょう。この解決策としては、ドメイン駆動設計を参考にすることをお勧めします。

# Closing Thoughts

終わりに
GraphQLは今ここにとどまりつつあり、それには理由がある。私たちにはまだ長い道のりがありますが、進化可能で信頼できるGraphQLサーバーを作るためのこの旅が、強力なGraphQLプラットフォームをサポートする助けになることを願っています。
そもそもAPIを構築する理由は、オーディエンスやクライアントのユースケースを解決するためであることを常に忘れないでください。
この目的を念頭においておくことが、最終的にAPIの設計、さらには実装の原動力となります。
どのようなAPIスタイルやデザインも、すべてのコンテキストにおいて完璧ということはない。
GraphQLが最適である状況に対して、本書が優れたGraphQL APIを構築する際の意思決定の指針となるようなトラックを提供できたことを心から願っています。