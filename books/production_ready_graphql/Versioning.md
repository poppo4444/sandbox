# Versioning

バージョニングは、おそらくAPIに関する最も多くの質問の引き金となるトピックの1つであり、最も多くの論争と白熱した議論をもたらすものです。
GraphQL APIのバージョニングはどのように行うのでしょうか？
最近最も一般的な答えは「しない」だ。最初にそれを読んだときの私のように、バージョンレスのAPIを維持することに少し不安を感じたり、そのアプローチに少し懐疑的になったりするかもしれない。
実際、これは一般的な答えであるだけでなく、GraphQL graphql.orgのランディングページの主な特徴として挙げられている。
graphql.orgを読むと、これはGraphQL特有の機能のように見えるかもしれないが、実際には、バージョン管理なしでAPIを進化させることは、RESTやHTTP APIではすでに頻繁に推奨されていることだ。
実際、Roy Fielding自身があるカンファレンスで、REST APIのバージョニングのベストプラクティスはそれを行わないことであると発言したのは有名な話です。
この章では、APIのバージョニング全般を探求し、どの進化アプローチがGraphQL APIにとって最も理にかなっているかを試してみます。

## API Versioning is Never Fun

APIを全くバージョン管理しないという考え方がどこから来ているのかを理解する良い方法は、ウェブAPIが一般的にどのようにバージョン管理されているかを見ることだ。
実際のところ、どのようなアプローチを選ぶにしても、私たちはトレードオフを受け入れることになる。おそらく最も一般的なアプローチは、APIをグローバルにバージョン管理することだろう。
v1、v2、v3......と、インテグレーターにとって壊れる可能性のある変更を加えるたびに、私たちは考えます。
このアプローチでは、既存の顧客がこれらの変更によって壊れることはありませんが、深刻な問題を伴います：

- 新しいメジャーバージョンをリリースするたびに、旧バージョンのクライアントはすべて取り残され、新しい変更のためにアップグレードを余儀なくされます。
- ほとんどのプロバイダーは、メジャーバージョンの変更をあまり行わないようにしています。そのため、新しいバージョンがデプロイされると、多くの変更点が盛り込まれ、クライアントが理解するのが難しくなり、基本的にAPIをゼロから再統合するのが難しくなることが多い。
- APIプロバイダーは、古いバージョンのAPIを永遠にサポートし続けるか、複雑さを増すか、古いバージョンに固執しているクライアントを壊し始めるかのどちらかを選ぶ必要がある。

実際には、このグローバル・バージョニングはさまざまな方法で行われる：

- URLの場合：v1/ユーザー、v2/ユーザー： URLを使ったグローバルなバージョニングは、しばしば、新しいURLのバージョンのもとで、新しいリソースが爆発的に増えることにつながります(ほとんどのリソースは変更されていないにもかかわらず)。これは、時間とともに膨大な量のURLをサポートすることにつながります。これはキャッシュとは相性が悪く、クライアントはしばしばすべてを書き換える必要がある。なぜなら、既存のv1リソースがv2でうまく動作するかどうかを信頼できないからだ。
- ヘッダーを使用する： Stripe-Version: 2019-05-25。ヘッダーベースのアプローチでは、バージョン間の変更をより小さくしようとすることが多いが、全体的な問題点として はまだ残っている。プロバイダーは、複雑さをできるだけ抑えながら複数のバージョンをサポートする方法を見つける必要がある。その好例が、Stripeのバージョニングに対するアプローチだ。

全体として、グローバルなバージョニングは、実際に新しいリソースのセットやまったく異なるAPIを扱う場合に、多くの意味を持つかもしれない。
この2つのアプローチほど「グローバル」ではない代替案として、バージョニング・コンテンツ・ネゴシエーションを適用する方法がある。たとえば GitHub API では、クライアントがバージョン番号を含むカスタムメディア型を指定することができます。これは、リソースの表現についてバージョン管理を表現するにはとてもよい方法ですが、それ以外の変更については必ずしもそうとは限りません。もう一つの欠点は、クライアントがそのメディアタイプを渡すことを強制されないことで、もしそのメディアタイプがなくなると、通常は最新バージョンに戻され、ほぼ確実に統合が壊れる。GraphQLの場合、異なるHTTPリソースを扱うわけではないので、これはいずれにせよダメだ。

## Versioning GraphQL is Possible

「バージョンなし」のアプローチが推奨されることが多いとはいえ、GraphQL APIをバージョン管理することを妨げるものは何もない。
実際、Shopifyは彼らのGraphQL APIを進化させるためにURLバージョニングアプローチを採用した。

彼らのバージョニングアプローチは、グローバルなバージョニングのためにURLを使用する。
GraphQLでは、新しい識別子の下にリソースの完全な新しい階層を作成しないため、これはそれほど厄介ではありません。
よりきめ細かく、3ヶ月の長さのバージョンを使用し、典型的なグローバル・バージョニングの問題を解決します。

実際、これをうまく機能させるのはかなり難しいことです。
第3章で説明したように、複数のスキーマを管理するのは難しいことです。
バージョニングを機能させる1つの方法は、クライアントがリクエストするURLやバージョンによって全く異なるスキーマを構築することです。
これはサーバー開発者に多くのオーバーヘッドを与え、バージョン数が積み重なるにつれて、信じられないほど管理が難しくなることは想像に難くない。
その代わりに、この本で以前に説明したようなランタイムの可視化アプローチを使用して、ユーザーにスキーマの異なるバリエーションを提示することができる。
これにも多くの複雑さが伴うが、可能である。

グローバル・バージョニングで見たのと同じ種類のキャッチ22が、GraphQLにも当てはまります。このようなアプローチはすべて、クライアントの故障やプロバイダー側の信じられないような複雑さにつながるという事実から、よく推奨されるアプローチが導き出される。それは、可能な限り単純に後方互換性を目指し、可能な限り追加的な変更を選択し、変更を壊す代わりに拡張性を考えるというものだ。

このアプローチを初めて読んだときの私のように、"でも、時には変更は避けられない！"と思ったことだろう。確かに、ベスト・プラクティスに留意していても、ミスは起こりうる。しかし、これからわかるように、APIをバージョンアップしようがしまいが、いずれにせよミスは起こる。

バージョン管理は、プロバイダーとクライアントの双方に安心感を与えることが多いが、それは一般的に長続きしない。　が永遠に続くわけではない。無限のバージョンがサポートされ、サーバーサイドが際限なく複雑にならない限り、クライアントは最終的に進化する必要がある。Shopifyの例では、安定版がリリースされてから9ヶ月後にこの現象が起こる。その9ヶ月後、クライアントは、より小さな変更点を含む次の実行可能なバージョンにアップグレードするか、おそらくより多くの変更点を含む最新バージョンにアップグレードする必要がある。

## Continuous Evolution

この記事の冒頭で述べたように、バージョニングの代替案は、単にそれをしないことである。
新バージョンをカットするのではなく、ひとつのバージョンを維持し、それを常に進化させるプロセスは、しばしば「継続的進化」と呼ばれる。
この哲学を説明する私のお気に入りの方法のひとつは、フィル・スタージョンの言葉だ：

```text
APIの進化とは、APIの "I"、リクエスト/レスポンスボディ、クエリパラメータ、一般的な機能などを維持しようと努力し、絶対に、絶対に、壊さなければならない時だけ壊すという考え方だ。
それは、API開発者が契約を維持するために身を屈めることは、それがどんなに迷惑なことであっても、多くの場合、幅広いクライアントに仕事を丸投げするよりも経済的・論理的に実行可能であるという考え方だ。
```

継続的な進化を支える哲学の大部分は、契約への強いコミットメントであり、後方互換性のある方法でAPIを進化させることを目指している。
これは実現不可能な夢に聞こえるかもしれないが、多くのAPIプロバイダーは、インターフェイスを維持するための創造的な方法を見つけようとするよりも、バージョニングに落ち着いてしまう。

加法的な変更は、ほとんどの場合、後方互換性があり、賢く使えば、多くの場合、破壊的な変更を避けることができる。
加法的進化アプローチの主な欠点は、通常、命名領域とAPIの「肥大化」である。
ネーミングの問題は、そもそもネーミングを具体的にしすぎることで軽減できる。
肥大化は、特にGraphQLにおいては、クライアントに対するバージョン管理のコストよりも少ない問題だろう。
しかしそれはもちろん、APIプロバイダーが決めるべきトレードオフだ。

しかし、前述したように、やむを得ない変更もある。
すべての変更を追加で行えるわけではなく、常にブレークチェンジが必要になる瞬間がある。実際、やむを得ない変更の例をいくつか挙げてみよう：

- セキュリティの変更： あるフィールドからプライベートなデータが漏れていたり、あるフィールドのセットが決して公開されるべきではなかったことに気づいたりする。
- API設計に関連したパフォーマンスの問題： ページ分割されていないリストが何百万ものレコードを返す可能性があり、タイムアウトを引き起こしたり、レコードを壊してしまう。クライアントを破壊する。
- 認証の変更： APIプロバイダが "basic
APIクライアントはJWTに移行せざるを得ない。
- nullでないフィールドが実行時にnullになることがある。これはエラーを引き起こす。
スキーマ契約を破壊しなければ修正できない。


これら4つの例では、追加的な変更では対処できないことが多い。APIを修正するか、フィールドを削除しなければならない。
継続的な進化では、非推奨の通知、クライアントが非推奨のフィールドから離れるための期間、そして最終的な日没による変更に頼ることになる。
バージョニングは、ブレークチェンジの問題を解決するように思えるが、私たちが挙げた例を見てみると、たとえ優れたバージョニング戦略があったとしても、どれも簡単にはいかないだろう。
実際、影響を受けるすべてのバージョンでブレークチェンジを行い、非推奨事項やクライアントが離れていく期間を利用して、最終的にブレークチェンジを行う必要がある。
何かおかしいことに気づいただろうか？
バージョン管理は、継続的に進化する1つのバージョンを持つ場合と同じ作業量（同時進行するバージョンの数によっては、それ以上）を必要とするのだ。
これら全ての戦略において、APIの進化の良し悪しを決めるのは、非推奨期間をどのように過ごすかだ。
これは「変更管理」と呼ばれることもある。

## Change Management

APIのメンテナとして、どのような進化／バージョン管理プロセスを標準化するにしても、ひとつ確かなことがある。
GraphQLは、これを巧みに行うための本当に素晴らしいツールをいくつか提供してくれます。良い変更管理戦略の第一歩は、今後の変更を既存のインテグレーターに見えるようにすることです。

### Deprecations

非推奨は継続的な進化のための最高のツールだ。
このディレクティブを使うことで、APIの特定の部分に、その使用はもう推奨されない、将来的には廃止される可能性があるという印をつけることができます。
GraphQLにはそのための素晴らしいツール、@deprecatedディレクティブがあります：

```gql
type User {
  name: String! @deprecated(
    reason: "Field name is being replaced by field `username`"
  )
  username: String!
}
```

deprecatedディレクティブは、User {型から離れるときに非常に便利です。
  name: 文字列！ディレクティブ
    reason: "フィールド名はフィールド `username` に置き換えられています"
  )
  username: String！
}
将来的に利用できなくなるフィールドから削除されます。プロバイダがこの変更の理由を説明できるように、reason引数を持っています。
残念なことに、現時点ではこのディレクティブはフィールドとenum値にしか適用できませんが、近いうちに引数や入力値にも適用できるようになるでしょう。
deprecatedの大きな利点は、クライアント全体で尊重される標準であるということであり、これはツールが私たちを助けてくれることを意味する。
たとえば、GraphQLはデフォルトで非推奨フィールドを非表示にし、新しいクライアントが廃止されるフィールドにオンボードされるのを防ぎます。
GraphQLクライアントは、非推奨のスキーマ・メンバー（メンバーかメンバーか）を使用するときに警告を投げるようになり、ドキュメンテーション・ジェネレーターは自動的にこれらのメンバーに注釈を付けることもできます。

これは素晴らしいことだが、もっと良くすることはできる。私の経験では、優れた非推奨にはさらなる詳細が必要だ：

- スキーマ・メンバが削除される日付 (日没日)。
- スキーマ・メンバが削除される理由。
- そのスキーマメンバーの代替案。
- オプション：長い形式の説明へのリンク（例えばブログ記事）。

もしあなたがコードファーストのアプローチを使っているのであれば、シンプルなカスタムヘルパー内にすべての情報をエンコードすることができる：

```gql
new GraphQLObjectType({
  name: 'User',
  fields: {
    name: {
      type: GraphQLString,
      deprecationReason: deprecationReason(
        reason: "Name is going away",
        alternative: "Use `username` instead",
        sunset_date: "2030-05-01",
        link: "https://dev.gql.com/blog/user-name-deprecation",
    	)
		}
	}
})
```

deprecationReason は、非推奨メッセージの一貫性を確保し、スキーマメンバを非推奨にするときに開発者が常に必要な情報を提供できるようにするために作成したカスタム関数です。
この例では、非推奨の理由は次のようになります：

```text
Name is going away. Use `username` instead. Sunset date: 2030-05-01
For more information: https://dev.gql.com/blog/user-name-deprecation

名前はなくなります。代わりに `username` を使ってください。日没日: 2030-05-01
詳しくは：https://dev.gql.com/blog/user-name-deprecation
```

これは私たちがGitHubで使っていた戦略だ。
何百人もの開発者がGraphQLスキーマに取り組んでいるとき、このようなユーティリティが高品質で一貫性のあるスキーマを保証する。体験をインテグレーターに提供します。

### Communication

Deprecationsは変更を伝えるのに役立つが、全てのクライアントに今後の変更を認識させるには十分でないことが多い。
最高のAPIプラットフォームは、非推奨を含む様々な手段で変更を伝えることができる。そこで、すべてのクエリを追跡するというアプローチが非常に役に立つ。
GraphQLの最大の利点の1つは、プロバイダがクエリの1つ1つに至るまで、APIがどのように使用されているかを知っているという事実だ。
APIが認証されている場合、これは次のことを意味する：

- 変更しようとしているメンバーが、毎週、毎日など、何回使われているかを知っている。
- 最も重要なことは、誰がこれらのフィールドを最も使用しているかを知ることです。

変更を伝えるためにこの力を使うことは、内部プラットフォームであっても、GraphQLの大きな利点である。多くのAPIプロバイダーは、変更があるとインテグレーターにEメールを送る。
これは非常に重要なプラクティスですが、GraphQLではそれをさらに推し進めることができます。
私たちはすべてのフィールドを誰が使っているかを知っているため、影響を受ける可能性があるとわかっている個々のインテグレーターに合わせたEメールを送ることができます。
Eメールは、変更を伝えるひとつの手段に過ぎない。このデータは、例えば素晴らしい開発者ダッシュボードを構築するために使用することができます。
変更を伝えることを検討すべき他の場所をいくつか紹介しましょう：

- 開発者プラットフォームの Twitter アカウント。
- ドキュメントサイト。
- 今後の変更を告知するブログ記事。- 変更ログ。

### Last Resorts

悲しいニュースですが、非推奨のスキーマが導入され、素晴らしいコミュニケーションが行われたとしても、ごく一部のインテグレーターは、変更に対応する機会がなかったか、単にあなたのコミュニケーションを見ていなかったかのどちらかで、スキーマの非推奨の部分を使い続ける可能性があります。
どのような大規模な変更でも、おそらくいくつかのインテグレーターが壊れることになるでしょう。
繰り返しになるが、Stripeを例にとると、彼らのAPIはお金を扱っている。
そのため、インテグレーターが壊れることはほとんどなく、代わりにプロバイダー側の複雑さを軽減するようなバージョンアップ戦略に大きく偏っている。
これが、彼らが特定のバージョニング・アプローチに投資してきた理由だ。

継続的な進化を使って、最後の数人のインテグレーターを確実に代替に移行させるために使える最後の手段がまだある。
APIの "ブラウンアウト "とは、監視システム、ログ、あるいは人間が、何かが変更されたことに気づくことを期待して、一時的に変更を加える手法である。

APIが返すエラーに、修正方法に関する何らかの情報が含まれていればいいのだが：

```json
{
  "errors": [{
    "message":
      "Deprecated: Field `name` does not exist on type `User`.
      Upgrade as soon as possible.
      See: https://my.api.com/blog/deprecation-of-name-on-user"
	}]
}
```

実際には、これは通常機能トグルを使用して行われます。
非推奨のGraphQLメンバーを動的に非表示にするブラウンアウトフラグを有効にすることができます。
これはスキーマ可視化技術を使うか、リゾルバ自体にカスタムエラーを実装することで行うことができる。
ブラウンアウトセッションの後に収集しているデータを見て、使用率が下がっているかどうかを確認してください。
使用量の減少が確認できるまでこの経験を繰り返すこともできますし、使用量が多すぎるようであれば、非推奨化を再考することもできます。

では、GraphQL APIをバージョンアップすべきでしょうか？
その判断は、最終的にはあなた自身のトレードオフのセット、あなたのクライアントが何を期待しているか、そしてAPIプロバイダーとしてどのような期待を設定したいかに帰結する。
というのも、多くの場合、継続的な進化のアプローチと同じように、変更が必要なポイントがやってくるからだ。
GraphQLは、いくつかの方法で継続的な進化を手助けしてくれる：

- フィールドに関する一流の非推奨サポートがあり、ほとんどのツールはすでにその使い方を知っている。
- 追加的な変更は、既存および新規のクライアントにオーバーヘッドを与えることなく行われる。- 使用状況の追跡は、単一フィールドまで行うことができる。

これら3つの特徴により、GraphQLは継続的進化に本当に適した候補となり、それが強く推奨されている理由です。
もうひとつ心に留めておくべきことは、まず継続的進化のアプローチを選択し、その後どうしてもバージョニングが必要だと判断した場合、それは可能だということだ。しかし、その逆はずっと難しい。
それでも、継続的進化は間違いなく悪い方法で行われる可能性があることを述べておくことは重要だと感じている。
それは大きな責任であり、（やりすぎはいけないが）悪用することはできない。
だからこそ、加点的な変更は、変更を加える前に絶対的に優先されなければならないのだ。

最後に、この種の問題を回避する最善の方法は、多くの場合、根本にある： APIの設計だ。から進化可能なデザインに焦点を当てたデザインファーストのアプローチを使う。
に焦点を当てたデザインファーストのアプローチを使うことだ。変更を余儀なくされた時は、優れた変更管理を行い、最善を望むのだ。

## Summary

要約すると、どのバージョニング・アプローチも完璧ではなく、サーバー側および／またはクライアント側で何らかの痛みを引き起こす可能性が高い。
GraphQLには、継続的な進化を特に魅力的にする一連の機能がありますが、GraphQLのバージョニングも可能です。
可能であれば、常に追加的で後方互換性のある変更を選ぶようにしましょう。
deprecationディレクティブを使用し、その理由引数を独自のツールやベストプラクティスで補強することを恐れないでほしい。
最終的にどのようなアプローチを選んでも、間違いは起こるかもしれない。
最も重要なのは、どのようにコミュニケーションをとり、変更を加えるかだ。

